{
  "language": "Solidity",
  "sources": {
    "@account-abstraction/contracts/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        // User op succeeded.\n        opSucceeded,\n        // User op reverted. Still has to pay for gas.\n        opReverted,\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\n        postOpReverted\n    }\n\n    /**\n     * Payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp          - The user operation.\n     * @param userOpHash      - Hash of the user's request data.\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\n     *                          value of validateUserOperation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                                    other values are invalid for paymaster.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * Post-operation handler.\n     * Must verify sender is the entryPoint.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"
    },
    "@account-abstraction/contracts/interfaces/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/core/Module.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../interfaces/IAvatar.sol\";\nimport \"../factory/FactoryFriendly.sol\";\nimport \"../guard/Guardable.sol\";\n\nabstract contract Module is FactoryFriendly, Guardable {\n    /// @dev Address that will ultimately execute function calls.\n    address public avatar;\n    /// @dev Address that this module will pass transactions to.\n    address public target;\n\n    /// @dev Emitted each time the avatar is set.\n    event AvatarSet(address indexed previousAvatar, address indexed newAvatar);\n    /// @dev Emitted each time the Target is set.\n    event TargetSet(address indexed previousTarget, address indexed newTarget);\n\n    /// @dev Sets the avatar to a new avatar (`newAvatar`).\n    /// @notice Can only be called by the current owner.\n    function setAvatar(address _avatar) public onlyOwner {\n        address previousAvatar = avatar;\n        avatar = _avatar;\n        emit AvatarSet(previousAvatar, _avatar);\n    }\n\n    /// @dev Sets the target to a new target (`newTarget`).\n    /// @notice Can only be called by the current owner.\n    function setTarget(address _target) public onlyOwner {\n        address previousTarget = target;\n        target = _target;\n        emit TargetSet(previousTarget, _target);\n    }\n\n    /// @dev Passes a transaction to be executed by the avatar.\n    /// @notice Can only be called by this contract.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function exec(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (bool success) {\n        /// Check if a transactioon guard is enabled.\n        if (guard != address(0)) {\n            IGuard(guard).checkTransaction(\n                /// Transaction info used by module transactions.\n                to,\n                value,\n                data,\n                operation,\n                /// Zero out the redundant transaction information only used for Safe multisig transctions.\n                0,\n                0,\n                0,\n                address(0),\n                payable(0),\n                bytes(\"0x\"),\n                msg.sender\n            );\n        }\n        success = IAvatar(target).execTransactionFromModule(\n            to,\n            value,\n            data,\n            operation\n        );\n        if (guard != address(0)) {\n            IGuard(guard).checkAfterExecution(bytes32(\"0x\"), success);\n        }\n        return success;\n    }\n\n    /// @dev Passes a transaction to be executed by the target and returns data.\n    /// @notice Can only be called by this contract.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execAndReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (bool success, bytes memory returnData) {\n        /// Check if a transactioon guard is enabled.\n        if (guard != address(0)) {\n            IGuard(guard).checkTransaction(\n                /// Transaction info used by module transactions.\n                to,\n                value,\n                data,\n                operation,\n                /// Zero out the redundant transaction information only used for Safe multisig transctions.\n                0,\n                0,\n                0,\n                address(0),\n                payable(0),\n                bytes(\"0x\"),\n                msg.sender\n            );\n        }\n        (success, returnData) = IAvatar(target)\n            .execTransactionFromModuleReturnData(to, value, data, operation);\n        if (guard != address(0)) {\n            IGuard(guard).checkAfterExecution(bytes32(\"0x\"), success);\n        }\n        return (success, returnData);\n    }\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac FactoryFriendly - A contract that allows other contracts to be initializable and pass bytes as arguments to define contract state\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract FactoryFriendly is OwnableUpgradeable {\n    function setUp(bytes memory initializeParams) public virtual;\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/guard/BaseGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IGuard.sol\";\n\nabstract contract BaseGuard is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == type(IGuard).interfaceId || // 0xe6d7a83a\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    /// @dev Module transactions only use the first four parameters: to, value, data, and operation.\n    /// Module.sol hardcodes the remaining parameters as 0 since they are not used for module transactions.\n    /// @notice This interface is used to maintain compatibilty with Gnosis Safe transaction guards.\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external virtual;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external virtual;\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/guard/Guardable.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./BaseGuard.sol\";\n\n/// @title Guardable - A contract that manages fallback calls made to this contract\ncontract Guardable is OwnableUpgradeable {\n    address public guard;\n\n    event ChangedGuard(address guard);\n\n    /// `guard_` does not implement IERC165.\n    error NotIERC165Compliant(address guard_);\n\n    /// @dev Set a guard that checks transactions before execution.\n    /// @param _guard The address of the guard to be used or the 0 address to disable the guard.\n    function setGuard(address _guard) external onlyOwner {\n        if (_guard != address(0)) {\n            if (!BaseGuard(_guard).supportsInterface(type(IGuard).interfaceId))\n                revert NotIERC165Compliant(_guard);\n        }\n        guard = _guard;\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() external view returns (address _guard) {\n        return guard;\n    }\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IAvatar {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    /// @dev Enables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Modules should be stored as a linked list.\n    /// @notice Must emit EnabledModule(address module) if successful.\n    /// @param module Module to be enabled.\n    function enableModule(address module) external;\n\n    /// @dev Disables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Must emit DisabledModule(address module) if successful.\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) external;\n\n    /// @dev Allows a Module to execute a transaction.\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /// @dev Allows a Module to execute a transaction and return data\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success, bytes memory returnData);\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) external view returns (bool);\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize)\n        external\n        view\n        returns (address[] memory array, address next);\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IGuard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotesUpgradeable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ArraysUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\n    function __ERC20Snapshot_init() internal onlyInitializing {\n    }\n\n    function __ERC20Snapshot_init_unchained() internal onlyInitializing {\n    }\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using ArraysUpgradeable for uint256[];\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    CountersUpgradeable.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20PermitUpgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../governance/utils/IVotesUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, IVotesUpgradeable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../utils/SafeERC20Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the ERC20 token contract to support token wrapping.\n *\n * Users can deposit and withdraw \"underlying tokens\" and receive a matching number of \"wrapped tokens\". This is useful\n * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the\n * wrapping of an existing \"basic\" ERC20 into a governance token.\n *\n * _Available since v4.2._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20WrapperUpgradeable is Initializable, ERC20Upgradeable {\n    IERC20Upgradeable public underlying;\n\n    function __ERC20Wrapper_init(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        __ERC20Wrapper_init_unchained(underlyingToken);\n    }\n\n    function __ERC20Wrapper_init_unchained(IERC20Upgradeable underlyingToken) internal onlyInitializing {\n        underlying = underlyingToken;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20MetadataUpgradeable(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20Upgradeable.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20Upgradeable.safeTransfer(underlying, account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Mint wrapped token to cover any underlyingTokens that would have been transferred by mistake. Internal\n     * function that can be exposed with access control if desired.\n     */\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary ArraysUpgradeable {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/account-abstraction/SmartAccountValidationV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {ILightAccount} from \"../interfaces/ILightAccount.sol\";\nimport {ILightAccountFactory} from \"../interfaces/ILightAccountFactory.sol\";\nimport {PackedUserOperation} from \"@account-abstraction/contracts/interfaces/IPaymaster.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nabstract contract SmartAccountValidationV1 is Initializable {\n    ILightAccountFactory public lightAccountFactory;\n\n    error InvalidSmartAccount();\n    error InvalidUserOpCallDataLength();\n    error InvalidCallData();\n    error InvalidInnerCallDataLength();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __SmartAccountValidationV1_init(\n        address _lightAccountFactory\n    ) internal {\n        lightAccountFactory = ILightAccountFactory(_lightAccountFactory);\n    }\n\n    function validateSmartAccount(\n        address smartAccount\n    ) internal view virtual returns (bool, address) {\n        // First check if the address has code (is a contract)\n        uint256 size;\n        assembly {\n            size := extcodesize(smartAccount)\n        }\n\n        // If it's an EOA (no code), it's not a `LightAccount`\n        if (size == 0) {\n            return (false, address(0));\n        }\n\n        try ILightAccount(smartAccount).owner() returns (\n            address lightAccountOwner\n        ) {\n            // Regenerate the expected light account address\n            address lightAccountAddress = lightAccountFactory.getAddress(\n                lightAccountOwner,\n                0 // we assume that DAO App is only creating one account per user\n            );\n\n            // If the given `smartAccount` address is the same as the derived\n            // `lightAccountAddress`, then we know that the `smartAccount`\n            // was created by the `LightAccountFactory` and therefore can be trusted.\n            return (lightAccountAddress == smartAccount, lightAccountOwner);\n        } catch {\n            // `smartAccount` does not implement `owner()`\n            // so it's definitely not a `LightAccount`\n            return (false, address(0));\n        }\n    }\n\n    function validateUserOp(\n        PackedUserOperation calldata userOp\n    ) internal view virtual returns (address, address, bytes4) {\n        (bool isValid, address lightAccountOwner) = validateSmartAccount(\n            userOp.sender\n        );\n        if (!isValid) {\n            revert InvalidSmartAccount();\n        }\n\n        // If we're here, we've confirmed that the sender is an actual instance of a LightAccount,\n        // and so therefore its \"execute\" function behaves as expected.\n        //\n        // This prevents a potential exploit where a user crafts a malicious UserOp\n        // which targets a contract that is expected to be a LightAccount, but is not,\n        // and allows the implementation of that contract's \"execute\" function to perform\n        // any arbitrary logic (aka logic which does not execute the whitelisted function\n        // encoded in the UserOp).\n\n        // Validate that we have at least 4 bytes for the selector\n        if (userOp.callData.length < 4) {\n            revert InvalidUserOpCallDataLength();\n        }\n\n        // Extract and validate the LightAccount's \"execute\" function selector\n        // 0xb61d27f6 = bytes4(keccak256(\"execute(address,uint256,bytes)\"))\n        if (bytes4(userOp.callData) != 0xb61d27f6) {\n            revert InvalidCallData();\n        }\n\n        // Decode the \"execute\" function parameters\n        (address target, , bytes memory innerCallData) = abi.decode(\n            userOp.callData[4:],\n            (address, uint256, bytes)\n        );\n\n        // Extract the actual function selector from the innerCallData\n        if (innerCallData.length < 4) {\n            revert InvalidInnerCallDataLength();\n        }\n\n        return (lightAccountOwner, target, bytes4(innerCallData));\n    }\n}\n"
    },
    "contracts/azorius/Azorius.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { Module } from \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\nimport { IBaseStrategy } from \"./interfaces/IBaseStrategy.sol\";\nimport { IAzorius, Enum } from \"./interfaces/IAzorius.sol\";\n\n/**\n * A Safe module which allows for composable governance.\n * Azorius conforms to the [Zodiac pattern](https://github.com/gnosis/zodiac) for Safe modules.\n *\n * The Azorius contract acts as a central manager of DAO Proposals, maintaining the specifications\n * of the transactions that comprise a Proposal, but notably not the state of voting.\n *\n * All voting details are delegated to [BaseStrategy](./BaseStrategy.md) implementations, of which an Azorius DAO can\n * have any number.\n */\ncontract Azorius is Module, IAzorius {\n\n    /**\n     * The sentinel node of the linked list of enabled [BaseStrategies](./BaseStrategy.md).\n     *\n     * See https://en.wikipedia.org/wiki/Sentinel_node.\n     */\n    address internal constant SENTINEL_STRATEGY = address(0x1);\n\n    /**\n     * ```\n     * keccak256(\n     *      \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n     * );\n     * ```\n     *\n     * A unique hash intended to prevent signature collisions.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-712.\n     */\n    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    /**\n     * ```\n     * keccak256(\n     *      \"Transaction(address to,uint256 value,bytes data,uint8 operation,uint256 nonce)\"\n     * );\n     * ```\n     *\n     * See https://eips.ethereum.org/EIPS/eip-712.\n     */\n    bytes32 public constant TRANSACTION_TYPEHASH =\n        0x72e9670a7ee00f5fbf1049b8c38e3f22fab7e9b85029e85cf9412f17fdd5c2ad;\n\n    /** Total number of submitted Proposals. */\n    uint32 public totalProposalCount;\n\n    /** Delay (in blocks) between when a Proposal is passed and when it can be executed. */\n    uint32 public timelockPeriod;\n\n    /** Time (in blocks) between when timelock ends and the Proposal expires. */\n    uint32 public executionPeriod;\n\n    /** Proposals by `proposalId`. */\n    mapping(uint256 => Proposal) internal proposals;\n\n    /** A linked list of enabled [BaseStrategies](./BaseStrategy.md). */\n    mapping(address => address) internal strategies;\n\n    event AzoriusSetUp(\n        address indexed creator,\n        address indexed owner,\n        address indexed avatar,\n        address target\n    );\n    event ProposalCreated(\n        address strategy,\n        uint256 proposalId,\n        address proposer,\n        Transaction[] transactions,\n        string metadata\n    );\n    event ProposalExecuted(uint32 proposalId, bytes32[] txHashes);\n    event EnabledStrategy(address strategy);\n    event DisabledStrategy(address strategy);\n    event TimelockPeriodUpdated(uint32 timelockPeriod);\n    event ExecutionPeriodUpdated(uint32 executionPeriod);\n\n    error InvalidStrategy();\n    error StrategyEnabled();\n    error StrategyDisabled();\n    error InvalidProposal();\n    error InvalidProposer();\n    error ProposalNotExecutable();\n    error InvalidTxHash();\n    error TxFailed();\n    error InvalidTxs();\n    error InvalidArrayLengths();\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /**\n     * Initial setup of the Azorius instance.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`, \n     * `address _avatar`, `address _target`, `address[] memory _strategies`,\n     * `uint256 _timelockPeriod`, `uint256 _executionPeriod`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (\n            address _owner,\n            address _avatar,\n            address _target,                \n            address[] memory _strategies,   // enabled BaseStrategies\n            uint32 _timelockPeriod,        // initial timelockPeriod\n            uint32 _executionPeriod        // initial executionPeriod\n        ) = abi.decode(\n                initializeParams,\n                (address, address, address, address[], uint32, uint32)\n            );\n        __Ownable_init();\n        avatar = _avatar;\n        target = _target;\n        _setUpStrategies(_strategies);\n        transferOwnership(_owner);\n        _updateTimelockPeriod(_timelockPeriod);\n        _updateExecutionPeriod(_executionPeriod);\n\n        emit AzoriusSetUp(msg.sender, _owner, _avatar, _target);\n    }\n\n    /** @inheritdoc IAzorius*/\n    function updateTimelockPeriod(uint32 _timelockPeriod) external onlyOwner {\n        _updateTimelockPeriod(_timelockPeriod);\n    }\n\n    /** @inheritdoc IAzorius*/\n    function updateExecutionPeriod(uint32 _executionPeriod) external onlyOwner {\n        _updateExecutionPeriod(_executionPeriod);\n    }\n\n    /** @inheritdoc IAzorius*/\n    function submitProposal(\n        address _strategy,\n        bytes memory _data,\n        Transaction[] calldata _transactions,\n        string calldata _metadata\n    ) external {\n        if (!isStrategyEnabled(_strategy)) revert StrategyDisabled();\n        if (!IBaseStrategy(_strategy).isProposer(msg.sender))\n            revert InvalidProposer();\n\n        bytes32[] memory txHashes = new bytes32[](_transactions.length);\n        uint256 transactionsLength = _transactions.length;\n        for (uint256 i; i < transactionsLength; ) {\n            txHashes[i] = getTxHash(\n                _transactions[i].to,\n                _transactions[i].value,\n                _transactions[i].data,\n                _transactions[i].operation\n            );\n            unchecked {\n                ++i;\n            }\n        }\n\n        proposals[totalProposalCount].strategy = _strategy;\n        proposals[totalProposalCount].txHashes = txHashes;\n        proposals[totalProposalCount].timelockPeriod = timelockPeriod;\n        proposals[totalProposalCount].executionPeriod = executionPeriod;\n\n        // not all strategy contracts will necessarily use the txHashes and _data values\n        // they are encoded to support any strategy contracts that may need them\n        IBaseStrategy(_strategy).initializeProposal(\n            abi.encode(totalProposalCount, txHashes, _data)\n        );\n\n        emit ProposalCreated(\n            _strategy,\n            totalProposalCount,\n            msg.sender,\n            _transactions,\n            _metadata\n        );\n\n        totalProposalCount++;\n    }\n\n    /** @inheritdoc IAzorius*/\n    function executeProposal(\n        uint32 _proposalId,\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _data,\n        Enum.Operation[] memory _operations\n    ) external {\n        if (_targets.length == 0) revert InvalidTxs();\n        if (\n            _targets.length != _values.length ||\n            _targets.length != _data.length ||\n            _targets.length != _operations.length\n        ) revert InvalidArrayLengths();\n        if (\n            proposals[_proposalId].executionCounter + _targets.length >\n            proposals[_proposalId].txHashes.length\n        ) revert InvalidTxs();\n        uint256 targetsLength = _targets.length;\n        bytes32[] memory txHashes = new bytes32[](targetsLength);\n        for (uint256 i; i < targetsLength; ) {\n            txHashes[i] = _executeProposalTx(\n                _proposalId,\n                _targets[i],\n                _values[i],\n                _data[i],\n                _operations[i]\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        emit ProposalExecuted(_proposalId, txHashes);\n    }\n\n    /** @inheritdoc IAzorius*/\n    function getStrategies(\n        address _startAddress,\n        uint256 _count\n    ) external view returns (address[] memory _strategies, address _next) {\n        // init array with max page size\n        _strategies = new address[](_count);\n\n        // populate return array\n        uint256 strategyCount = 0;\n        address currentStrategy = strategies[_startAddress];\n        while (\n            currentStrategy != address(0x0) &&\n            currentStrategy != SENTINEL_STRATEGY &&\n            strategyCount < _count\n        ) {\n            _strategies[strategyCount] = currentStrategy;\n            currentStrategy = strategies[currentStrategy];\n            strategyCount++;\n        }\n        _next = currentStrategy;\n        // set correct size of returned array\n        assembly {\n            mstore(_strategies, strategyCount)\n        }\n    }\n\n    /** @inheritdoc IAzorius*/\n    function getProposalTxHash(uint32 _proposalId, uint32 _txIndex) external view returns (bytes32) {\n        return proposals[_proposalId].txHashes[_txIndex];\n    }\n\n    /** @inheritdoc IAzorius*/\n    function getProposalTxHashes(uint32 _proposalId) external view returns (bytes32[] memory) {\n        return proposals[_proposalId].txHashes;\n    }\n\n    /** @inheritdoc IAzorius*/\n    function getProposal(uint32 _proposalId) external view\n        returns (\n            address _strategy,\n            bytes32[] memory _txHashes,\n            uint32 _timelockPeriod,\n            uint32 _executionPeriod,\n            uint32 _executionCounter\n        )\n    {\n        _strategy = proposals[_proposalId].strategy;\n        _txHashes = proposals[_proposalId].txHashes;\n        _timelockPeriod = proposals[_proposalId].timelockPeriod;\n        _executionPeriod = proposals[_proposalId].executionPeriod;\n        _executionCounter = proposals[_proposalId].executionCounter;\n    }\n\n    /** @inheritdoc IAzorius*/\n    function enableStrategy(address _strategy) public override onlyOwner {\n        if (_strategy == address(0) || _strategy == SENTINEL_STRATEGY)\n            revert InvalidStrategy();\n        if (strategies[_strategy] != address(0)) revert StrategyEnabled();\n\n        strategies[_strategy] = strategies[SENTINEL_STRATEGY];\n        strategies[SENTINEL_STRATEGY] = _strategy;\n\n        emit EnabledStrategy(_strategy);\n    }\n\n    /** @inheritdoc IAzorius*/\n    function disableStrategy(address _prevStrategy, address _strategy) public onlyOwner {\n        if (_strategy == address(0) || _strategy == SENTINEL_STRATEGY)\n            revert InvalidStrategy();\n        if (strategies[_prevStrategy] != _strategy) revert StrategyDisabled();\n\n        strategies[_prevStrategy] = strategies[_strategy];\n        strategies[_strategy] = address(0);\n\n        emit DisabledStrategy(_strategy);\n    }\n\n    /** @inheritdoc IAzorius*/\n    function isStrategyEnabled(address _strategy) public view returns (bool) {\n        return\n            SENTINEL_STRATEGY != _strategy &&\n            strategies[_strategy] != address(0);\n    }\n\n    /** @inheritdoc IAzorius*/\n    function proposalState(uint32 _proposalId) public view returns (ProposalState) {\n        Proposal memory _proposal = proposals[_proposalId];\n\n        if (_proposal.strategy == address(0)) revert InvalidProposal();\n\n        IBaseStrategy _strategy = IBaseStrategy(_proposal.strategy);\n\n        uint256 votingEndBlock = _strategy.votingEndBlock(_proposalId);\n\n        if (block.number <= votingEndBlock) {\n            return ProposalState.ACTIVE;\n        } else if (!_strategy.isPassed(_proposalId)) {\n            return ProposalState.FAILED;\n        } else if (_proposal.executionCounter == _proposal.txHashes.length) {\n            // a Proposal with 0 transactions goes straight to EXECUTED\n            // this allows for the potential for on-chain voting for \n            // \"off-chain\" executed decisions\n            return ProposalState.EXECUTED;\n        } else if (block.number <= votingEndBlock + _proposal.timelockPeriod) {\n            return ProposalState.TIMELOCKED;\n        } else if (\n            block.number <=\n            votingEndBlock +\n                _proposal.timelockPeriod +\n                _proposal.executionPeriod\n        ) {\n            return ProposalState.EXECUTABLE;\n        } else {\n            return ProposalState.EXPIRED;\n        }\n    }\n\n    /** @inheritdoc IAzorius*/\n    function generateTxHashData(\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        uint256 chainId = block.chainid;\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this)\n        );\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                TRANSACTION_TYPEHASH,\n                _to,\n                _value,\n                keccak256(_data),\n                _operation,\n                _nonce\n            )\n        );\n        return\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x01),\n                domainSeparator,\n                transactionHash\n            );\n    }\n\n    /** @inheritdoc IAzorius*/\n    function getTxHash(\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation\n    ) public view returns (bytes32) {\n        return keccak256(generateTxHashData(_to, _value, _data, _operation, 0));\n    }\n\n    /**\n     * Executes the specified transaction in a Proposal, by index.\n     * Transactions in a Proposal must be called in order.\n     *\n     * @param _proposalId identifier of the proposal\n     * @param _target contract to be called by the avatar\n     * @param _value ETH value to pass with the call\n     * @param _data data to be executed from the call\n     * @param _operation Call or Delegatecall\n     */\n    function _executeProposalTx(\n        uint32 _proposalId,\n        address _target,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation\n    ) internal returns (bytes32 txHash) {\n        if (proposalState(_proposalId) != ProposalState.EXECUTABLE)\n            revert ProposalNotExecutable();\n        txHash = getTxHash(_target, _value, _data, _operation);\n        if (\n            proposals[_proposalId].txHashes[\n                proposals[_proposalId].executionCounter\n            ] != txHash\n        ) revert InvalidTxHash();\n\n        proposals[_proposalId].executionCounter++;\n        \n        if (!exec(_target, _value, _data, _operation)) revert TxFailed();\n    }\n\n    /**\n     * Enables the specified array of [BaseStrategy](./BaseStrategy.md) contract addresses.\n     *\n     * @param _strategies array of `BaseStrategy` contract addresses to enable\n     */\n    function _setUpStrategies(address[] memory _strategies) internal {\n        strategies[SENTINEL_STRATEGY] = SENTINEL_STRATEGY;\n        uint256 strategiesLength = _strategies.length;\n        for (uint256 i; i < strategiesLength; ) {\n            enableStrategy(_strategies[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * Updates the `timelockPeriod` for future Proposals.\n     *\n     * @param _timelockPeriod new timelock period (in blocks)\n     */\n    function _updateTimelockPeriod(uint32 _timelockPeriod) internal {\n        timelockPeriod = _timelockPeriod;\n        emit TimelockPeriodUpdated(_timelockPeriod);\n    }\n\n    /**\n     * Updates the `executionPeriod` for future Proposals.\n     *\n     * @param _executionPeriod new execution period (in blocks)\n     */\n    function _updateExecutionPeriod(uint32 _executionPeriod) internal {\n        executionPeriod = _executionPeriod;\n        emit ExecutionPeriodUpdated(_executionPeriod);\n    }\n}\n"
    },
    "contracts/azorius/BaseQuorumPercent.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * An Azorius extension contract that enables percent based quorums.\n * Intended to be implemented by [BaseStrategy](./BaseStrategy.md) implementations.\n */\nabstract contract BaseQuorumPercent is OwnableUpgradeable {\n    \n    /** The numerator to use when calculating quorum (adjustable). */\n    uint256 public quorumNumerator;\n\n    /** The denominator to use when calculating quorum (1,000,000). */\n    uint256 public constant QUORUM_DENOMINATOR = 1_000_000;\n\n    /** Ensures the numerator cannot be larger than the denominator. */\n    error InvalidQuorumNumerator();\n\n    event QuorumNumeratorUpdated(uint256 quorumNumerator);\n\n    /** \n     * Updates the quorum required for future Proposals.\n     *\n     * @param _quorumNumerator numerator to use when calculating quorum (over 1,000,000)\n     */\n    function updateQuorumNumerator(uint256 _quorumNumerator) public virtual onlyOwner {\n        _updateQuorumNumerator(_quorumNumerator);\n    }\n\n    /** Internal implementation of `updateQuorumNumerator`. */\n    function _updateQuorumNumerator(uint256 _quorumNumerator) internal virtual {\n        if (_quorumNumerator > QUORUM_DENOMINATOR)\n            revert InvalidQuorumNumerator();\n\n        quorumNumerator = _quorumNumerator;\n\n        emit QuorumNumeratorUpdated(_quorumNumerator);\n    }\n\n    /**\n     * Calculates whether a vote meets quorum. This is calculated based on yes votes + abstain\n     * votes.\n     *\n     * @param _totalSupply the total supply of tokens\n     * @param _yesVotes number of votes in favor\n     * @param _abstainVotes number of votes abstaining\n     * @return bool whether the total number of yes votes + abstain meets the quorum\n     */\n    function meetsQuorum(uint256 _totalSupply, uint256 _yesVotes, uint256 _abstainVotes) public view returns (bool) {\n        return _yesVotes + _abstainVotes >= (_totalSupply * quorumNumerator) / QUORUM_DENOMINATOR;\n    }\n\n    /**\n     * Calculates the total number of votes required for a proposal to meet quorum.\n     * \n     * @param _proposalId The ID of the proposal to get quorum votes for\n     * @return uint256 The quantity of votes required to meet quorum\n     */\n    function quorumVotes(uint32 _proposalId) public view virtual returns (uint256);\n}\n"
    },
    "contracts/azorius/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { IAzorius } from \"./interfaces/IAzorius.sol\";\nimport { IBaseStrategy } from \"./interfaces/IBaseStrategy.sol\";\nimport { FactoryFriendly } from \"@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * The base abstract contract for all voting strategies in Azorius.\n */\nabstract contract BaseStrategy is OwnableUpgradeable, FactoryFriendly, IBaseStrategy {\n\n    event AzoriusSet(address indexed azoriusModule);\n    event StrategySetUp(address indexed azoriusModule, address indexed owner);\n\n    error OnlyAzorius();\n\n    IAzorius public azoriusModule;\n\n    /**\n     * Ensures that only the [Azorius](./Azorius.md) contract that pertains to this \n     * [BaseStrategy](./BaseStrategy.md) can call functions on it.\n     */\n    modifier onlyAzorius() {\n        if (msg.sender != address(azoriusModule)) revert OnlyAzorius();\n        _;\n    }\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /** @inheritdoc IBaseStrategy*/\n    function setAzorius(address _azoriusModule) external onlyOwner {\n        azoriusModule = IAzorius(_azoriusModule);\n        emit AzoriusSet(_azoriusModule);\n    }\n\n    /** @inheritdoc IBaseStrategy*/\n    function initializeProposal(bytes memory _data) external virtual;\n\n    /** @inheritdoc IBaseStrategy*/\n    function isPassed(uint32 _proposalId) external view virtual returns (bool);\n\n    /** @inheritdoc IBaseStrategy*/\n    function isProposer(address _address) external view virtual returns (bool);\n\n    /** @inheritdoc IBaseStrategy*/\n    function votingEndBlock(uint32 _proposalId) external view virtual returns (uint32);\n\n    /**\n     * Sets the address of the [Azorius](Azorius.md) module contract.\n     *\n     * @param _azoriusModule address of the Azorius module\n     */\n    function _setAzorius(address _azoriusModule) internal {\n        azoriusModule = IAzorius(_azoriusModule);\n        emit AzoriusSet(_azoriusModule);\n    }\n}\n"
    },
    "contracts/azorius/BaseVotingBasisPercent.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * An Azorius extension contract that enables percent based voting basis calculations.\n *\n * Intended to be implemented by BaseStrategy implementations, this allows for voting strategies\n * to dictate any basis strategy for passing a Proposal between >50% (simple majority) to 100%.\n *\n * See https://en.wikipedia.org/wiki/Voting#Voting_basis.\n * See https://en.wikipedia.org/wiki/Supermajority.\n */\nabstract contract BaseVotingBasisPercent is OwnableUpgradeable {\n    \n    /** The numerator to use when calculating basis (adjustable). */\n    uint256 public basisNumerator;\n\n    /** The denominator to use when calculating basis (1,000,000). */\n    uint256 public constant BASIS_DENOMINATOR = 1_000_000;\n\n    error InvalidBasisNumerator();\n\n    event BasisNumeratorUpdated(uint256 basisNumerator);\n\n    /**\n     * Updates the `basisNumerator` for future Proposals.\n     *\n     * @param _basisNumerator numerator to use\n     */\n    function updateBasisNumerator(uint256 _basisNumerator) public virtual onlyOwner {\n        _updateBasisNumerator(_basisNumerator);\n    }\n\n    /** Internal implementation of `updateBasisNumerator`. */\n    function _updateBasisNumerator(uint256 _basisNumerator) internal virtual {\n        if (_basisNumerator > BASIS_DENOMINATOR || _basisNumerator < BASIS_DENOMINATOR / 2)\n            revert InvalidBasisNumerator();\n\n        basisNumerator = _basisNumerator;\n\n        emit BasisNumeratorUpdated(_basisNumerator);\n    }\n\n    /**\n     * Calculates whether a vote meets its basis.\n     *\n     * @param _yesVotes number of votes in favor\n     * @param _noVotes number of votes against\n     * @return bool whether the yes votes meets the set basis\n     */\n    function meetsBasis(uint256 _yesVotes, uint256 _noVotes) public view returns (bool) {\n        return _yesVotes > (_yesVotes + _noVotes) * basisNumerator / BASIS_DENOMINATOR;\n    }\n}\n"
    },
    "contracts/azorius/interfaces/IAzorius.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\n/**\n * The base interface for the Azorius governance Safe module.\n * Azorius conforms to the Zodiac pattern for Safe modules: https://github.com/gnosis/zodiac\n *\n * Azorius manages the state of Proposals submitted to a DAO, along with the associated strategies\n * ([BaseStrategy](../BaseStrategy.md)) for voting that are enabled on the DAO.\n *\n * Any given DAO can support multiple voting BaseStrategies, and these strategies are intended to be\n * as customizable as possible.\n *\n * Proposals begin in the `ACTIVE` state and will ultimately end in either\n * the `EXECUTED`, `EXPIRED`, or `FAILED` state.\n *\n * `ACTIVE` - a new proposal begins in this state, and stays in this state\n *          for the duration of its voting period.\n *\n * `TIMELOCKED` - A proposal that passes enters the `TIMELOCKED` state, during which\n *          it cannot yet be executed.  This is to allow time for token holders\n *          to potentially exit their position, as well as parent DAOs time to\n *          initiate a freeze, if they choose to do so. A proposal stays timelocked\n *          for the duration of its `timelockPeriod`.\n *\n * `EXECUTABLE` - Following the `TIMELOCKED` state, a passed proposal becomes `EXECUTABLE`,\n *          and can then finally be executed on chain by anyone.\n *\n * `EXECUTED` - the final state for a passed proposal.  The proposal has been executed\n *          on the blockchain.\n *\n * `EXPIRED` - a passed proposal which is not executed before its `executionPeriod` has\n *          elapsed will be `EXPIRED`, and can no longer be executed.\n *\n * `FAILED` - a failed proposal (as defined by its [BaseStrategy](../BaseStrategy.md) \n *          `isPassed` function). For a basic strategy, this would mean it received more \n *          NO votes than YES or did not achieve quorum. \n */\ninterface IAzorius {\n\n    /** Represents a transaction to perform on the blockchain. */\n    struct Transaction {\n        address to; // destination address of the transaction\n        uint256 value; // amount of ETH to transfer with the transaction\n        bytes data; // encoded function call data of the transaction\n        Enum.Operation operation; // Operation type, Call or DelegateCall\n    }\n\n    /** Holds details pertaining to a single proposal. */\n    struct Proposal {\n        uint32 executionCounter; // count of transactions that have been executed within the proposal\n        uint32 timelockPeriod; // time (in blocks) this proposal will be timelocked for if it passes\n        uint32 executionPeriod; // time (in blocks) this proposal has to be executed after timelock ends before it is expired\n        address strategy; // BaseStrategy contract this proposal was created on\n        bytes32[] txHashes; // hashes of the transactions that are being proposed\n    }\n\n    /** The list of states in which a Proposal can be in at any given time. */\n    enum ProposalState {\n        ACTIVE,\n        TIMELOCKED,\n        EXECUTABLE,\n        EXECUTED,\n        EXPIRED,\n        FAILED\n    }\n\n    /**\n     * Enables a [BaseStrategy](../BaseStrategy.md) implementation for newly created Proposals.\n     *\n     * Multiple strategies can be enabled, and new Proposals will be able to be\n     * created using any of the currently enabled strategies.\n     *\n     * @param _strategy contract address of the BaseStrategy to be enabled\n     */\n    function enableStrategy(address _strategy) external;\n\n    /**\n     * Disables a previously enabled [BaseStrategy](../BaseStrategy.md) implementation for new proposals.\n     * This has no effect on existing Proposals, either `ACTIVE` or completed.\n     *\n     * @param _prevStrategy BaseStrategy address that pointed in the linked list to the strategy to be removed\n     * @param _strategy address of the BaseStrategy to be removed\n     */\n    function disableStrategy(address _prevStrategy, address _strategy) external;\n\n    /**\n     * Updates the `timelockPeriod` for newly created Proposals.\n     * This has no effect on existing Proposals, either `ACTIVE` or completed.\n     *\n     * @param _timelockPeriod timelockPeriod (in blocks) to be used for new Proposals\n     */\n    function updateTimelockPeriod(uint32 _timelockPeriod) external;\n\n    /**\n     * Updates the execution period for future Proposals.\n     *\n     * @param _executionPeriod new execution period (in blocks)\n     */\n    function updateExecutionPeriod(uint32 _executionPeriod) external;\n\n    /**\n     * Submits a new Proposal, using one of the enabled [BaseStrategies](../BaseStrategy.md).\n     * New Proposals begin immediately in the `ACTIVE` state.\n     *\n     * @param _strategy address of the BaseStrategy implementation which the Proposal will use\n     * @param _data arbitrary data passed to the BaseStrategy implementation. This may not be used by all strategies, \n     * but is included in case future strategy contracts have a need for it\n     * @param _transactions array of transactions to propose\n     * @param _metadata additional data such as a title/description to submit with the proposal\n     */\n    function submitProposal(\n        address _strategy,\n        bytes memory _data,\n        Transaction[] calldata _transactions,\n        string calldata _metadata\n    ) external;\n\n    /**\n     * Executes all transactions within a Proposal.\n     * This will only be able to be called if the Proposal passed.\n     *\n     * @param _proposalId identifier of the Proposal\n     * @param _targets target contracts for each transaction\n     * @param _values ETH values to be sent with each transaction\n     * @param _data transaction data to be executed\n     * @param _operations Calls or Delegatecalls\n     */\n    function executeProposal(\n        uint32 _proposalId,\n        address[] memory _targets,\n        uint256[] memory _values,\n        bytes[] memory _data,\n        Enum.Operation[] memory _operations\n    ) external;\n\n    /**\n     * Returns whether a [BaseStrategy](../BaseStrategy.md) implementation is enabled.\n     *\n     * @param _strategy contract address of the BaseStrategy to check\n     * @return bool True if the strategy is enabled, otherwise False\n     */\n    function isStrategyEnabled(address _strategy) external view returns (bool);\n\n    /**\n     * Returns an array of enabled [BaseStrategy](../BaseStrategy.md) contract addresses.\n     * Because the list of BaseStrategies is technically unbounded, this\n     * requires the address of the first strategy you would like, along\n     * with the total count of strategies to return, rather than\n     * returning the whole list at once.\n     *\n     * @param _startAddress contract address of the BaseStrategy to start with\n     * @param _count maximum number of BaseStrategies that should be returned\n     * @return _strategies array of BaseStrategies\n     * @return _next next BaseStrategy contract address in the linked list\n     */\n    function getStrategies(\n        address _startAddress,\n        uint256 _count\n    ) external view returns (address[] memory _strategies, address _next);\n\n    /**\n     * Gets the state of a Proposal.\n     *\n     * @param _proposalId identifier of the Proposal\n     * @return ProposalState uint256 ProposalState enum value representing the\n     *         current state of the proposal\n     */\n    function proposalState(uint32 _proposalId) external view returns (ProposalState);\n\n    /**\n     * Generates the data for the module transaction hash (required for signing).\n     *\n     * @param _to target address of the transaction\n     * @param _value ETH value to send with the transaction\n     * @param _data encoded function call data of the transaction\n     * @param _operation Enum.Operation to use for the transaction\n     * @param _nonce Safe nonce of the transaction\n     * @return bytes hashed transaction data\n     */\n    function generateTxHashData(\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation,\n        uint256 _nonce\n    ) external view returns (bytes memory);\n\n    /**\n     * Returns the `keccak256` hash of the specified transaction.\n     *\n     * @param _to target address of the transaction\n     * @param _value ETH value to send with the transaction\n     * @param _data encoded function call data of the transaction\n     * @param _operation Enum.Operation to use for the transaction\n     * @return bytes32 transaction hash\n     */\n    function getTxHash(\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation\n    ) external view returns (bytes32);\n\n    /**\n     * Returns the hash of a transaction in a Proposal.\n     *\n     * @param _proposalId identifier of the Proposal\n     * @param _txIndex index of the transaction within the Proposal\n     * @return bytes32 hash of the specified transaction\n     */\n    function getProposalTxHash(uint32 _proposalId, uint32 _txIndex) external view returns (bytes32);\n\n    /**\n     * Returns the transaction hashes associated with a given `proposalId`.\n     *\n     * @param _proposalId identifier of the Proposal to get transaction hashes for\n     * @return bytes32[] array of transaction hashes\n     */\n    function getProposalTxHashes(uint32 _proposalId) external view returns (bytes32[] memory);\n\n    /**\n     * Returns details about the specified Proposal.\n     *\n     * @param _proposalId identifier of the Proposal\n     * @return _strategy address of the BaseStrategy contract the Proposal is on\n     * @return _txHashes hashes of the transactions the Proposal contains\n     * @return _timelockPeriod time (in blocks) the Proposal is timelocked for\n     * @return _executionPeriod time (in blocks) the Proposal must be executed within, after timelock ends\n     * @return _executionCounter counter of how many of the Proposals transactions have been executed\n     */\n    function getProposal(uint32 _proposalId) external view\n        returns (\n            address _strategy,\n            bytes32[] memory _txHashes,\n            uint32 _timelockPeriod,\n            uint32 _executionPeriod,\n            uint32 _executionCounter\n        );\n}\n"
    },
    "contracts/azorius/interfaces/IBaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\n/**\n * The specification for a voting strategy in Azorius.\n *\n * Each IBaseStrategy implementation need only implement the given functions here,\n * which allows for highly composable but simple or complex voting strategies.\n *\n * It should be noted that while many voting strategies make use of parameters such as\n * voting period or quorum, that is a detail of the individual strategy itself, and not\n * a requirement for the Azorius protocol.\n */\ninterface IBaseStrategy {\n\n    /**\n     * Sets the address of the [Azorius](../Azorius.md) contract this \n     * [BaseStrategy](../BaseStrategy.md) is being used on.\n     *\n     * @param _azoriusModule address of the Azorius Safe module\n     */\n    function setAzorius(address _azoriusModule) external;\n\n    /**\n     * Called by the [Azorius](../Azorius.md) module. This notifies this \n     * [BaseStrategy](../BaseStrategy.md) that a new Proposal has been created.\n     *\n     * @param _data arbitrary data to pass to this BaseStrategy\n     */\n    function initializeProposal(bytes memory _data) external;\n\n    /**\n     * Returns whether a Proposal has been passed.\n     *\n     * @param _proposalId proposalId to check\n     * @return bool true if the proposal has passed, otherwise false\n     */\n    function isPassed(uint32 _proposalId) external view returns (bool);\n\n    /**\n     * Returns whether the specified address can submit a Proposal with\n     * this [BaseStrategy](../BaseStrategy.md).\n     *\n     * This allows a BaseStrategy to place any limits it would like on\n     * who can create new Proposals, such as requiring a minimum token\n     * delegation.\n     *\n     * @param _address address to check\n     * @return bool true if the address can submit a Proposal, otherwise false\n     */\n    function isProposer(address _address) external view returns (bool);\n\n    /**\n     * Returns the block number voting ends on a given Proposal.\n     *\n     * @param _proposalId proposalId to check\n     * @return uint32 block number when voting ends on the Proposal\n     */\n    function votingEndBlock(uint32 _proposalId) external view returns (uint32);\n}\n"
    },
    "contracts/azorius/interfaces/IERC721VotingStrategy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\n/**\n * Interface of functions required for ERC-721 freeze voting associated with an ERC-721\n * voting strategy.\n */\ninterface IERC721VotingStrategy {\n\n    /**\n     * Returns the current token weight for the given ERC-721 token address.\n     *\n     * @param _tokenAddress the ERC-721 token address\n     */\n    function getTokenWeight(address _tokenAddress) external view returns (uint256);\n}\n"
    },
    "contracts/azorius/LinearERC20Voting.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { IVotes } from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport { BaseStrategy, IBaseStrategy } from \"./BaseStrategy.sol\";\nimport { BaseQuorumPercent } from \"./BaseQuorumPercent.sol\";\nimport { BaseVotingBasisPercent } from \"./BaseVotingBasisPercent.sol\";\n\n /**\n  * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that \n  * enables linear (i.e. 1 to 1) token voting. Each token delegated to a given address \n  * in an `ERC20Votes` token equals 1 vote for a Proposal.\n  */\ncontract LinearERC20Voting is BaseStrategy, BaseQuorumPercent, BaseVotingBasisPercent {\n\n    /**\n     * The voting options for a Proposal.\n     */\n    enum VoteType {\n        NO,     // disapproves of executing the Proposal\n        YES,    // approves of executing the Proposal\n        ABSTAIN // neither YES nor NO, i.e. voting \"present\"\n    }\n\n    /**\n     * Defines the current state of votes on a particular Proposal.\n     */\n    struct ProposalVotes {\n        uint32 votingStartBlock; // block that voting starts at\n        uint32 votingEndBlock; // block that voting ends\n        uint256 noVotes; // current number of NO votes for the Proposal\n        uint256 yesVotes; // current number of YES votes for the Proposal\n        uint256 abstainVotes; // current number of ABSTAIN votes for the Proposal\n        mapping(address => bool) hasVoted; // whether a given address has voted yet or not\n    }\n\n    IVotes public governanceToken;\n\n    /** Number of blocks a new Proposal can be voted on. */\n    uint32 public votingPeriod;\n\n    /** Voting weight required to be able to submit Proposals. */\n    uint256 public requiredProposerWeight;\n\n    /** `proposalId` to `ProposalVotes`, the voting state of a Proposal. */\n    mapping(uint256 => ProposalVotes) internal proposalVotes;\n\n    event VotingPeriodUpdated(uint32 votingPeriod);\n    event RequiredProposerWeightUpdated(uint256 requiredProposerWeight);\n    event ProposalInitialized(uint32 proposalId, uint32 votingEndBlock);\n    event Voted(address voter, uint32 proposalId, uint8 voteType, uint256 weight);\n\n    error InvalidProposal();\n    error VotingEnded();\n    error AlreadyVoted();\n    error InvalidVote();\n    error InvalidTokenAddress();\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `ERC20Votes _governanceToken`, `address _azoriusModule`, `uint32 _votingPeriod`,\n     * `uint256 _quorumNumerator`, `uint256 _basisNumerator`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (\n            address _owner,\n            IVotes _governanceToken,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _requiredProposerWeight,\n            uint256 _quorumNumerator,\n            uint256 _basisNumerator\n        ) = abi.decode(\n                initializeParams,\n                (address, IVotes, address, uint32, uint256, uint256, uint256)\n            );\n        if (address(_governanceToken) == address(0))\n            revert InvalidTokenAddress();\n\n        governanceToken = _governanceToken;\n        __Ownable_init();\n        transferOwnership(_owner);\n        _setAzorius(_azoriusModule);\n        _updateQuorumNumerator(_quorumNumerator);\n        _updateBasisNumerator(_basisNumerator);\n        _updateVotingPeriod(_votingPeriod);\n        _updateRequiredProposerWeight(_requiredProposerWeight);\n\n        emit StrategySetUp(_azoriusModule, _owner);\n    }\n\n    /**\n     * Updates the voting time period for new Proposals.\n     *\n     * @param _votingPeriod voting time period (in blocks)\n     */\n    function updateVotingPeriod(uint32 _votingPeriod) external onlyOwner {\n        _updateVotingPeriod(_votingPeriod);\n    }\n\n    /**\n     * Updates the voting weight required to submit new Proposals.\n     *\n     * @param _requiredProposerWeight required token voting weight\n     */\n    function updateRequiredProposerWeight(uint256 _requiredProposerWeight) external onlyOwner {\n        _updateRequiredProposerWeight(_requiredProposerWeight);\n    }\n\n    /**\n     * Casts votes for a Proposal, equal to the caller's token delegation.\n     *\n     * @param _proposalId id of the Proposal to vote on\n     * @param _voteType Proposal support as defined in VoteType (NO, YES, ABSTAIN)\n     */\n    function vote(uint32 _proposalId, uint8 _voteType) external {\n        _vote(\n            _proposalId,\n            msg.sender,\n            _voteType,\n            getVotingWeight(msg.sender, _proposalId)\n        );\n    }\n\n    /**\n     * Returns the current state of the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @return noVotes current count of \"NO\" votes\n     * @return yesVotes current count of \"YES\" votes\n     * @return abstainVotes current count of \"ABSTAIN\" votes\n     * @return startBlock block number voting starts\n     * @return endBlock block number voting ends\n     */\n    function getProposalVotes(uint32 _proposalId) external view\n        returns (\n            uint256 noVotes,\n            uint256 yesVotes,\n            uint256 abstainVotes,\n            uint32 startBlock,\n            uint32 endBlock,\n            uint256 votingSupply\n        )\n    {\n        noVotes = proposalVotes[_proposalId].noVotes;\n        yesVotes = proposalVotes[_proposalId].yesVotes;\n        abstainVotes = proposalVotes[_proposalId].abstainVotes;\n        startBlock = proposalVotes[_proposalId].votingStartBlock;\n        endBlock = proposalVotes[_proposalId].votingEndBlock;\n        votingSupply = getProposalVotingSupply(_proposalId);\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function initializeProposal(bytes memory _data) public virtual override onlyAzorius {\n        uint32 proposalId = abi.decode(_data, (uint32));\n        uint32 _votingEndBlock = uint32(block.number) + votingPeriod;\n\n        proposalVotes[proposalId].votingEndBlock = _votingEndBlock;\n        proposalVotes[proposalId].votingStartBlock = uint32(block.number);\n\n        emit ProposalInitialized(proposalId, _votingEndBlock);\n    }\n    \n    /**\n     * Returns whether an address has voted on the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal to check\n     * @param _address address to check\n     * @return bool true if the address has voted on the Proposal, otherwise false\n     */\n    function hasVoted(uint32 _proposalId, address _address) public view returns (bool) {\n        return proposalVotes[_proposalId].hasVoted[_address];\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isPassed(uint32 _proposalId) public view override returns (bool) {\n        return (\n            block.number > proposalVotes[_proposalId].votingEndBlock && // voting period has ended\n            meetsQuorum(getProposalVotingSupply(_proposalId), proposalVotes[_proposalId].yesVotes, proposalVotes[_proposalId].abstainVotes) && // yes + abstain votes meets the quorum\n            meetsBasis(proposalVotes[_proposalId].yesVotes, proposalVotes[_proposalId].noVotes) // yes votes meets the basis\n        );\n    }\n\n    /**\n     * Returns a snapshot of total voting supply for a given Proposal.  Because token supplies can change,\n     * it is necessary to calculate quorum from the supply available at the time of the Proposal's creation,\n     * not when it is being voted on passes / fails.\n     *\n     * @param _proposalId id of the Proposal\n     * @return uint256 voting supply snapshot for the given _proposalId\n     */\n    function getProposalVotingSupply(uint32 _proposalId) public view virtual returns (uint256) {\n        return governanceToken.getPastTotalSupply(proposalVotes[_proposalId].votingStartBlock);\n    }\n\n    /**\n     * Calculates the voting weight an address has for a specific Proposal.\n     *\n     * @param _voter address of the voter\n     * @param _proposalId id of the Proposal\n     * @return uint256 the address' voting weight\n     */\n    function getVotingWeight(address _voter, uint32 _proposalId) public view returns (uint256) {\n        return\n            governanceToken.getPastVotes(\n                _voter,\n                proposalVotes[_proposalId].votingStartBlock\n            );\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isProposer(address _address) public view override returns (bool) {\n        return governanceToken.getPastVotes(\n            _address,\n            block.number - 1\n        ) >= requiredProposerWeight;\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function votingEndBlock(uint32 _proposalId) public view override returns (uint32) {\n      return proposalVotes[_proposalId].votingEndBlock;\n    }\n\n    /** Internal implementation of `updateVotingPeriod`. */\n    function _updateVotingPeriod(uint32 _votingPeriod) internal {\n        votingPeriod = _votingPeriod;\n        emit VotingPeriodUpdated(_votingPeriod);\n    }\n\n    /** Internal implementation of `updateRequiredProposerWeight`. */\n    function _updateRequiredProposerWeight(uint256 _requiredProposerWeight) internal {\n        requiredProposerWeight = _requiredProposerWeight;\n        emit RequiredProposerWeightUpdated(_requiredProposerWeight);\n    }\n\n    /**\n     * Internal function for casting a vote on a Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @param _voter address casting the vote\n     * @param _voteType vote support, as defined in VoteType\n     * @param _weight amount of voting weight cast, typically the\n     *          total number of tokens delegated\n     */\n    function _vote(uint32 _proposalId, address _voter, uint8 _voteType, uint256 _weight) internal {\n        if (proposalVotes[_proposalId].votingEndBlock == 0)\n            revert InvalidProposal();\n        if (block.number > proposalVotes[_proposalId].votingEndBlock)\n            revert VotingEnded();\n        if (proposalVotes[_proposalId].hasVoted[_voter]) revert AlreadyVoted();\n\n        proposalVotes[_proposalId].hasVoted[_voter] = true;\n\n        if (_voteType == uint8(VoteType.NO)) {\n            proposalVotes[_proposalId].noVotes += _weight;\n        } else if (_voteType == uint8(VoteType.YES)) {\n            proposalVotes[_proposalId].yesVotes += _weight;\n        } else if (_voteType == uint8(VoteType.ABSTAIN)) {\n            proposalVotes[_proposalId].abstainVotes += _weight;\n        } else {\n            revert InvalidVote();\n        }\n\n        emit Voted(_voter, _proposalId, _voteType, _weight);\n    }\n\n    /** @inheritdoc BaseQuorumPercent*/\n    function quorumVotes(uint32 _proposalId) public view override returns (uint256) {\n        return quorumNumerator * getProposalVotingSupply(_proposalId) / QUORUM_DENOMINATOR;\n    }\n}\n"
    },
    "contracts/azorius/LinearERC20VotingOG.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { IVotes } from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport { BaseStrategy, IBaseStrategy } from \"./BaseStrategy.sol\";\nimport { BaseQuorumPercent } from \"./BaseQuorumPercent.sol\";\nimport { BaseVotingBasisPercent } from \"./BaseVotingBasisPercent.sol\";\n\n /**\n  * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that \n  * enables linear (i.e. 1 to 1) token voting. Each token delegated to a given address \n  * in an `ERC20Votes` token equals 1 vote for a Proposal.\n  */\ncontract LinearERC20VotingOG is BaseStrategy, BaseQuorumPercent, BaseVotingBasisPercent {\n\n    /**\n     * The voting options for a Proposal.\n     */\n    enum VoteType {\n        NO,     // disapproves of executing the Proposal\n        YES,    // approves of executing the Proposal\n        ABSTAIN // neither YES nor NO, i.e. voting \"present\"\n    }\n\n    /**\n     * Defines the current state of votes on a particular Proposal.\n     */\n    struct ProposalVotes {\n        uint32 votingStartBlock; // block that voting starts at\n        uint32 votingEndBlock; // block that voting ends\n        uint256 noVotes; // current number of NO votes for the Proposal\n        uint256 yesVotes; // current number of YES votes for the Proposal\n        uint256 abstainVotes; // current number of ABSTAIN votes for the Proposal\n        mapping(address => bool) hasVoted; // whether a given address has voted yet or not\n    }\n\n    IVotes public governanceToken;\n\n    /** Number of blocks a new Proposal can be voted on. */\n    uint32 public votingPeriod;\n\n    /** Voting weight required to be able to submit Proposals. */\n    uint256 public requiredProposerWeight;\n\n    /** `proposalId` to `ProposalVotes`, the voting state of a Proposal. */\n    mapping(uint256 => ProposalVotes) internal proposalVotes;\n\n    event VotingPeriodUpdated(uint32 votingPeriod);\n    event RequiredProposerWeightUpdated(uint256 requiredProposerWeight);\n    event ProposalInitialized(uint32 proposalId, uint32 votingEndBlock);\n    event Voted(address voter, uint32 proposalId, uint8 voteType, uint256 weight);\n\n    error InvalidProposal();\n    error VotingEnded();\n    error AlreadyVoted();\n    error InvalidVote();\n    error InvalidTokenAddress();\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `ERC20Votes _governanceToken`, `address _azoriusModule`, `uint256 _votingPeriod`,\n     * `uint256 _quorumNumerator`, `uint256 _basisNumerator`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (\n            address _owner,\n            IVotes _governanceToken,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _requiredProposerWeight,\n            uint256 _quorumNumerator,\n            uint256 _basisNumerator\n        ) = abi.decode(\n                initializeParams,\n                (address, IVotes, address, uint32, uint256, uint256, uint256)\n            );\n        if (address(_governanceToken) == address(0))\n            revert InvalidTokenAddress();\n\n        governanceToken = _governanceToken;\n        __Ownable_init();\n        transferOwnership(_owner);\n        _setAzorius(_azoriusModule);\n        _updateQuorumNumerator(_quorumNumerator);\n        _updateBasisNumerator(_basisNumerator);\n        _updateVotingPeriod(_votingPeriod);\n        _updateRequiredProposerWeight(_requiredProposerWeight);\n\n        emit StrategySetUp(_azoriusModule, _owner);\n    }\n\n    /**\n     * Updates the voting time period for new Proposals.\n     *\n     * @param _votingPeriod voting time period (in blocks)\n     */\n    function updateVotingPeriod(uint32 _votingPeriod) external onlyOwner {\n        _updateVotingPeriod(_votingPeriod);\n    }\n\n    /**\n     * Updates the voting weight required to submit new Proposals.\n     *\n     * @param _requiredProposerWeight required token voting weight\n     */\n    function updateRequiredProposerWeight(uint256 _requiredProposerWeight) external onlyOwner {\n        _updateRequiredProposerWeight(_requiredProposerWeight);\n    }\n\n    /**\n     * Casts votes for a Proposal, equal to the caller's token delegation.\n     *\n     * @param _proposalId id of the Proposal to vote on\n     * @param _voteType Proposal support as defined in VoteType (NO, YES, ABSTAIN)\n     */\n    function vote(uint32 _proposalId, uint8 _voteType) external {\n        _vote(\n            _proposalId,\n            msg.sender,\n            _voteType,\n            getVotingWeight(msg.sender, _proposalId)\n        );\n    }\n\n    /**\n     * Returns the current state of the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @return noVotes current count of \"NO\" votes\n     * @return yesVotes current count of \"YES\" votes\n     * @return abstainVotes current count of \"ABSTAIN\" votes\n     * @return startBlock block number voting starts\n     * @return endBlock block number voting ends\n     */\n    function getProposalVotes(uint32 _proposalId) external view\n        returns (\n            uint256 noVotes,\n            uint256 yesVotes,\n            uint256 abstainVotes,\n            uint32 startBlock,\n            uint32 endBlock,\n            uint256 votingSupply\n        )\n    {\n        noVotes = proposalVotes[_proposalId].noVotes;\n        yesVotes = proposalVotes[_proposalId].yesVotes;\n        abstainVotes = proposalVotes[_proposalId].abstainVotes;\n        startBlock = proposalVotes[_proposalId].votingStartBlock;\n        endBlock = proposalVotes[_proposalId].votingEndBlock;\n        votingSupply = getProposalVotingSupply(_proposalId);\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function initializeProposal(bytes memory _data) public virtual override onlyAzorius {\n        uint32 proposalId = abi.decode(_data, (uint32));\n        uint32 _votingEndBlock = uint32(block.number) + votingPeriod;\n\n        proposalVotes[proposalId].votingEndBlock = _votingEndBlock;\n        proposalVotes[proposalId].votingStartBlock = uint32(block.number);\n\n        emit ProposalInitialized(proposalId, _votingEndBlock);\n    }\n    \n    /**\n     * Returns whether an address has voted on the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal to check\n     * @param _address address to check\n     * @return bool true if the address has voted on the Proposal, otherwise false\n     */\n    function hasVoted(uint32 _proposalId, address _address) public view returns (bool) {\n        return proposalVotes[_proposalId].hasVoted[_address];\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isPassed(uint32 _proposalId) public view override returns (bool) {\n        return (\n            block.number > proposalVotes[_proposalId].votingEndBlock && // voting period has ended\n            meetsQuorum(getProposalVotingSupply(_proposalId), proposalVotes[_proposalId].yesVotes, proposalVotes[_proposalId].abstainVotes) && // yes + abstain votes meets the quorum\n            meetsBasis(proposalVotes[_proposalId].yesVotes, proposalVotes[_proposalId].noVotes) // yes votes meets the basis\n        );\n    }\n\n    /**\n     * Returns a snapshot of total voting supply for a given Proposal.  Because token supplies can change,\n     * it is necessary to calculate quorum from the supply available at the time of the Proposal's creation,\n     * not when it is being voted on passes / fails.\n     *\n     * @param _proposalId id of the Proposal\n     * @return uint256 voting supply snapshot for the given _proposalId\n     */\n    function getProposalVotingSupply(uint32 _proposalId) public view virtual returns (uint256) {\n        return governanceToken.getPastTotalSupply(proposalVotes[_proposalId].votingStartBlock);\n    }\n\n    /**\n     * Calculates the voting weight an address has for a specific Proposal.\n     *\n     * @param _voter address of the voter\n     * @param _proposalId id of the Proposal\n     * @return uint256 the address' voting weight\n     */\n    function getVotingWeight(address _voter, uint32 _proposalId) public view returns (uint256) {\n        return\n            governanceToken.getPastVotes(\n                _voter,\n                proposalVotes[_proposalId].votingStartBlock\n            );\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isProposer(address _address) public view override returns (bool) {\n        return governanceToken.getPastVotes(\n            _address,\n            block.number - 1\n        ) >= requiredProposerWeight;\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function votingEndBlock(uint32 _proposalId) public view override returns (uint32) {\n      return proposalVotes[_proposalId].votingEndBlock;\n    }\n\n    /** Internal implementation of `updateVotingPeriod`. */\n    function _updateVotingPeriod(uint32 _votingPeriod) internal {\n        votingPeriod = _votingPeriod;\n        emit VotingPeriodUpdated(_votingPeriod);\n    }\n\n    /** Internal implementation of `updateRequiredProposerWeight`. */\n    function _updateRequiredProposerWeight(uint256 _requiredProposerWeight) internal {\n        requiredProposerWeight = _requiredProposerWeight;\n        emit RequiredProposerWeightUpdated(_requiredProposerWeight);\n    }\n\n    /**\n     * Internal function for casting a vote on a Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @param _voter address casting the vote\n     * @param _voteType vote support, as defined in VoteType\n     * @param _weight amount of voting weight cast, typically the\n     *          total number of tokens delegated\n     */\n    function _vote(uint32 _proposalId, address _voter, uint8 _voteType, uint256 _weight) internal {\n        if (proposalVotes[_proposalId].votingEndBlock == 0)\n            revert InvalidProposal();\n        if (block.number > proposalVotes[_proposalId].votingEndBlock)\n            revert VotingEnded();\n        if (proposalVotes[_proposalId].hasVoted[_voter]) revert AlreadyVoted();\n\n        proposalVotes[_proposalId].hasVoted[_voter] = true;\n\n        if (_voteType == uint8(VoteType.NO)) {\n            proposalVotes[_proposalId].noVotes += _weight;\n        } else if (_voteType == uint8(VoteType.YES)) {\n            proposalVotes[_proposalId].yesVotes += _weight;\n        } else if (_voteType == uint8(VoteType.ABSTAIN)) {\n            proposalVotes[_proposalId].abstainVotes += _weight;\n        } else {\n            revert InvalidVote();\n        }\n\n        emit Voted(_voter, _proposalId, _voteType, _weight);\n    }\n\n    /** @inheritdoc BaseQuorumPercent*/\n    function quorumVotes(uint32 _proposalId) public view override returns (uint256) {\n        return quorumNumerator * getProposalVotingSupply(_proposalId) / QUORUM_DENOMINATOR;\n    }\n}\n"
    },
    "contracts/azorius/LinearERC20WrappedVoting.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { LinearERC20Voting } from \"./LinearERC20Voting.sol\";\nimport { VotesERC20Wrapper } from \"../VotesERC20Wrapper.sol\";\n\n /**\n  * An extension of [LinearERC20Voting](./azorius/LinearERC20Voting.md) that properly supports\n  * [VotesERC20Wrapper](./VotesERC20Wrapper.md) token governance.\n  *\n  * This snapshots and uses the total supply of the underlying token for calculating quorum,\n  * rather than the total supply of *wrapped* tokens, as would be the case without it.\n  */\ncontract LinearERC20WrappedVoting is LinearERC20Voting {\n\n    /** `proposalId` to \"past total supply\" of tokens. */\n    mapping(uint256 => uint256) internal votingSupply;\n\n    /** @inheritdoc LinearERC20Voting*/\n    function initializeProposal(bytes memory _data) public virtual override onlyAzorius {\n        uint32 proposalId = abi.decode(_data, (uint32));\n        uint32 _votingEndBlock = uint32(block.number) + votingPeriod;\n\n        proposalVotes[proposalId].votingEndBlock = _votingEndBlock;\n        proposalVotes[proposalId].votingStartBlock = uint32(block.number);\n        votingSupply[proposalId] = VotesERC20Wrapper(address(governanceToken)).underlying().totalSupply();\n\n        emit ProposalInitialized(proposalId, _votingEndBlock);\n    }\n\n    /** @inheritdoc LinearERC20Voting*/\n    function getProposalVotingSupply(uint32 _proposalId) public view override returns (uint256) {\n        return votingSupply[_proposalId];\n    }\n}\n"
    },
    "contracts/azorius/LinearERC721Voting.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { IERC721VotingStrategy } from \"./interfaces/IERC721VotingStrategy.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { BaseVotingBasisPercent } from \"./BaseVotingBasisPercent.sol\";\nimport { IAzorius } from \"./interfaces/IAzorius.sol\";\nimport { BaseStrategy } from \"./BaseStrategy.sol\";\n\n/**\n * An Azorius strategy that allows multiple ERC721 tokens to be registered as governance tokens, \n * each with their own voting weight.\n *\n * This is slightly different from ERC-20 voting, since there is no way to snapshot ERC721 holdings.\n * Each ERC721 id can vote once, reguardless of what address held it when a proposal was created.\n *\n * Also, this uses \"quorumThreshold\" rather than LinearERC20Voting's quorumPercent, because the \n * total supply of NFTs is not knowable within the IERC721 interface.  This is similar to a multisig \n * \"total signers\" required, rather than a percentage of the tokens.\n */\ncontract LinearERC721Voting is BaseStrategy, BaseVotingBasisPercent, IERC721VotingStrategy {\n\n    /**\n     * The voting options for a Proposal.\n     */\n    enum VoteType {\n        NO,     // disapproves of executing the Proposal\n        YES,    // approves of executing the Proposal\n        ABSTAIN // neither YES nor NO, i.e. voting \"present\"\n    }\n\n    /**\n     * Defines the current state of votes on a particular Proposal.\n     */\n    struct ProposalVotes {\n        uint32 votingStartBlock; // block that voting starts at\n        uint32 votingEndBlock; // block that voting ends\n        uint256 noVotes; // current number of NO votes for the Proposal\n        uint256 yesVotes; // current number of YES votes for the Proposal\n        uint256 abstainVotes; // current number of ABSTAIN votes for the Proposal\n        /**\n         * ERC-721 contract address to individual NFT id to bool \n         * of whether it has voted on this proposal.\n         */\n        mapping(address => mapping(uint256 => bool)) hasVoted;\n    }\n\n    /** `proposalId` to `ProposalVotes`, the voting state of a Proposal. */\n    mapping(uint256 => ProposalVotes) public proposalVotes;\n\n    /** The list of ERC-721 tokens that can vote. */\n    address[] public tokenAddresses;\n    \n    /** ERC-721 address to its voting weight per NFT id.  */\n    mapping(address => uint256) public tokenWeights;\n    \n    /** Number of blocks a new Proposal can be voted on. */\n    uint32 public votingPeriod;\n\n    /** \n     * The total number of votes required to achieve quorum.\n     * \"Quorum threshold\" is used instead of a quorum percent because IERC721 has no \n     * totalSupply function, so the contract cannot determine this.\n     */\n    uint256 public quorumThreshold;\n\n    /** \n     * The minimum number of voting power required to create a new proposal.\n     */\n    uint256 public proposerThreshold; \n\n    event VotingPeriodUpdated(uint32 votingPeriod);\n    event QuorumThresholdUpdated(uint256 quorumThreshold);\n    event ProposerThresholdUpdated(uint256 proposerThreshold);\n    event ProposalInitialized(uint32 proposalId, uint32 votingEndBlock);\n    event Voted(address voter, uint32 proposalId, uint8 voteType, address[] tokenAddresses, uint256[] tokenIds);\n    event GovernanceTokenAdded(address token, uint256 weight);\n    event GovernanceTokenRemoved(address token);\n\n    error InvalidParams();\n    error InvalidProposal();\n    error VotingEnded();\n    error InvalidVote();\n    error InvalidTokenAddress();\n    error NoVotingWeight();\n    error TokenAlreadySet();\n    error TokenNotSet();\n    error IdAlreadyVoted(uint256 tokenId);\n    error IdNotOwned(uint256 tokenId);\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address[] memory _tokens`, `uint256[] memory _weights`, `address _azoriusModule`, \n     * `uint32 _votingPeriod`, `uint256 _quorumThreshold`, `uint256 _proposerThreshold`, \n     * `uint256 _basisNumerator`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (\n            address _owner,\n            address[] memory _tokens,\n            uint256[] memory _weights,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _quorumThreshold,\n            uint256 _proposerThreshold,\n            uint256 _basisNumerator\n        ) = abi.decode(\n            initializeParams,\n            (address, address[], uint256[], address, uint32, uint256, uint256, uint256)\n        );\n\n        if (_tokens.length != _weights.length) {\n            revert InvalidParams();\n        }\n\n        for (uint i = 0; i < _tokens.length;) {\n            _addGovernanceToken(_tokens[i], _weights[i]);\n            unchecked { ++i; }\n        }\n\n        __Ownable_init();\n        transferOwnership(_owner);\n        _setAzorius(_azoriusModule);\n        _updateQuorumThreshold(_quorumThreshold);\n        _updateProposerThreshold(_proposerThreshold);\n        _updateBasisNumerator(_basisNumerator);\n        _updateVotingPeriod(_votingPeriod);\n\n        emit StrategySetUp(_azoriusModule, _owner);\n    }\n\n    /**\n     * Adds a new ERC-721 token as a governance token, along with its associated weight.\n     *\n     * @param _tokenAddress the address of the ERC-721 token\n     * @param _weight the number of votes each NFT id is worth\n     */\n    function addGovernanceToken(address _tokenAddress, uint256 _weight) external onlyOwner {\n        _addGovernanceToken(_tokenAddress, _weight);\n    }\n\n    /**\n     * Updates the voting time period for new Proposals.\n     *\n     * @param _votingPeriod voting time period (in blocks)\n     */\n    function updateVotingPeriod(uint32 _votingPeriod) external onlyOwner {\n        _updateVotingPeriod(_votingPeriod);\n    }\n\n    /** \n     * Updates the quorum required for future Proposals.\n     *\n     * @param _quorumThreshold total voting weight required to achieve quorum\n     */\n    function updateQuorumThreshold(uint256 _quorumThreshold) external onlyOwner {\n        _updateQuorumThreshold(_quorumThreshold);\n    }\n\n    /**\n     * Updates the voting weight required to submit new Proposals.\n     *\n     * @param _proposerThreshold required voting weight\n     */\n    function updateProposerThreshold(uint256 _proposerThreshold) external onlyOwner {\n        _updateProposerThreshold(_proposerThreshold);\n    }\n    /**\n     * Returns whole list of governance tokens addresses\n     */\n    function getAllTokenAddresses() external view returns (address[] memory) {\n        return tokenAddresses;\n    }\n\n    /**\n     * Returns the current state of the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @return noVotes current count of \"NO\" votes\n     * @return yesVotes current count of \"YES\" votes\n     * @return abstainVotes current count of \"ABSTAIN\" votes\n     * @return startBlock block number voting starts\n     * @return endBlock block number voting ends\n     */\n    function getProposalVotes(uint32 _proposalId) external view\n        returns (\n            uint256 noVotes,\n            uint256 yesVotes,\n            uint256 abstainVotes,\n            uint32 startBlock,\n            uint32 endBlock\n        )\n    {\n        noVotes = proposalVotes[_proposalId].noVotes;\n        yesVotes = proposalVotes[_proposalId].yesVotes;\n        abstainVotes = proposalVotes[_proposalId].abstainVotes;\n        startBlock = proposalVotes[_proposalId].votingStartBlock;\n        endBlock = proposalVotes[_proposalId].votingEndBlock;\n    }\n\n    /**\n     * Submits a vote on an existing Proposal.\n     *\n     * @param _proposalId id of the Proposal to vote on\n     * @param _voteType Proposal support as defined in VoteType (NO, YES, ABSTAIN)\n     * @param _tokenAddresses list of ERC-721 addresses that correspond to ids in _tokenIds\n     * @param _tokenIds list of unique token ids that correspond to their ERC-721 address in _tokenAddresses\n     */\n    function vote(\n        uint32 _proposalId, \n        uint8 _voteType, \n        address[] memory _tokenAddresses,\n        uint256[] memory _tokenIds \n    ) external {\n        if (_tokenAddresses.length != _tokenIds.length) revert InvalidParams();\n        _vote(_proposalId, msg.sender, _voteType, _tokenAddresses, _tokenIds);\n    }\n\n    /** @inheritdoc IERC721VotingStrategy*/\n    function getTokenWeight(address _tokenAddress) external view override returns (uint256) {\n        return tokenWeights[_tokenAddress];\n    }\n\n    /**\n     * Returns whether an NFT id has already voted.\n     *\n     * @param _proposalId the id of the Proposal\n     * @param _tokenAddress the ERC-721 contract address\n     * @param _tokenId the unique id of the NFT\n     */\n    function hasVoted(uint32 _proposalId, address _tokenAddress, uint256 _tokenId) external view returns (bool) {\n        return proposalVotes[_proposalId].hasVoted[_tokenAddress][_tokenId];\n    }\n\n    /** \n     * Removes the given ERC-721 token address from the list of governance tokens.\n     *\n     * @param _tokenAddress the ERC-721 token to remove\n     */\n    function removeGovernanceToken(address _tokenAddress) external onlyOwner {\n        if (tokenWeights[_tokenAddress] == 0) revert TokenNotSet();\n\n        tokenWeights[_tokenAddress] = 0;\n\n        uint256 length = tokenAddresses.length;\n        for (uint256 i = 0; i < length;) {\n            if (_tokenAddress == tokenAddresses[i]) {\n                uint256 last = length - 1;\n                tokenAddresses[i] = tokenAddresses[last]; // move the last token into the position to remove\n                delete tokenAddresses[last];              // delete the last token\n                break;\n            }\n            unchecked { ++i; }\n        }\n        \n        emit GovernanceTokenRemoved(_tokenAddress);\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function initializeProposal(bytes memory _data) public virtual override onlyAzorius {\n        uint32 proposalId = abi.decode(_data, (uint32));\n        uint32 _votingEndBlock = uint32(block.number) + votingPeriod;\n\n        proposalVotes[proposalId].votingEndBlock = _votingEndBlock;\n        proposalVotes[proposalId].votingStartBlock = uint32(block.number);\n\n        emit ProposalInitialized(proposalId, _votingEndBlock);\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isPassed(uint32 _proposalId) public view override returns (bool) {\n        return (\n            block.number > proposalVotes[_proposalId].votingEndBlock && // voting period has ended\n            quorumThreshold <= proposalVotes[_proposalId].yesVotes + proposalVotes[_proposalId].abstainVotes && // yes + abstain votes meets the quorum\n            meetsBasis(proposalVotes[_proposalId].yesVotes, proposalVotes[_proposalId].noVotes) // yes votes meets the basis\n        );\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isProposer(address _address) public view override returns (bool) {\n        uint256 totalWeight = 0;\n        for (uint i = 0; i < tokenAddresses.length;) {\n            address tokenAddress = tokenAddresses[i];\n            totalWeight += IERC721(tokenAddress).balanceOf(_address) * tokenWeights[tokenAddress];\n            unchecked { ++i; }\n        }\n        return totalWeight >= proposerThreshold;\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function votingEndBlock(uint32 _proposalId) public view override returns (uint32) {\n      return proposalVotes[_proposalId].votingEndBlock;\n    }\n\n    /** Internal implementation of `addGovernanceToken` */\n    function _addGovernanceToken(address _tokenAddress, uint256 _weight) internal {\n        if (!IERC721(_tokenAddress).supportsInterface(0x80ac58cd))\n            revert InvalidTokenAddress();\n        \n        if (_weight == 0)\n            revert NoVotingWeight();\n\n        if (tokenWeights[_tokenAddress] > 0)\n            revert TokenAlreadySet();\n\n        tokenAddresses.push(_tokenAddress);\n        tokenWeights[_tokenAddress] = _weight;\n\n        emit GovernanceTokenAdded(_tokenAddress, _weight);\n    }\n\n    /** Internal implementation of `updateVotingPeriod`. */\n    function _updateVotingPeriod(uint32 _votingPeriod) internal {\n        votingPeriod = _votingPeriod;\n        emit VotingPeriodUpdated(_votingPeriod);\n    }\n\n    /** Internal implementation of `updateQuorumThreshold`. */\n    function _updateQuorumThreshold(uint256 _quorumThreshold) internal {\n        quorumThreshold = _quorumThreshold;\n        emit QuorumThresholdUpdated(quorumThreshold);\n    }\n\n    /** Internal implementation of `updateProposerThreshold`. */\n    function _updateProposerThreshold(uint256 _proposerThreshold) internal {\n        proposerThreshold = _proposerThreshold;\n        emit ProposerThresholdUpdated(_proposerThreshold);\n    }\n\n    /**\n     * Internal function for casting a vote on a Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @param _voter address casting the vote\n     * @param _voteType vote support, as defined in VoteType\n     * @param _tokenAddresses list of ERC-721 addresses that correspond to ids in _tokenIds\n     * @param _tokenIds list of unique token ids that correspond to their ERC-721 address in _tokenAddresses\n     */\n    function _vote(\n        uint32 _proposalId,\n        address _voter,\n        uint8 _voteType,\n        address[] memory _tokenAddresses,\n        uint256[] memory _tokenIds\n    ) internal {\n\n        uint256 weight;\n\n        // verifies the voter holds the NFTs and returns the total weight associated with their tokens\n        // the frontend will need to determine whether an address can vote on a proposal, as it is possible\n        // to vote twice if you get more weight later on\n        for (uint256 i = 0; i < _tokenAddresses.length;) {\n\n            address tokenAddress = _tokenAddresses[i];\n            uint256 tokenId = _tokenIds[i];\n\n            if (_voter != IERC721(tokenAddress).ownerOf(tokenId)) {\n                revert IdNotOwned(tokenId);\n            }\n\n            if (proposalVotes[_proposalId].hasVoted[tokenAddress][tokenId] == true) {\n                revert IdAlreadyVoted(tokenId);\n            }\n            \n            weight += tokenWeights[tokenAddress];\n            proposalVotes[_proposalId].hasVoted[tokenAddress][tokenId] = true;\n            unchecked { ++i; }\n        }\n\n        if (weight == 0) revert NoVotingWeight();\n\n        ProposalVotes storage proposal = proposalVotes[_proposalId];\n\n        if (proposal.votingEndBlock == 0)\n            revert InvalidProposal();\n\n        if (block.number > proposal.votingEndBlock)\n            revert VotingEnded();\n\n        if (_voteType == uint8(VoteType.NO)) {\n            proposal.noVotes += weight;\n        } else if (_voteType == uint8(VoteType.YES)) {\n            proposal.yesVotes += weight;\n        } else if (_voteType == uint8(VoteType.ABSTAIN)) {\n            proposal.abstainVotes += weight;\n        } else {\n            revert InvalidVote();\n        }\n\n        emit Voted(_voter, _proposalId, _voteType, _tokenAddresses, _tokenIds);\n    }\n}\n"
    },
    "contracts/azorius/strategies/ERC4337VoterSupportV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {ILightAccount} from \"../../interfaces/ILightAccount.sol\";\nimport {SmartAccountValidationV1} from \"../../account-abstraction/SmartAccountValidationV1.sol\";\n\n/**\n * Functionality to support ERC4337 (Account Abstraction) by properly identifying the voter\n * when a contract account is used to interact with the voting system.\n */\nabstract contract ERC4337VoterSupportV1 is SmartAccountValidationV1 {\n    /**\n     * @dev Tracks whether a proposal's voting period has been marked as ended.\n     * This flag is set to true when the first vote attempt occurs after the voting end block,\n     * triggering a VotingPeriodEnded event. Used to allow an at-most-once vote to not revert\n     * after the voting period has ended, and to give bundlers the ability to determine\n     * if a proposal voting period has ended without using the banned NUMBER opcode.\n     */\n    mapping(uint32 => bool) internal _votingPeriodEnded;\n\n    event VotingPeriodEnded(\n        uint32 indexed proposalId,\n        uint256 votingEndBlock,\n        uint256 currentBlock\n    );\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __ERC4337VoterSupportV1_init(\n        address _lightAccountFactory\n    ) internal {\n        __SmartAccountValidationV1_init(_lightAccountFactory);\n    }\n\n    /**\n     * Returns the address of the voter which owns the voting weight\n     * @param _msgSender address of the sender. It can be the wallet address, or the smart account address with EOA as owner\n     * @return address of the voter\n     */\n    function _voter(\n        address _msgSender\n    ) internal view virtual returns (address) {\n        (bool isValid, address lightAccountOwner) = validateSmartAccount(\n            _msgSender\n        );\n        if (!isValid) {\n            return _msgSender;\n        }\n\n        return lightAccountOwner;\n    }\n\n    /**\n     * @dev Tracks whether a proposal's voting period has been officially marked as ended.\n     * This flag is set to true when the first vote attempt occurs after the voting end block,\n     * triggering a VotingPeriodEnded event. Used to ensure the event is emitted exactly once\n     * per proposal, and only if a vote has been attempted after the voting end block.\n     * @param _proposalId The ID of the proposal to check.\n     * @return True if the voting period has ended and a vote has been attempted after the voting end block, false otherwise.\n     */\n    function votingPeriodEnded(\n        uint32 _proposalId\n    ) external view virtual returns (bool) {\n        return _votingPeriodEnded[_proposalId];\n    }\n}\n"
    },
    "contracts/azorius/strategies/HatsProposalCreationWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IHats} from \"../../interfaces/hats/IHats.sol\";\n\nabstract contract HatsProposalCreationWhitelist is OwnableUpgradeable {\n    event HatWhitelisted(uint256 hatId);\n    event HatRemovedFromWhitelist(uint256 hatId);\n\n    IHats public hatsContract;\n\n    /** Array to store whitelisted Hat IDs. */\n    uint256[] private whitelistedHatIds;\n\n    error InvalidHatsContract();\n    error NoHatsWhitelisted();\n    error HatAlreadyWhitelisted();\n    error HatNotWhitelisted();\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters:\n     * `address _hatsContract`, `uint256[] _initialWhitelistedHats`\n     */\n    function setUp(bytes memory initializeParams) public virtual {\n        (address _hatsContract, uint256[] memory _initialWhitelistedHats) = abi\n            .decode(initializeParams, (address, uint256[]));\n\n        if (_hatsContract == address(0)) revert InvalidHatsContract();\n        hatsContract = IHats(_hatsContract);\n\n        if (_initialWhitelistedHats.length == 0) revert NoHatsWhitelisted();\n        for (uint256 i = 0; i < _initialWhitelistedHats.length; i++) {\n            _whitelistHat(_initialWhitelistedHats[i]);\n        }\n    }\n\n    /**\n     * Adds a Hat to the whitelist for proposal creation.\n     * @param _hatId The ID of the Hat to whitelist\n     */\n    function whitelistHat(uint256 _hatId) external onlyOwner {\n        _whitelistHat(_hatId);\n    }\n\n    /**\n     * Internal function to add a Hat to the whitelist.\n     * @param _hatId The ID of the Hat to whitelist\n     */\n    function _whitelistHat(uint256 _hatId) internal {\n        for (uint256 i = 0; i < whitelistedHatIds.length; i++) {\n            if (whitelistedHatIds[i] == _hatId) revert HatAlreadyWhitelisted();\n        }\n        whitelistedHatIds.push(_hatId);\n        emit HatWhitelisted(_hatId);\n    }\n\n    /**\n     * Removes a Hat from the whitelist for proposal creation.\n     * @param _hatId The ID of the Hat to remove from the whitelist\n     */\n    function removeHatFromWhitelist(uint256 _hatId) external onlyOwner {\n        bool found = false;\n        for (uint256 i = 0; i < whitelistedHatIds.length; i++) {\n            if (whitelistedHatIds[i] == _hatId) {\n                whitelistedHatIds[i] = whitelistedHatIds[\n                    whitelistedHatIds.length - 1\n                ];\n                whitelistedHatIds.pop();\n                found = true;\n                break;\n            }\n        }\n        if (!found) revert HatNotWhitelisted();\n\n        emit HatRemovedFromWhitelist(_hatId);\n    }\n\n    /**\n     * @dev Checks if an address is authorized to create proposals.\n     * @param _address The address to check for proposal creation authorization.\n     * @return bool Returns true if the address is wearing any of the whitelisted Hats, false otherwise.\n     * @notice This function overrides the isProposer function from the parent contract.\n     * It iterates through all whitelisted Hat IDs and checks if the given address\n     * is wearing any of them using the Hats Protocol.\n     */\n    function isProposer(address _address) public view virtual returns (bool) {\n        for (uint256 i = 0; i < whitelistedHatIds.length; i++) {\n            if (hatsContract.isWearerOfHat(_address, whitelistedHatIds[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Returns the IDs of all whitelisted Hats.\n     * @return uint256[] memory An array of whitelisted Hat IDs.\n     */\n    function getWhitelistedHatIds() public view returns (uint256[] memory) {\n        return whitelistedHatIds;\n    }\n}\n"
    },
    "contracts/azorius/strategies/HatsProposalCreationWhitelistV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {IHatsProposalCreationWhitelistV1} from \"../../interfaces/IHatsProposalCreationWhitelistV1.sol\";\nimport {IHats} from \"../../interfaces/hats/IHats.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract HatsProposalCreationWhitelistV1 is\n    IHatsProposalCreationWhitelistV1,\n    OwnableUpgradeable,\n    ERC165\n{\n    IHats public hatsContract;\n\n    /** Array to store whitelisted Hat IDs. */\n    uint256[] private whitelistedHatIds;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters:\n     * `address _hatsContract`, `uint256[] _initialWhitelistedHats`\n     */\n    function setUp(bytes memory initializeParams) public virtual {\n        (address _hatsContract, uint256[] memory _initialWhitelistedHats) = abi\n            .decode(initializeParams, (address, uint256[]));\n\n        if (_hatsContract == address(0)) revert MissingHatsContract();\n        hatsContract = IHats(_hatsContract);\n\n        if (_initialWhitelistedHats.length == 0) revert NoHatsWhitelisted();\n        for (uint256 i = 0; i < _initialWhitelistedHats.length; i++) {\n            _whitelistHat(_initialWhitelistedHats[i]);\n        }\n    }\n\n    /**\n     * Adds a Hat to the whitelist for proposal creation.\n     * @param _hatId The ID of the Hat to whitelist\n     */\n    function whitelistHat(uint256 _hatId) external onlyOwner {\n        _whitelistHat(_hatId);\n    }\n\n    /**\n     * Internal function to add a Hat to the whitelist.\n     * @param _hatId The ID of the Hat to whitelist\n     */\n    function _whitelistHat(uint256 _hatId) internal {\n        for (uint256 i = 0; i < whitelistedHatIds.length; i++) {\n            if (whitelistedHatIds[i] == _hatId) revert HatAlreadyWhitelisted();\n        }\n        whitelistedHatIds.push(_hatId);\n        emit HatWhitelisted(_hatId);\n    }\n\n    /**\n     * Removes a Hat from the whitelist for proposal creation.\n     * @param _hatId The ID of the Hat to remove from the whitelist\n     */\n    function unwhitelistHat(uint256 _hatId) external onlyOwner {\n        bool found = false;\n        for (uint256 i = 0; i < whitelistedHatIds.length; i++) {\n            if (whitelistedHatIds[i] == _hatId) {\n                whitelistedHatIds[i] = whitelistedHatIds[\n                    whitelistedHatIds.length - 1\n                ];\n                whitelistedHatIds.pop();\n                found = true;\n                break;\n            }\n        }\n        if (!found) revert HatNotWhitelisted();\n\n        emit HatUnwhitelisted(_hatId);\n    }\n\n    /**\n     * @dev Checks if an address is wearing any of the whitelisted Hats.\n     * @param _address The address to check for wearing whitelisted Hats.\n     * @return bool Returns true if the address is wearing any of the whitelisted Hats, false otherwise.\n     */\n    function isWearingWhitelistedHat(\n        address _address\n    ) public view virtual returns (bool) {\n        for (uint256 i = 0; i < whitelistedHatIds.length; i++) {\n            if (hatsContract.isWearerOfHat(_address, whitelistedHatIds[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Returns the IDs of all whitelisted Hats.\n     * @return uint256[] memory An array of whitelisted Hat IDs.\n     */\n    function getWhitelistedHatIds() public view returns (uint256[] memory) {\n        return whitelistedHatIds;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IHatsProposalCreationWhitelistV1).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC20VotingExtensible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {BaseStrategy, IBaseStrategy} from \"../BaseStrategy.sol\";\nimport {BaseQuorumPercent} from \"../BaseQuorumPercent.sol\";\nimport {BaseVotingBasisPercent} from \"../BaseVotingBasisPercent.sol\";\n\n/**\n * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that\n * enables linear (i.e. 1 to 1) token voting. Each token delegated to a given address\n * in an `ERC20Votes` token equals 1 vote for a Proposal.\n *\n * This contract is an extensible version of LinearERC20Voting, with all functions\n * marked as `virtual`. This allows other contracts to inherit from it and override\n * any part of its functionality. The existence of this contract enables the creation\n * of more specialized voting strategies that build upon the basic linear ERC20 voting\n * mechanism while allowing for customization of specific aspects as needed.\n */\nabstract contract LinearERC20VotingExtensible is\n    BaseStrategy,\n    BaseQuorumPercent,\n    BaseVotingBasisPercent\n{\n    /**\n     * The voting options for a Proposal.\n     */\n    enum VoteType {\n        NO, // disapproves of executing the Proposal\n        YES, // approves of executing the Proposal\n        ABSTAIN // neither YES nor NO, i.e. voting \"present\"\n    }\n\n    /**\n     * Defines the current state of votes on a particular Proposal.\n     */\n    struct ProposalVotes {\n        uint32 votingStartBlock; // block that voting starts at\n        uint32 votingEndBlock; // block that voting ends\n        uint256 noVotes; // current number of NO votes for the Proposal\n        uint256 yesVotes; // current number of YES votes for the Proposal\n        uint256 abstainVotes; // current number of ABSTAIN votes for the Proposal\n        mapping(address => bool) hasVoted; // whether a given address has voted yet or not\n    }\n\n    IVotes public governanceToken;\n\n    /** Number of blocks a new Proposal can be voted on. */\n    uint32 public votingPeriod;\n\n    /** Voting weight required to be able to submit Proposals. */\n    uint256 public requiredProposerWeight;\n\n    /** `proposalId` to `ProposalVotes`, the voting state of a Proposal. */\n    mapping(uint256 => ProposalVotes) internal proposalVotes;\n\n    event VotingPeriodUpdated(uint32 votingPeriod);\n    event RequiredProposerWeightUpdated(uint256 requiredProposerWeight);\n    event ProposalInitialized(uint32 proposalId, uint32 votingEndBlock);\n    event Voted(\n        address voter,\n        uint32 proposalId,\n        uint8 voteType,\n        uint256 weight\n    );\n\n    error InvalidProposal();\n    error VotingEnded();\n    error AlreadyVoted();\n    error InvalidVote();\n    error InvalidTokenAddress();\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `IVotes _governanceToken`, `address _azoriusModule`, `uint32 _votingPeriod`,\n     * `uint256 _requiredProposerWeight`, `uint256 _quorumNumerator`,\n     * `uint256 _basisNumerator`\n     */\n    function setUp(\n        bytes memory initializeParams\n    ) public virtual override initializer {\n        (\n            address _owner,\n            IVotes _governanceToken,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _requiredProposerWeight,\n            uint256 _quorumNumerator,\n            uint256 _basisNumerator\n        ) = abi.decode(\n                initializeParams,\n                (address, IVotes, address, uint32, uint256, uint256, uint256)\n            );\n        if (address(_governanceToken) == address(0))\n            revert InvalidTokenAddress();\n\n        governanceToken = _governanceToken;\n        __Ownable_init();\n        transferOwnership(_owner);\n        _setAzorius(_azoriusModule);\n        _updateQuorumNumerator(_quorumNumerator);\n        _updateBasisNumerator(_basisNumerator);\n        _updateVotingPeriod(_votingPeriod);\n        _updateRequiredProposerWeight(_requiredProposerWeight);\n\n        emit StrategySetUp(_azoriusModule, _owner);\n    }\n\n    /**\n     * Updates the voting time period for new Proposals.\n     *\n     * @param _votingPeriod voting time period (in blocks)\n     */\n    function updateVotingPeriod(\n        uint32 _votingPeriod\n    ) external virtual onlyOwner {\n        _updateVotingPeriod(_votingPeriod);\n    }\n\n    /**\n     * Updates the voting weight required to submit new Proposals.\n     *\n     * @param _requiredProposerWeight required token voting weight\n     */\n    function updateRequiredProposerWeight(\n        uint256 _requiredProposerWeight\n    ) external virtual onlyOwner {\n        _updateRequiredProposerWeight(_requiredProposerWeight);\n    }\n\n    /**\n     * Casts votes for a Proposal, equal to the caller's token delegation.\n     *\n     * @param _proposalId id of the Proposal to vote on\n     * @param _voteType Proposal support as defined in VoteType (NO, YES, ABSTAIN)\n     */\n    function vote(uint32 _proposalId, uint8 _voteType) external virtual {\n        _vote(\n            _proposalId,\n            msg.sender,\n            _voteType,\n            getVotingWeight(msg.sender, _proposalId)\n        );\n    }\n\n    /**\n     * Returns the current state of the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @return noVotes current count of \"NO\" votes\n     * @return yesVotes current count of \"YES\" votes\n     * @return abstainVotes current count of \"ABSTAIN\" votes\n     * @return startBlock block number voting starts\n     * @return endBlock block number voting ends\n     */\n    function getProposalVotes(\n        uint32 _proposalId\n    )\n        external\n        view\n        virtual\n        returns (\n            uint256 noVotes,\n            uint256 yesVotes,\n            uint256 abstainVotes,\n            uint32 startBlock,\n            uint32 endBlock,\n            uint256 votingSupply\n        )\n    {\n        noVotes = proposalVotes[_proposalId].noVotes;\n        yesVotes = proposalVotes[_proposalId].yesVotes;\n        abstainVotes = proposalVotes[_proposalId].abstainVotes;\n        startBlock = proposalVotes[_proposalId].votingStartBlock;\n        endBlock = proposalVotes[_proposalId].votingEndBlock;\n        votingSupply = getProposalVotingSupply(_proposalId);\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function initializeProposal(\n        bytes memory _data\n    ) public virtual override onlyAzorius {\n        uint32 proposalId = abi.decode(_data, (uint32));\n        uint32 _votingEndBlock = uint32(block.number) + votingPeriod;\n\n        proposalVotes[proposalId].votingEndBlock = _votingEndBlock;\n        proposalVotes[proposalId].votingStartBlock = uint32(block.number);\n\n        emit ProposalInitialized(proposalId, _votingEndBlock);\n    }\n\n    /**\n     * Returns whether an address has voted on the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal to check\n     * @param _address address to check\n     * @return bool true if the address has voted on the Proposal, otherwise false\n     */\n    function hasVoted(\n        uint32 _proposalId,\n        address _address\n    ) public view virtual returns (bool) {\n        return proposalVotes[_proposalId].hasVoted[_address];\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isPassed(\n        uint32 _proposalId\n    ) public view virtual override returns (bool) {\n        return (block.number > proposalVotes[_proposalId].votingEndBlock && // voting period has ended\n            meetsQuorum(\n                getProposalVotingSupply(_proposalId),\n                proposalVotes[_proposalId].yesVotes,\n                proposalVotes[_proposalId].abstainVotes\n            ) && // yes + abstain votes meets the quorum\n            meetsBasis(\n                proposalVotes[_proposalId].yesVotes,\n                proposalVotes[_proposalId].noVotes\n            )); // yes votes meets the basis\n    }\n\n    /**\n     * Returns a snapshot of total voting supply for a given Proposal.  Because token supplies can change,\n     * it is necessary to calculate quorum from the supply available at the time of the Proposal's creation,\n     * not when it is being voted on passes / fails.\n     *\n     * @param _proposalId id of the Proposal\n     * @return uint256 voting supply snapshot for the given _proposalId\n     */\n    function getProposalVotingSupply(\n        uint32 _proposalId\n    ) public view virtual returns (uint256) {\n        return\n            governanceToken.getPastTotalSupply(\n                proposalVotes[_proposalId].votingStartBlock\n            );\n    }\n\n    /**\n     * Calculates the voting weight an address has for a specific Proposal.\n     *\n     * @param _voter address of the voter\n     * @param _proposalId id of the Proposal\n     * @return uint256 the address' voting weight\n     */\n    function getVotingWeight(\n        address _voter,\n        uint32 _proposalId\n    ) public view virtual returns (uint256) {\n        return\n            governanceToken.getPastVotes(\n                _voter,\n                proposalVotes[_proposalId].votingStartBlock\n            );\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isProposer(\n        address _address\n    ) public view virtual override returns (bool) {\n        return\n            governanceToken.getPastVotes(_address, block.number - 1) >=\n            requiredProposerWeight;\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function votingEndBlock(\n        uint32 _proposalId\n    ) public view virtual override returns (uint32) {\n        return proposalVotes[_proposalId].votingEndBlock;\n    }\n\n    /** Internal implementation of `updateVotingPeriod`. */\n    function _updateVotingPeriod(uint32 _votingPeriod) internal virtual {\n        votingPeriod = _votingPeriod;\n        emit VotingPeriodUpdated(_votingPeriod);\n    }\n\n    /** Internal implementation of `updateRequiredProposerWeight`. */\n    function _updateRequiredProposerWeight(\n        uint256 _requiredProposerWeight\n    ) internal virtual {\n        requiredProposerWeight = _requiredProposerWeight;\n        emit RequiredProposerWeightUpdated(_requiredProposerWeight);\n    }\n\n    /**\n     * Internal function for casting a vote on a Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @param _voter address casting the vote\n     * @param _voteType vote support, as defined in VoteType\n     * @param _weight amount of voting weight cast, typically the\n     *          total number of tokens delegated\n     */\n    function _vote(\n        uint32 _proposalId,\n        address _voter,\n        uint8 _voteType,\n        uint256 _weight\n    ) internal virtual {\n        if (proposalVotes[_proposalId].votingEndBlock == 0)\n            revert InvalidProposal();\n        if (block.number > proposalVotes[_proposalId].votingEndBlock)\n            revert VotingEnded();\n        if (proposalVotes[_proposalId].hasVoted[_voter]) revert AlreadyVoted();\n\n        proposalVotes[_proposalId].hasVoted[_voter] = true;\n\n        if (_voteType == uint8(VoteType.NO)) {\n            proposalVotes[_proposalId].noVotes += _weight;\n        } else if (_voteType == uint8(VoteType.YES)) {\n            proposalVotes[_proposalId].yesVotes += _weight;\n        } else if (_voteType == uint8(VoteType.ABSTAIN)) {\n            proposalVotes[_proposalId].abstainVotes += _weight;\n        } else {\n            revert InvalidVote();\n        }\n\n        emit Voted(_voter, _proposalId, _voteType, _weight);\n    }\n\n    /** @inheritdoc BaseQuorumPercent*/\n    function quorumVotes(\n        uint32 _proposalId\n    ) public view virtual override returns (uint256) {\n        return\n            (quorumNumerator * getProposalVotingSupply(_proposalId)) /\n            QUORUM_DENOMINATOR;\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC20VotingV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {Version} from \"../../Version.sol\";\nimport {ERC4337VoterSupportV1} from \"./ERC4337VoterSupportV1.sol\";\nimport {LinearERC20VotingExtensible} from \"./LinearERC20VotingExtensible.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that\n * enables linear (i.e. 1 to 1) token voting. Each token delegated to a given address\n * in an `ERC20Votes` token equals 1 vote for a Proposal.\n */\ncontract LinearERC20VotingV1 is\n    LinearERC20VotingExtensible,\n    ERC165,\n    ERC4337VoterSupportV1,\n    Version\n{\n    uint16 private constant VERSION = 1;\n\n    /**\n     * @dev Constructor that disables initializers\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address _governanceToken`, `address _azoriusModule`, `uint32 _votingPeriod`,\n     * `uint256 _quorumNumerator`, `uint256 _basisNumerator`, `address _lightAccountFactory`\n     */\n    function setUp(bytes memory initializeParams) public virtual override {\n        (\n            address _owner,\n            IVotes _governanceToken,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _requiredProposerWeight,\n            uint256 _quorumNumerator,\n            uint256 _basisNumerator,\n            address _lightAccountFactory\n        ) = abi.decode(\n                initializeParams,\n                (\n                    address,\n                    IVotes,\n                    address,\n                    uint32,\n                    uint256,\n                    uint256,\n                    uint256,\n                    address\n                )\n            );\n\n        LinearERC20VotingExtensible.setUp(\n            abi.encode(\n                _owner,\n                _governanceToken,\n                _azoriusModule,\n                _votingPeriod,\n                _requiredProposerWeight,\n                _quorumNumerator,\n                _basisNumerator\n            )\n        );\n\n        __ERC4337VoterSupportV1_init(_lightAccountFactory);\n    }\n\n    /**\n     * Casts votes for a Proposal, equal to the caller's token delegation.\n     *\n     * @param _proposalId id of the Proposal to vote on\n     * @param _voteType Proposal support as defined in VoteType (NO, YES, ABSTAIN)\n     */\n    function vote(\n        uint32 _proposalId,\n        uint8 _voteType\n    ) external virtual override {\n        address voter = _voter(msg.sender);\n        _vote(\n            _proposalId,\n            voter,\n            _voteType,\n            getVotingWeight(voter, _proposalId)\n        );\n    }\n\n    /** @inheritdoc LinearERC20VotingExtensible*/\n    function _vote(\n        uint32 _proposalId,\n        address _voter,\n        uint8 _voteType,\n        uint256 _weight\n    ) internal virtual override {\n        if (proposalVotes[_proposalId].votingEndBlock == 0)\n            revert InvalidProposal();\n        if (block.number > proposalVotes[_proposalId].votingEndBlock) {\n            if (!_votingPeriodEnded[_proposalId]) {\n                _votingPeriodEnded[_proposalId] = true;\n                emit VotingPeriodEnded(\n                    _proposalId,\n                    proposalVotes[_proposalId].votingEndBlock,\n                    block.number\n                );\n                return;\n            }\n            revert VotingEnded();\n        }\n        if (proposalVotes[_proposalId].hasVoted[_voter]) revert AlreadyVoted();\n\n        proposalVotes[_proposalId].hasVoted[_voter] = true;\n\n        if (_voteType == uint8(VoteType.NO)) {\n            proposalVotes[_proposalId].noVotes += _weight;\n        } else if (_voteType == uint8(VoteType.YES)) {\n            proposalVotes[_proposalId].yesVotes += _weight;\n        } else if (_voteType == uint8(VoteType.ABSTAIN)) {\n            proposalVotes[_proposalId].abstainVotes += _weight;\n        } else {\n            revert InvalidVote();\n        }\n\n        emit Voted(_voter, _proposalId, _voteType, _weight);\n    }\n\n    function getVersion() public view virtual override returns (uint16) {\n        return VERSION;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(Version, ERC165) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC20VotingWithHatsProposalCreation.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport {LinearERC20VotingExtensible} from \"./LinearERC20VotingExtensible.sol\";\nimport {HatsProposalCreationWhitelist} from \"./HatsProposalCreationWhitelist.sol\";\nimport {IHats} from \"../../interfaces/hats/IHats.sol\";\n\n/**\n * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that\n * enables linear (i.e. 1 to 1) ERC20 based token voting, with proposal creation\n * restricted to users wearing whitelisted Hats.\n */\ncontract LinearERC20VotingWithHatsProposalCreation is\n    HatsProposalCreationWhitelist,\n    LinearERC20VotingExtensible\n{\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address _governanceToken`, `address _azoriusModule`, `uint32 _votingPeriod`,\n     * `uint256 _quorumNumerator`, `uint256 _basisNumerator`, `address _hatsContract`,\n     * `uint256[] _initialWhitelistedHats`\n     */\n    function setUp(\n        bytes memory initializeParams\n    )\n        public\n        override(HatsProposalCreationWhitelist, LinearERC20VotingExtensible)\n    {\n        (\n            address _owner,\n            address _governanceToken,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _quorumNumerator,\n            uint256 _basisNumerator,\n            address _hatsContract,\n            uint256[] memory _initialWhitelistedHats\n        ) = abi.decode(\n                initializeParams,\n                (\n                    address,\n                    address,\n                    address,\n                    uint32,\n                    uint256,\n                    uint256,\n                    address,\n                    uint256[]\n                )\n            );\n\n        LinearERC20VotingExtensible.setUp(\n            abi.encode(\n                _owner,\n                _governanceToken,\n                _azoriusModule,\n                _votingPeriod,\n                0, // requiredProposerWeight is zero because we only care about the hat check\n                _quorumNumerator,\n                _basisNumerator\n            )\n        );\n\n        HatsProposalCreationWhitelist.setUp(\n            abi.encode(_hatsContract, _initialWhitelistedHats)\n        );\n    }\n\n    /** @inheritdoc HatsProposalCreationWhitelist*/\n    function isProposer(\n        address _address\n    )\n        public\n        view\n        override(HatsProposalCreationWhitelist, LinearERC20VotingExtensible)\n        returns (bool)\n    {\n        return HatsProposalCreationWhitelist.isProposer(_address);\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC20VotingWithHatsProposalCreationV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {LinearERC20VotingV1} from \"./LinearERC20VotingV1.sol\";\nimport {LinearERC20VotingExtensible} from \"./LinearERC20VotingExtensible.sol\";\nimport {HatsProposalCreationWhitelistV1} from \"./HatsProposalCreationWhitelistV1.sol\";\n\n/**\n * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that\n * enables linear (i.e. 1 to 1) ERC20 based token voting, with proposal creation\n * restricted to users wearing whitelisted Hats.\n */\ncontract LinearERC20VotingWithHatsProposalCreationV1 is\n    LinearERC20VotingV1,\n    HatsProposalCreationWhitelistV1\n{\n    uint16 private constant VERSION = 1;\n\n    /**\n     * @dev Constructor that disables initializers\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address _governanceToken`, `address _azoriusModule`, `uint32 _votingPeriod`,\n     * `uint256 _quorumNumerator`, `uint256 _basisNumerator`, `address _hatsContract`,\n     * `uint256[] _initialWhitelistedHats`, `address _lightAccountFactory`\n     */\n    function setUp(\n        bytes memory initializeParams\n    ) public override(LinearERC20VotingV1, HatsProposalCreationWhitelistV1) {\n        (\n            address _owner,\n            address _governanceToken,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _quorumNumerator,\n            uint256 _basisNumerator,\n            address _hatsContract,\n            uint256[] memory _initialWhitelistedHats,\n            address _lightAccountFactory\n        ) = abi.decode(\n                initializeParams,\n                (\n                    address,\n                    address,\n                    address,\n                    uint32,\n                    uint256,\n                    uint256,\n                    address,\n                    uint256[],\n                    address\n                )\n            );\n\n        LinearERC20VotingV1.setUp(\n            abi.encode(\n                _owner,\n                _governanceToken,\n                _azoriusModule,\n                _votingPeriod,\n                0, // requiredProposerWeight is zero because we only care about the hat check\n                _quorumNumerator,\n                _basisNumerator,\n                _lightAccountFactory\n            )\n        );\n\n        HatsProposalCreationWhitelistV1.setUp(\n            abi.encode(_hatsContract, _initialWhitelistedHats)\n        );\n    }\n\n    function isProposer(\n        address _address\n    ) public view virtual override returns (bool) {\n        return isWearingWhitelistedHat(_address);\n    }\n\n    function getVersion() public view virtual override returns (uint16) {\n        return VERSION;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(LinearERC20VotingV1, HatsProposalCreationWhitelistV1)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC721VotingExtensible.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721VotingStrategy} from \"../interfaces/IERC721VotingStrategy.sol\";\nimport {BaseVotingBasisPercent} from \"../BaseVotingBasisPercent.sol\";\nimport {IAzorius} from \"../interfaces/IAzorius.sol\";\nimport {BaseStrategy} from \"../BaseStrategy.sol\";\n\n/**\n * An Azorius strategy that allows multiple ERC721 tokens to be registered as governance tokens,\n * each with their own voting weight.\n *\n * This is slightly different from ERC-20 voting, since there is no way to snapshot ERC721 holdings.\n * Each ERC721 id can vote once, reguardless of what address held it when a proposal was created.\n *\n * Also, this uses \"quorumThreshold\" rather than LinearERC20Voting's quorumPercent, because the\n * total supply of NFTs is not knowable within the IERC721 interface.  This is similar to a multisig\n * \"total signers\" required, rather than a percentage of the tokens.\n *\n * This contract is an extensible version of LinearERC721Voting, with all functions\n * marked as `virtual`. This allows other contracts to inherit from it and override\n * any part of its functionality. The existence of this contract enables the creation\n * of more specialized voting strategies that build upon the basic linear ERC721 voting\n * mechanism while allowing for customization of specific aspects as needed.\n */\nabstract contract LinearERC721VotingExtensible is\n    BaseStrategy,\n    BaseVotingBasisPercent,\n    IERC721VotingStrategy\n{\n    /**\n     * The voting options for a Proposal.\n     */\n    enum VoteType {\n        NO, // disapproves of executing the Proposal\n        YES, // approves of executing the Proposal\n        ABSTAIN // neither YES nor NO, i.e. voting \"present\"\n    }\n\n    /**\n     * Defines the current state of votes on a particular Proposal.\n     */\n    struct ProposalVotes {\n        uint32 votingStartBlock; // block that voting starts at\n        uint32 votingEndBlock; // block that voting ends\n        uint256 noVotes; // current number of NO votes for the Proposal\n        uint256 yesVotes; // current number of YES votes for the Proposal\n        uint256 abstainVotes; // current number of ABSTAIN votes for the Proposal\n        /**\n         * ERC-721 contract address to individual NFT id to bool\n         * of whether it has voted on this proposal.\n         */\n        mapping(address => mapping(uint256 => bool)) hasVoted;\n    }\n\n    /** `proposalId` to `ProposalVotes`, the voting state of a Proposal. */\n    mapping(uint256 => ProposalVotes) public proposalVotes;\n\n    /** The list of ERC-721 tokens that can vote. */\n    address[] public tokenAddresses;\n\n    /** ERC-721 address to its voting weight per NFT id.  */\n    mapping(address => uint256) public tokenWeights;\n\n    /** Number of blocks a new Proposal can be voted on. */\n    uint32 public votingPeriod;\n\n    /**\n     * The total number of votes required to achieve quorum.\n     * \"Quorum threshold\" is used instead of a quorum percent because IERC721 has no\n     * totalSupply function, so the contract cannot determine this.\n     */\n    uint256 public quorumThreshold;\n\n    /**\n     * The minimum number of voting power required to create a new proposal.\n     */\n    uint256 public proposerThreshold;\n\n    event VotingPeriodUpdated(uint32 votingPeriod);\n    event QuorumThresholdUpdated(uint256 quorumThreshold);\n    event ProposerThresholdUpdated(uint256 proposerThreshold);\n    event ProposalInitialized(uint32 proposalId, uint32 votingEndBlock);\n    event Voted(\n        address voter,\n        uint32 proposalId,\n        uint8 voteType,\n        address[] tokenAddresses,\n        uint256[] tokenIds\n    );\n    event GovernanceTokenAdded(address token, uint256 weight);\n    event GovernanceTokenRemoved(address token);\n\n    error InvalidParams();\n    error InvalidProposal();\n    error VotingEnded();\n    error InvalidVote();\n    error InvalidTokenAddress();\n    error NoVotingWeight();\n    error TokenAlreadySet();\n    error TokenNotSet();\n    error IdAlreadyVoted(uint256 tokenId);\n    error IdNotOwned(uint256 tokenId);\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address[] memory _tokens`, `uint256[] memory _weights`, `address _azoriusModule`,\n     * `uint32 _votingPeriod`, `uint256 _quorumThreshold`, `uint256 _proposerThreshold`,\n     * `uint256 _basisNumerator`\n     */\n    function setUp(\n        bytes memory initializeParams\n    ) public virtual override initializer {\n        (\n            address _owner,\n            address[] memory _tokens,\n            uint256[] memory _weights,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _quorumThreshold,\n            uint256 _proposerThreshold,\n            uint256 _basisNumerator\n        ) = abi.decode(\n                initializeParams,\n                (\n                    address,\n                    address[],\n                    uint256[],\n                    address,\n                    uint32,\n                    uint256,\n                    uint256,\n                    uint256\n                )\n            );\n\n        if (_tokens.length != _weights.length) {\n            revert InvalidParams();\n        }\n\n        for (uint i = 0; i < _tokens.length; ) {\n            _addGovernanceToken(_tokens[i], _weights[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        __Ownable_init();\n        transferOwnership(_owner);\n        _setAzorius(_azoriusModule);\n        _updateQuorumThreshold(_quorumThreshold);\n        _updateProposerThreshold(_proposerThreshold);\n        _updateBasisNumerator(_basisNumerator);\n        _updateVotingPeriod(_votingPeriod);\n\n        emit StrategySetUp(_azoriusModule, _owner);\n    }\n\n    /**\n     * Adds a new ERC-721 token as a governance token, along with its associated weight.\n     *\n     * @param _tokenAddress the address of the ERC-721 token\n     * @param _weight the number of votes each NFT id is worth\n     */\n    function addGovernanceToken(\n        address _tokenAddress,\n        uint256 _weight\n    ) external virtual onlyOwner {\n        _addGovernanceToken(_tokenAddress, _weight);\n    }\n\n    /**\n     * Updates the voting time period for new Proposals.\n     *\n     * @param _votingPeriod voting time period (in blocks)\n     */\n    function updateVotingPeriod(\n        uint32 _votingPeriod\n    ) external virtual onlyOwner {\n        _updateVotingPeriod(_votingPeriod);\n    }\n\n    /**\n     * Updates the quorum required for future Proposals.\n     *\n     * @param _quorumThreshold total voting weight required to achieve quorum\n     */\n    function updateQuorumThreshold(\n        uint256 _quorumThreshold\n    ) external virtual onlyOwner {\n        _updateQuorumThreshold(_quorumThreshold);\n    }\n\n    /**\n     * Updates the voting weight required to submit new Proposals.\n     *\n     * @param _proposerThreshold required voting weight\n     */\n    function updateProposerThreshold(\n        uint256 _proposerThreshold\n    ) external virtual onlyOwner {\n        _updateProposerThreshold(_proposerThreshold);\n    }\n\n    /**\n     * Returns whole list of governance tokens addresses\n     */\n    function getAllTokenAddresses()\n        external\n        view\n        virtual\n        returns (address[] memory)\n    {\n        return tokenAddresses;\n    }\n\n    /**\n     * Returns the current state of the specified Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @return noVotes current count of \"NO\" votes\n     * @return yesVotes current count of \"YES\" votes\n     * @return abstainVotes current count of \"ABSTAIN\" votes\n     * @return startBlock block number voting starts\n     * @return endBlock block number voting ends\n     */\n    function getProposalVotes(\n        uint32 _proposalId\n    )\n        external\n        view\n        virtual\n        returns (\n            uint256 noVotes,\n            uint256 yesVotes,\n            uint256 abstainVotes,\n            uint32 startBlock,\n            uint32 endBlock\n        )\n    {\n        noVotes = proposalVotes[_proposalId].noVotes;\n        yesVotes = proposalVotes[_proposalId].yesVotes;\n        abstainVotes = proposalVotes[_proposalId].abstainVotes;\n        startBlock = proposalVotes[_proposalId].votingStartBlock;\n        endBlock = proposalVotes[_proposalId].votingEndBlock;\n    }\n\n    /**\n     * Submits a vote on an existing Proposal.\n     *\n     * @param _proposalId id of the Proposal to vote on\n     * @param _voteType Proposal support as defined in VoteType (NO, YES, ABSTAIN)\n     * @param _tokenAddresses list of ERC-721 addresses that correspond to ids in _tokenIds\n     * @param _tokenIds list of unique token ids that correspond to their ERC-721 address in _tokenAddresses\n     */\n    function vote(\n        uint32 _proposalId,\n        uint8 _voteType,\n        address[] memory _tokenAddresses,\n        uint256[] memory _tokenIds\n    ) external virtual {\n        if (_tokenAddresses.length != _tokenIds.length) revert InvalidParams();\n        _vote(_proposalId, msg.sender, _voteType, _tokenAddresses, _tokenIds);\n    }\n\n    /** @inheritdoc IERC721VotingStrategy*/\n    function getTokenWeight(\n        address _tokenAddress\n    ) external view virtual override returns (uint256) {\n        return tokenWeights[_tokenAddress];\n    }\n\n    /**\n     * Returns whether an NFT id has already voted.\n     *\n     * @param _proposalId the id of the Proposal\n     * @param _tokenAddress the ERC-721 contract address\n     * @param _tokenId the unique id of the NFT\n     */\n    function hasVoted(\n        uint32 _proposalId,\n        address _tokenAddress,\n        uint256 _tokenId\n    ) external view virtual returns (bool) {\n        return proposalVotes[_proposalId].hasVoted[_tokenAddress][_tokenId];\n    }\n\n    /**\n     * Removes the given ERC-721 token address from the list of governance tokens.\n     *\n     * @param _tokenAddress the ERC-721 token to remove\n     */\n    function removeGovernanceToken(\n        address _tokenAddress\n    ) external virtual onlyOwner {\n        if (tokenWeights[_tokenAddress] == 0) revert TokenNotSet();\n\n        tokenWeights[_tokenAddress] = 0;\n\n        uint256 length = tokenAddresses.length;\n        for (uint256 i = 0; i < length; ) {\n            if (_tokenAddress == tokenAddresses[i]) {\n                uint256 last = length - 1;\n                tokenAddresses[i] = tokenAddresses[last]; // move the last token into the position to remove\n                delete tokenAddresses[last]; // delete the last token\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit GovernanceTokenRemoved(_tokenAddress);\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function initializeProposal(\n        bytes memory _data\n    ) public virtual override onlyAzorius {\n        uint32 proposalId = abi.decode(_data, (uint32));\n        uint32 _votingEndBlock = uint32(block.number) + votingPeriod;\n\n        proposalVotes[proposalId].votingEndBlock = _votingEndBlock;\n        proposalVotes[proposalId].votingStartBlock = uint32(block.number);\n\n        emit ProposalInitialized(proposalId, _votingEndBlock);\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isPassed(\n        uint32 _proposalId\n    ) public view virtual override returns (bool) {\n        return (block.number > proposalVotes[_proposalId].votingEndBlock && // voting period has ended\n            quorumThreshold <=\n            proposalVotes[_proposalId].yesVotes +\n                proposalVotes[_proposalId].abstainVotes && // yes + abstain votes meets the quorum\n            meetsBasis(\n                proposalVotes[_proposalId].yesVotes,\n                proposalVotes[_proposalId].noVotes\n            )); // yes votes meets the basis\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function isProposer(\n        address _address\n    ) public view virtual override returns (bool) {\n        uint256 totalWeight = 0;\n        for (uint i = 0; i < tokenAddresses.length; ) {\n            address tokenAddress = tokenAddresses[i];\n            totalWeight +=\n                IERC721(tokenAddress).balanceOf(_address) *\n                tokenWeights[tokenAddress];\n            unchecked {\n                ++i;\n            }\n        }\n        return totalWeight >= proposerThreshold;\n    }\n\n    /** @inheritdoc BaseStrategy*/\n    function votingEndBlock(\n        uint32 _proposalId\n    ) public view virtual override returns (uint32) {\n        return proposalVotes[_proposalId].votingEndBlock;\n    }\n\n    /** Internal implementation of `addGovernanceToken` */\n    function _addGovernanceToken(\n        address _tokenAddress,\n        uint256 _weight\n    ) internal virtual {\n        if (!IERC721(_tokenAddress).supportsInterface(0x80ac58cd))\n            revert InvalidTokenAddress();\n\n        if (_weight == 0) revert NoVotingWeight();\n\n        if (tokenWeights[_tokenAddress] > 0) revert TokenAlreadySet();\n\n        tokenAddresses.push(_tokenAddress);\n        tokenWeights[_tokenAddress] = _weight;\n\n        emit GovernanceTokenAdded(_tokenAddress, _weight);\n    }\n\n    /** Internal implementation of `updateVotingPeriod`. */\n    function _updateVotingPeriod(uint32 _votingPeriod) internal virtual {\n        votingPeriod = _votingPeriod;\n        emit VotingPeriodUpdated(_votingPeriod);\n    }\n\n    /** Internal implementation of `updateQuorumThreshold`. */\n    function _updateQuorumThreshold(uint256 _quorumThreshold) internal virtual {\n        quorumThreshold = _quorumThreshold;\n        emit QuorumThresholdUpdated(quorumThreshold);\n    }\n\n    /** Internal implementation of `updateProposerThreshold`. */\n    function _updateProposerThreshold(\n        uint256 _proposerThreshold\n    ) internal virtual {\n        proposerThreshold = _proposerThreshold;\n        emit ProposerThresholdUpdated(_proposerThreshold);\n    }\n\n    /**\n     * Internal function for casting a vote on a Proposal.\n     *\n     * @param _proposalId id of the Proposal\n     * @param _voter address casting the vote\n     * @param _voteType vote support, as defined in VoteType\n     * @param _tokenAddresses list of ERC-721 addresses that correspond to ids in _tokenIds\n     * @param _tokenIds list of unique token ids that correspond to their ERC-721 address in _tokenAddresses\n     */\n    function _vote(\n        uint32 _proposalId,\n        address _voter,\n        uint8 _voteType,\n        address[] memory _tokenAddresses,\n        uint256[] memory _tokenIds\n    ) internal virtual {\n        uint256 weight;\n\n        // verifies the voter holds the NFTs and returns the total weight associated with their tokens\n        // the frontend will need to determine whether an address can vote on a proposal, as it is possible\n        // to vote twice if you get more weight later on\n        for (uint256 i = 0; i < _tokenAddresses.length; ) {\n            address tokenAddress = _tokenAddresses[i];\n            uint256 tokenId = _tokenIds[i];\n\n            if (_voter != IERC721(tokenAddress).ownerOf(tokenId)) {\n                revert IdNotOwned(tokenId);\n            }\n\n            if (\n                proposalVotes[_proposalId].hasVoted[tokenAddress][tokenId] ==\n                true\n            ) {\n                revert IdAlreadyVoted(tokenId);\n            }\n\n            weight += tokenWeights[tokenAddress];\n            proposalVotes[_proposalId].hasVoted[tokenAddress][tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (weight == 0) revert NoVotingWeight();\n\n        ProposalVotes storage proposal = proposalVotes[_proposalId];\n\n        if (proposal.votingEndBlock == 0) revert InvalidProposal();\n\n        if (block.number > proposal.votingEndBlock) revert VotingEnded();\n\n        if (_voteType == uint8(VoteType.NO)) {\n            proposal.noVotes += weight;\n        } else if (_voteType == uint8(VoteType.YES)) {\n            proposal.yesVotes += weight;\n        } else if (_voteType == uint8(VoteType.ABSTAIN)) {\n            proposal.abstainVotes += weight;\n        } else {\n            revert InvalidVote();\n        }\n\n        emit Voted(_voter, _proposalId, _voteType, _tokenAddresses, _tokenIds);\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC721VotingV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {IERC721VotingStrategy} from \"../interfaces/IERC721VotingStrategy.sol\";\nimport {Version} from \"../../Version.sol\";\nimport {ERC4337VoterSupportV1} from \"./ERC4337VoterSupportV1.sol\";\nimport {LinearERC721VotingExtensible} from \"./LinearERC721VotingExtensible.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/**\n * An Azorius strategy that allows multiple ERC721 tokens to be registered as governance tokens,\n * each with their own voting weight.\n *\n * This is slightly different from ERC-20 voting, since there is no way to snapshot ERC721 holdings.\n * Each ERC721 id can vote once, reguardless of what address held it when a proposal was created.\n *\n * Also, this uses \"quorumThreshold\" rather than LinearERC20Voting's quorumPercent, because the\n * total supply of NFTs is not knowable within the IERC721 interface.  This is similar to a multisig\n * \"total signers\" required, rather than a percentage of the tokens.\n */\ncontract LinearERC721VotingV1 is\n    LinearERC721VotingExtensible,\n    ERC165,\n    ERC4337VoterSupportV1,\n    Version\n{\n    uint16 private constant VERSION = 1;\n\n    /**\n     * @dev Constructor that disables initializers\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address[] memory _tokens`, `uint256[] memory _weights`, `address _azoriusModule`,\n     * `uint32 _votingPeriod`, `uint256 _quorumThreshold`, `uint256 _basisNumerator`,\n     * `address _lightAccountFactory`\n     */\n    function setUp(bytes memory initializeParams) public virtual override {\n        (\n            address _owner,\n            address[] memory _tokens,\n            uint256[] memory _weights,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _quorumThreshold,\n            uint256 _proposerThreshold,\n            uint256 _basisNumerator,\n            address _lightAccountFactory\n        ) = abi.decode(\n                initializeParams,\n                (\n                    address,\n                    address[],\n                    uint256[],\n                    address,\n                    uint32,\n                    uint256,\n                    uint256,\n                    uint256,\n                    address\n                )\n            );\n\n        LinearERC721VotingExtensible.setUp(\n            abi.encode(\n                _owner,\n                _tokens,\n                _weights,\n                _azoriusModule,\n                _votingPeriod,\n                _quorumThreshold,\n                _proposerThreshold,\n                _basisNumerator\n            )\n        );\n\n        __ERC4337VoterSupportV1_init(_lightAccountFactory);\n    }\n\n    /**\n     * Submits a vote on an existing Proposal.\n     *\n     * @param _proposalId id of the Proposal to vote on\n     * @param _voteType Proposal support as defined in VoteType (NO, YES, ABSTAIN)\n     * @param _tokenAddresses list of ERC-721 addresses that correspond to ids in _tokenIds\n     * @param _tokenIds list of unique token ids that correspond to their ERC-721 address in _tokenAddresses\n     */\n    function vote(\n        uint32 _proposalId,\n        uint8 _voteType,\n        address[] memory _tokenAddresses,\n        uint256[] memory _tokenIds\n    ) external virtual override {\n        if (_tokenAddresses.length != _tokenIds.length) revert InvalidParams();\n        _vote(\n            _proposalId,\n            _voter(msg.sender),\n            _voteType,\n            _tokenAddresses,\n            _tokenIds\n        );\n    }\n\n    /** @inheritdoc LinearERC721VotingExtensible*/\n    function _vote(\n        uint32 _proposalId,\n        address _voter,\n        uint8 _voteType,\n        address[] memory _tokenAddresses,\n        uint256[] memory _tokenIds\n    ) internal virtual override {\n        uint256 weight;\n\n        // verifies the voter holds the NFTs and returns the total weight associated with their tokens\n        // the frontend will need to determine whether an address can vote on a proposal, as it is possible\n        // to vote twice if you get more weight later on\n        for (uint256 i = 0; i < _tokenAddresses.length; ) {\n            address tokenAddress = _tokenAddresses[i];\n            uint256 tokenId = _tokenIds[i];\n\n            if (_voter != IERC721(tokenAddress).ownerOf(tokenId)) {\n                revert IdNotOwned(tokenId);\n            }\n\n            if (\n                proposalVotes[_proposalId].hasVoted[tokenAddress][tokenId] ==\n                true\n            ) {\n                revert IdAlreadyVoted(tokenId);\n            }\n\n            weight += tokenWeights[tokenAddress];\n            proposalVotes[_proposalId].hasVoted[tokenAddress][tokenId] = true;\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (weight == 0) revert NoVotingWeight();\n\n        ProposalVotes storage proposal = proposalVotes[_proposalId];\n\n        if (proposal.votingEndBlock == 0) revert InvalidProposal();\n\n        if (block.number > proposal.votingEndBlock) {\n            if (!_votingPeriodEnded[_proposalId]) {\n                _votingPeriodEnded[_proposalId] = true;\n                emit VotingPeriodEnded(\n                    _proposalId,\n                    proposal.votingEndBlock,\n                    block.number\n                );\n                return;\n            }\n            revert VotingEnded();\n        }\n\n        if (_voteType == uint8(VoteType.NO)) {\n            proposal.noVotes += weight;\n        } else if (_voteType == uint8(VoteType.YES)) {\n            proposal.yesVotes += weight;\n        } else if (_voteType == uint8(VoteType.ABSTAIN)) {\n            proposal.abstainVotes += weight;\n        } else {\n            revert InvalidVote();\n        }\n\n        emit Voted(_voter, _proposalId, _voteType, _tokenAddresses, _tokenIds);\n    }\n\n    function getVersion() public view virtual override returns (uint16) {\n        return VERSION;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(Version, ERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721VotingStrategy).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC721VotingWithHatsProposalCreation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport {LinearERC721VotingExtensible} from \"./LinearERC721VotingExtensible.sol\";\nimport {HatsProposalCreationWhitelist} from \"./HatsProposalCreationWhitelist.sol\";\nimport {IHats} from \"../../interfaces/hats/IHats.sol\";\n\n/**\n * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that\n * enables linear (i.e. 1 to 1) ERC721 based token voting, with proposal creation\n * restricted to users wearing whitelisted Hats.\n */\ncontract LinearERC721VotingWithHatsProposalCreation is\n    HatsProposalCreationWhitelist,\n    LinearERC721VotingExtensible\n{\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address[] memory _tokens`, `uint256[] memory _weights`, `address _azoriusModule`,\n     * `uint32 _votingPeriod`, `uint256 _quorumThreshold`, `uint256 _basisNumerator`,\n     * `address _hatsContract`, `uint256[] _initialWhitelistedHats`\n     */\n    function setUp(\n        bytes memory initializeParams\n    )\n        public\n        override(HatsProposalCreationWhitelist, LinearERC721VotingExtensible)\n    {\n        (\n            address _owner,\n            address[] memory _tokens,\n            uint256[] memory _weights,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _quorumThreshold,\n            uint256 _basisNumerator,\n            address _hatsContract,\n            uint256[] memory _initialWhitelistedHats\n        ) = abi.decode(\n                initializeParams,\n                (\n                    address,\n                    address[],\n                    uint256[],\n                    address,\n                    uint32,\n                    uint256,\n                    uint256,\n                    address,\n                    uint256[]\n                )\n            );\n\n        LinearERC721VotingExtensible.setUp(\n            abi.encode(\n                _owner,\n                _tokens,\n                _weights,\n                _azoriusModule,\n                _votingPeriod,\n                _quorumThreshold,\n                0, // _proposerThreshold is zero because we only care about the hat check\n                _basisNumerator\n            )\n        );\n\n        HatsProposalCreationWhitelist.setUp(\n            abi.encode(_hatsContract, _initialWhitelistedHats)\n        );\n    }\n\n    /** @inheritdoc HatsProposalCreationWhitelist*/\n    function isProposer(\n        address _address\n    )\n        public\n        view\n        override(HatsProposalCreationWhitelist, LinearERC721VotingExtensible)\n        returns (bool)\n    {\n        return HatsProposalCreationWhitelist.isProposer(_address);\n    }\n}\n"
    },
    "contracts/azorius/strategies/LinearERC721VotingWithHatsProposalCreationV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {LinearERC721VotingV1} from \"./LinearERC721VotingV1.sol\";\nimport {LinearERC721VotingExtensible} from \"./LinearERC721VotingExtensible.sol\";\nimport {HatsProposalCreationWhitelistV1} from \"./HatsProposalCreationWhitelistV1.sol\";\n\n/**\n * An [Azorius](./Azorius.md) [BaseStrategy](./BaseStrategy.md) implementation that\n * enables linear (i.e. 1 to 1) ERC721 based token voting, with proposal creation\n * restricted to users wearing whitelisted Hats.\n */\ncontract LinearERC721VotingWithHatsProposalCreationV1 is\n    LinearERC721VotingV1,\n    HatsProposalCreationWhitelistV1\n{\n    uint16 private constant VERSION = 1;\n\n    /**\n     * @dev Constructor that disables initializers\n     */\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address[] memory _tokens`, `uint256[] memory _weights`, `address _azoriusModule`,\n     * `uint32 _votingPeriod`, `uint256 _quorumThreshold`, `uint256 _basisNumerator`,\n     * `address _hatsContract`, `uint256[] _initialWhitelistedHats`, `address _lightAccountFactory`\n     */\n    function setUp(\n        bytes memory initializeParams\n    ) public override(LinearERC721VotingV1, HatsProposalCreationWhitelistV1) {\n        (\n            address _owner,\n            address[] memory _tokens,\n            uint256[] memory _weights,\n            address _azoriusModule,\n            uint32 _votingPeriod,\n            uint256 _quorumThreshold,\n            uint256 _basisNumerator,\n            address _hatsContract,\n            uint256[] memory _initialWhitelistedHats,\n            address _lightAccountFactory\n        ) = abi.decode(\n                initializeParams,\n                (\n                    address,\n                    address[],\n                    uint256[],\n                    address,\n                    uint32,\n                    uint256,\n                    uint256,\n                    address,\n                    uint256[],\n                    address\n                )\n            );\n\n        LinearERC721VotingV1.setUp(\n            abi.encode(\n                _owner,\n                _tokens,\n                _weights,\n                _azoriusModule,\n                _votingPeriod,\n                _quorumThreshold,\n                0, // _proposerThreshold is zero because we only care about the hat check\n                _basisNumerator,\n                _lightAccountFactory\n            )\n        );\n\n        HatsProposalCreationWhitelistV1.setUp(\n            abi.encode(_hatsContract, _initialWhitelistedHats)\n        );\n    }\n\n    function isProposer(\n        address _address\n    ) public view virtual override returns (bool) {\n        return isWearingWhitelistedHat(_address);\n    }\n\n    /**\n     * Implementation of version\n     */\n    function getVersion() public view virtual override returns (uint16) {\n        return VERSION;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(HatsProposalCreationWhitelistV1, LinearERC721VotingV1)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/AzoriusFreezeGuard.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { IBaseFreezeVoting } from \"./interfaces/IBaseFreezeVoting.sol\";\nimport { IGuard } from \"@gnosis.pm/zodiac/contracts/interfaces/IGuard.sol\";\nimport { FactoryFriendly } from \"@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol\";\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { BaseGuard } from \"@gnosis.pm/zodiac/contracts/guard/BaseGuard.sol\";\n\n/**\n * A Safe Transaction Guard contract that prevents an [Azorius](./azorius/Azorius.md) \n * subDAO from executing transactions if it has been frozen by its parentDAO.\n *\n * See https://docs.safe.global/learn/safe-core/safe-core-protocol/guards.\n */\ncontract AzoriusFreezeGuard is FactoryFriendly, IGuard, BaseGuard {\n\n    /**\n     * A reference to the freeze voting contract, which manages the freeze\n     * voting process and maintains the frozen / unfrozen state of the DAO.\n     */\n    IBaseFreezeVoting public freezeVoting;\n\n    event AzoriusFreezeGuardSetUp(\n        address indexed creator,\n        address indexed owner,\n        address indexed freezeVoting\n    );\n\n    error DAOFrozen();\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address _freezeVoting`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        __Ownable_init();\n        (address _owner, address _freezeVoting) = abi.decode(\n            initializeParams,\n            (address, address)\n        );\n\n        transferOwnership(_owner);\n        freezeVoting = IBaseFreezeVoting(_freezeVoting);\n\n        emit AzoriusFreezeGuardSetUp(msg.sender, _owner, _freezeVoting);\n    }\n\n    /**\n     * This function is called by the Safe to check if the transaction\n     * is able to be executed and reverts if the guard conditions are\n     * not met.\n     *\n     * In our implementation, this reverts if the DAO is frozen.\n     */\n    function checkTransaction(\n        address,\n        uint256,\n        bytes memory,\n        Enum.Operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external view override(BaseGuard, IGuard) {\n        // if the DAO is currently frozen, revert\n        // see BaseFreezeVoting for freeze voting details\n        if(freezeVoting.isFrozen()) revert DAOFrozen();\n    }\n\n    /**\n     * A callback performed after a transaction is executed on the Safe. This is a required\n     * function of the `BaseGuard` and `IGuard` interfaces that we do not make use of.\n     */\n    function checkAfterExecution(bytes32, bool) external view override(BaseGuard, IGuard) {\n        // not implementated\n    }\n}\n"
    },
    "contracts/BaseFreezeVoting.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { FactoryFriendly } from \"@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol\";\nimport { IBaseFreezeVoting } from \"./interfaces/IBaseFreezeVoting.sol\";\n\n/**\n * The base abstract contract which holds the state of a vote to freeze a childDAO.\n *\n * The freeze feature gives a way for parentDAOs to have a limited measure of control\n * over their created subDAOs.\n *\n * Normally a subDAO operates independently, and can vote on or sign transactions, \n * however should the parent disagree with a decision made by the subDAO, any parent\n * token holder can initiate a vote to \"freeze\" it, making executing transactions impossible\n * for the time denoted by `freezePeriod`.\n *\n * This requires a number of votes equal to `freezeVotesThreshold`, within the `freezeProposalPeriod`\n * to be successful.\n *\n * Following a successful freeze vote, the childDAO will be unable to execute transactions, due to\n * a Safe Transaction Guard, until the `freezePeriod` has elapsed.\n */\nabstract contract BaseFreezeVoting is FactoryFriendly, IBaseFreezeVoting {\n\n    /** Block number the freeze proposal was created at. */\n    uint32 public freezeProposalCreatedBlock;\n\n    /** Number of blocks a freeze proposal has to succeed. */\n    uint32 public freezeProposalPeriod;\n\n    /** Number of blocks a freeze lasts, from time of freeze proposal creation. */\n    uint32 public freezePeriod;\n\n    /** Number of freeze votes required to activate a freeze. */\n    uint256 public freezeVotesThreshold;\n\n    /** Number of accrued freeze votes. */\n    uint256 public freezeProposalVoteCount;\n\n    /**\n    * Mapping of address to the block the freeze vote was started to \n    * whether the address has voted yet on the freeze proposal.\n    */\n    mapping(address => mapping(uint256 => bool)) public userHasFreezeVoted;\n\n    event FreezeVoteCast(address indexed voter, uint256 votesCast);\n    event FreezeProposalCreated(address indexed creator);\n    event FreezeVotesThresholdUpdated(uint256 freezeVotesThreshold);\n    event FreezePeriodUpdated(uint32 freezePeriod);\n    event FreezeProposalPeriodUpdated(uint32 freezeProposalPeriod);\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /**\n     * Casts a positive vote to freeze the subDAO. This function is intended to be called\n     * by the individual token holders themselves directly, and will allot their token\n     * holdings a \"yes\" votes towards freezing.\n     *\n     * Additionally, if a vote to freeze is not already running, calling this will initiate\n     * a new vote to freeze it.\n     */\n    function castFreezeVote() external virtual;\n\n    /**\n     * Returns true if the DAO is currently frozen, false otherwise.\n     * \n     * @return bool whether the DAO is currently frozen\n     */\n    function isFrozen() external view returns (bool) {\n        return freezeProposalVoteCount >= freezeVotesThreshold \n            && block.number < freezeProposalCreatedBlock + freezePeriod;\n    }\n\n    /**\n     * Unfreezes the DAO, only callable by the owner (parentDAO).\n     */\n    function unfreeze() external onlyOwner {\n        freezeProposalCreatedBlock = 0;\n        freezeProposalVoteCount = 0;\n    }\n\n    /**\n     * Updates the freeze votes threshold, the number of votes required to enact a freeze.\n     *\n     * @param _freezeVotesThreshold number of freeze votes required to activate a freeze\n     */\n    function updateFreezeVotesThreshold(uint256 _freezeVotesThreshold) external onlyOwner {\n        _updateFreezeVotesThreshold(_freezeVotesThreshold);\n    }\n\n    /**\n     * Updates the freeze proposal period, the time that parent token holders have to cast votes\n     * after a freeze vote has been initiated.\n     *\n     * @param _freezeProposalPeriod number of blocks a freeze vote has to succeed to enact a freeze\n     */\n    function updateFreezeProposalPeriod(uint32 _freezeProposalPeriod) external onlyOwner {\n        _updateFreezeProposalPeriod(_freezeProposalPeriod);\n    }\n\n    /**\n     * Updates the freeze period, the time the DAO will be unable to execute transactions for,\n     * should a freeze vote pass.\n     *\n     * @param _freezePeriod number of blocks a freeze lasts, from time of freeze proposal creation\n     */\n    function updateFreezePeriod(uint32 _freezePeriod) external onlyOwner {\n        _updateFreezePeriod(_freezePeriod);\n    }\n\n    /** Internal implementation of `updateFreezeVotesThreshold`. */\n    function _updateFreezeVotesThreshold(uint256 _freezeVotesThreshold) internal {\n        freezeVotesThreshold = _freezeVotesThreshold;\n        emit FreezeVotesThresholdUpdated(_freezeVotesThreshold);\n    }\n\n    /** Internal implementation of `updateFreezeProposalPeriod`. */\n    function _updateFreezeProposalPeriod(uint32 _freezeProposalPeriod) internal {\n        freezeProposalPeriod = _freezeProposalPeriod;\n        emit FreezeProposalPeriodUpdated(_freezeProposalPeriod);\n    }\n\n    /** Internal implementation of `updateFreezePeriod`. */\n    function _updateFreezePeriod(uint32 _freezePeriod) internal {\n        freezePeriod = _freezePeriod;\n        emit FreezePeriodUpdated(_freezePeriod);\n    }\n}\n"
    },
    "contracts/ERC20Claim.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport {IERC20Claim} from \"./interfaces/IERC20Claim.sol\";\nimport {VotesERC20, FactoryFriendly} from \"./VotesERC20.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * A simple contract that allows for parent DAOs that have created a new ERC-20\n * token voting subDAO to allocate a certain amount of those tokens as claimable\n * by the parent DAO's token holders.\n */\ncontract ERC20Claim is FactoryFriendly, IERC20Claim {\n\n    using SafeERC20 for IERC20;\n\n    /** The deadline block to claim tokens by, or 0 for indefinite. */\n    uint32 public deadlineBlock;\n\n    /** The address of the initial holder of the claimable `childERC20` tokens. */\n    address public funder;\n\n    /** Child ERC20 token address, to calculate the percentage claimable. */\n    address public childERC20;\n\n    /** Parent ERC20 token address, for calculating a snapshot of holdings. */\n    address public parentERC20;\n\n    /** Id of a snapshot of token holdings for this claim (see [VotesERC20](./VotesERC20.md)). */\n    uint256 public snapShotId;\n\n    /** Total amount of `childERC20` tokens allocated for claiming by parent holders. */\n    uint256 public parentAllocation;\n\n    /** Mapping of address to bool of whether the address has claimed already. */\n    mapping(address => bool) public claimed;\n\n    event ERC20ClaimCreated(\n        address parentToken,\n        address childToken,\n        uint256 parentAllocation,\n        uint256 snapshotId,\n        uint256 deadline\n    );\n\n    event ERC20Claimed(\n        address indexed pToken,\n        address indexed cToken,\n        address indexed claimer,\n        uint256 amount\n    );\n\n    error NoAllocation();\n    error AllocationClaimed();\n    error NotTheFunder();\n    error NoDeadline();\n    error DeadlinePending();\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `address _childTokenFunder`,\n     * `uint256 _deadlineBlock`, `address _parentERC20`, `address _childERC20`,\n     * `uint256 _parentAllocation`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        __Ownable_init();\n        (\n            uint32 _deadlineBlock,\n            address _childTokenFunder,\n            address _parentERC20,\n            address _childERC20,\n            uint256 _parentAllocation\n        ) = abi.decode(\n                initializeParams,\n                (uint32, address, address, address, uint256)\n            );\n\n        funder = _childTokenFunder;\n        deadlineBlock = _deadlineBlock;\n        childERC20 = _childERC20;\n        parentERC20 = _parentERC20;\n        parentAllocation = _parentAllocation;\n\n        snapShotId = VotesERC20(_parentERC20).captureSnapShot();\n\n        IERC20(_childERC20).safeTransferFrom(\n            _childTokenFunder,\n            address(this),\n            _parentAllocation\n        );\n\n        emit ERC20ClaimCreated(\n            _parentERC20,\n            _childERC20,\n            _parentAllocation,\n            snapShotId,\n            _deadlineBlock\n        );\n    }\n\n    /** @inheritdoc IERC20Claim*/\n    function claimTokens(address claimer) external {\n        uint256 amount = getClaimAmount(claimer); // get claimer balance\n\n        if (amount == 0) revert NoAllocation(); // the claimer has not been allocated tokens to claim\n\n        claimed[claimer] = true;\n\n        IERC20(childERC20).safeTransfer(claimer, amount); // transfer claimer balance\n\n        emit ERC20Claimed(parentERC20, childERC20, claimer, amount);\n    }\n\n    /** @inheritdoc IERC20Claim*/\n    function reclaim() external {\n        if (msg.sender != funder) revert NotTheFunder();\n        if (deadlineBlock == 0) revert NoDeadline();\n        if (block.number < deadlineBlock) revert DeadlinePending();\n        IERC20 token = IERC20(childERC20);\n        token.safeTransfer(funder, token.balanceOf(address(this)));\n    }\n\n    /** @inheritdoc IERC20Claim*/\n    function getClaimAmount(address claimer) public view returns (uint256) {\n        return\n            claimed[claimer]\n                ? 0\n                : (VotesERC20(parentERC20).balanceOfAt(claimer, snapShotId) *\n                    parentAllocation) /\n                    VotesERC20(parentERC20).totalSupplyAt(snapShotId);\n    }\n}\n"
    },
    "contracts/ERC20FreezeVoting.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { BaseFreezeVoting, IBaseFreezeVoting } from \"./BaseFreezeVoting.sol\";\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { IVotes } from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\n/**\n * A [BaseFreezeVoting](./BaseFreezeVoting.md) implementation which handles \n * freezes on ERC20 based token voting DAOs.\n */\ncontract ERC20FreezeVoting is BaseFreezeVoting {\n\n    /** A reference to the ERC20 voting token of the subDAO. */\n    IVotes public votesERC20;\n\n    event ERC20FreezeVotingSetUp(\n        address indexed owner,\n        address indexed votesERC20\n    );\n\n    error NoVotes();\n    error AlreadyVoted();\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `uint256 _freezeVotesThreshold`, `uint256 _freezeProposalPeriod`, `uint256 _freezePeriod`,\n     * `address _votesERC20`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (\n            address _owner,\n            uint256 _freezeVotesThreshold,\n            uint32 _freezeProposalPeriod,\n            uint32 _freezePeriod,\n            address _votesERC20\n        ) = abi.decode(\n                initializeParams,\n                (address, uint256, uint32, uint32, address)\n            );\n\n        __Ownable_init();\n        _transferOwnership(_owner);\n        _updateFreezeVotesThreshold(_freezeVotesThreshold);\n        _updateFreezeProposalPeriod(_freezeProposalPeriod);\n        _updateFreezePeriod(_freezePeriod);\n        freezePeriod = _freezePeriod;\n        votesERC20 = IVotes(_votesERC20);\n\n        emit ERC20FreezeVotingSetUp(_owner, _votesERC20);\n    }\n\n    /** @inheritdoc BaseFreezeVoting*/\n    function castFreezeVote() external override {\n        uint256 userVotes;\n\n        if (block.number > freezeProposalCreatedBlock + freezeProposalPeriod) {\n            // create a new freeze proposal and set total votes to msg.sender's vote count\n\n            freezeProposalCreatedBlock = uint32(block.number);\n\n            userVotes = votesERC20.getPastVotes(\n                msg.sender,\n                freezeProposalCreatedBlock - 1\n            );\n\n            if (userVotes == 0) revert NoVotes();\n\n            freezeProposalVoteCount = userVotes;\n\n            emit FreezeProposalCreated(msg.sender);\n        } else {\n            // there is an existing freeze proposal, count user's votes toward it\n\n            if (userHasFreezeVoted[msg.sender][freezeProposalCreatedBlock])\n                revert AlreadyVoted();\n\n            userVotes = votesERC20.getPastVotes(\n                msg.sender,\n                freezeProposalCreatedBlock - 1\n            );\n\n            if (userVotes == 0) revert NoVotes();\n\n            freezeProposalVoteCount += userVotes;\n        }        \n\n        userHasFreezeVoted[msg.sender][freezeProposalCreatedBlock] = true;\n\n        emit FreezeVoteCast(msg.sender, userVotes);\n    }\n}\n"
    },
    "contracts/ERC721FreezeVoting.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { IERC721VotingStrategy } from \"./azorius/interfaces/IERC721VotingStrategy.sol\";\nimport { BaseFreezeVoting, IBaseFreezeVoting } from \"./BaseFreezeVoting.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/**\n * A [BaseFreezeVoting](./BaseFreezeVoting.md) implementation which handles \n * freezes on ERC721 based token voting DAOs.\n */\ncontract ERC721FreezeVoting is BaseFreezeVoting {\n\n    /** A reference to the voting strategy of the parent DAO. */\n    IERC721VotingStrategy public strategy;\n\n    /**\n     * Mapping of block the freeze vote was started on, to the token address, to token id,\n     * to whether that token has been used to vote already.\n     */\n    mapping(uint256 => mapping(address => mapping(uint256 => bool))) public idHasFreezeVoted;\n\n    event ERC721FreezeVotingSetUp(address indexed owner, address indexed strategy);\n\n    error NoVotes();\n    error NotSupported();\n    error UnequalArrays();\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters.\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (\n            address _owner,\n            uint256 _freezeVotesThreshold,\n            uint32 _freezeProposalPeriod,\n            uint32 _freezePeriod,\n            address _strategy\n        ) = abi.decode(\n                initializeParams,\n                (address, uint256, uint32, uint32, address)\n            );\n\n        __Ownable_init();\n        _transferOwnership(_owner);\n        _updateFreezeVotesThreshold(_freezeVotesThreshold);\n        _updateFreezeProposalPeriod(_freezeProposalPeriod);\n        _updateFreezePeriod(_freezePeriod);\n        freezePeriod = _freezePeriod;\n        strategy = IERC721VotingStrategy(_strategy);\n\n        emit ERC721FreezeVotingSetUp(_owner, _strategy);\n    }\n\n    function castFreezeVote() external override pure { revert NotSupported(); }\n\n    function castFreezeVote(address[] memory _tokenAddresses, uint256[] memory _tokenIds) external {\n        if (_tokenAddresses.length != _tokenIds.length) revert UnequalArrays();\n\n        if (block.number > freezeProposalCreatedBlock + freezeProposalPeriod) {\n            // create a new freeze proposal\n            freezeProposalCreatedBlock = uint32(block.number);\n            freezeProposalVoteCount = 0;\n            emit FreezeProposalCreated(msg.sender);\n        }\n\n        uint256 userVotes = _getVotesAndUpdateHasVoted(_tokenAddresses, _tokenIds, msg.sender);\n        if (userVotes == 0) revert NoVotes();\n\n        freezeProposalVoteCount += userVotes;     \n\n        emit FreezeVoteCast(msg.sender, userVotes);\n    }\n\n    function _getVotesAndUpdateHasVoted(\n        address[] memory _tokenAddresses,\n        uint256[] memory _tokenIds,\n        address _voter\n    ) internal returns (uint256) {\n\n        uint256 votes = 0;\n\n        for (uint256 i = 0; i < _tokenAddresses.length; i++) {\n\n            address tokenAddress = _tokenAddresses[i];\n            uint256 tokenId = _tokenIds[i];\n\n            if (_voter != IERC721(tokenAddress).ownerOf(tokenId))\n                continue;\n\n            if (idHasFreezeVoted[freezeProposalCreatedBlock][tokenAddress][tokenId])\n                continue;\n            \n            votes += strategy.getTokenWeight(tokenAddress);\n\n            idHasFreezeVoted[freezeProposalCreatedBlock][tokenAddress][tokenId] = true;\n        }\n\n        return votes;\n    }\n}\n"
    },
    "contracts/FractalModule.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { Module, Enum } from \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\nimport { IFractalModule } from \"./interfaces/IFractalModule.sol\";\n\n /**\n  * Implementation of [IFractalModule](./interfaces/IFractalModule.md).\n  *\n  * A Safe module contract that allows for a \"parent-child\" DAO relationship.\n  *\n  * Adding the module allows for a designated set of addresses to execute\n  * transactions on the Safe, which in our implementation is the set of parent\n  * DAOs.\n  */\ncontract FractalModule is IFractalModule, Module {\n\n    /** Mapping of whether an address is a controller (typically a parentDAO). */\n    mapping(address => bool) public controllers;\n\n    event ControllersAdded(address[] controllers);\n    event ControllersRemoved(address[] controllers);\n\n    error Unauthorized();\n    error TxFailed();\n\n    /** Allows only authorized controllers to execute transactions on the Safe. */\n    modifier onlyAuthorized() {\n        if (owner() != msg.sender && !controllers[msg.sender])\n            revert Unauthorized();\n        _;\n    }\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `address _avatar`, `address _target`, `address[] memory _controllers`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        __Ownable_init();\n        (\n            address _owner,                 // controlling DAO\n            address _avatar,\n            address _target,\n            address[] memory _controllers   // authorized controllers\n        ) = abi.decode(\n                initializeParams,\n                (address, address, address, address[])\n            );\n\n        setAvatar(_avatar);\n        setTarget(_target);\n        addControllers(_controllers);\n        transferOwnership(_owner);\n    }\n\n    /** @inheritdoc IFractalModule*/\n    function removeControllers(address[] memory _controllers) external onlyOwner {\n        uint256 controllersLength = _controllers.length;\n        for (uint256 i; i < controllersLength; ) {\n            controllers[_controllers[i]] = false;\n            unchecked {\n                ++i;\n            }\n        }\n        emit ControllersRemoved(_controllers);\n    }\n\n    /** @inheritdoc IFractalModule*/\n    function execTx(bytes memory execTxData) public onlyAuthorized {\n        (\n            address _target,\n            uint256 _value,\n            bytes memory _data,\n            Enum.Operation _operation\n        ) = abi.decode(execTxData, (address, uint256, bytes, Enum.Operation));\n        if(!exec(_target, _value, _data, _operation)) revert TxFailed();\n    }\n\n    /** @inheritdoc IFractalModule*/\n    function addControllers(address[] memory _controllers) public onlyOwner {\n        uint256 controllersLength = _controllers.length;\n        for (uint256 i; i < controllersLength; ) {\n            controllers[_controllers[i]] = true;\n            unchecked {\n                ++i;\n            }\n        }\n        emit ControllersAdded(_controllers);\n    }\n}\n"
    },
    "contracts/interfaces/hats/HatsErrors.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface HatsErrors {\n    /// @notice Emitted when `user` is attempting to perform an action on `hatId` but is not wearing one of `hatId`'s admin hats\n    /// @dev Can be equivalent to `NotHatWearer(buildHatId(hatId))`, such as when emitted by `approveLinkTopHatToTree` or `relinkTopHatToTree`\n    error NotAdmin(address user, uint256 hatId);\n\n    /// @notice Emitted when attempting to perform an action as or for an account that is not a wearer of a given hat\n    error NotHatWearer();\n\n    /// @notice Emitted when attempting to perform an action that requires being either an admin or wearer of a given hat\n    error NotAdminOrWearer();\n\n    /// @notice Emitted when attempting to mint `hatId` but `hatId`'s maxSupply has been reached\n    error AllHatsWorn(uint256 hatId);\n\n    /// @notice Emitted when attempting to create a hat with a level 14 hat as its admin\n    error MaxLevelsReached();\n\n    /// @notice Emitted when an attempted hat id has empty intermediate level(s)\n    error InvalidHatId();\n\n    /// @notice Emitted when attempting to mint `hatId` to a `wearer` who is already wearing the hat\n    error AlreadyWearingHat(address wearer, uint256 hatId);\n\n    /// @notice Emitted when attempting to mint a non-existant hat\n    error HatDoesNotExist(uint256 hatId);\n\n    /// @notice Emmitted when attempting to mint or transfer a hat that is not active\n    error HatNotActive();\n\n    /// @notice Emitted when attempting to mint or transfer a hat to an ineligible wearer\n    error NotEligible();\n\n    /// @notice Emitted when attempting to check or set a hat's status from an account that is not that hat's toggle module\n    error NotHatsToggle();\n\n    /// @notice Emitted when attempting to check or set a hat wearer's status from an account that is not that hat's eligibility module\n    error NotHatsEligibility();\n\n    /// @notice Emitted when array arguments to a batch function have mismatching lengths\n    error BatchArrayLengthMismatch();\n\n    /// @notice Emitted when attempting to mutate or transfer an immutable hat\n    error Immutable();\n\n    /// @notice Emitted when attempting to change a hat's maxSupply to a value lower than its current supply\n    error NewMaxSupplyTooLow();\n\n    /// @notice Emitted when attempting to link a tophat to a new admin for which the tophat serves as an admin\n    error CircularLinkage();\n\n    /// @notice Emitted when attempting to link or relink a tophat to a separate tree\n    error CrossTreeLinkage();\n\n    /// @notice Emitted when attempting to link a tophat without a request\n    error LinkageNotRequested();\n\n    /// @notice Emitted when attempting to unlink a tophat that does not have a wearer\n    /// @dev This ensures that unlinking never results in a bricked tophat\n    error InvalidUnlink();\n\n    /// @notice Emmited when attempting to change a hat's eligibility or toggle module to the zero address\n    error ZeroAddress();\n\n    /// @notice Emmitted when attempting to change a hat's details or imageURI to a string with over 7000 bytes (~characters)\n    /// @dev This protects against a DOS attack where an admin iteratively extend's a hat's details or imageURI\n    ///      to be so long that reading it exceeds the block gas limit, breaking `uri()` and `viewHat()`\n    error StringTooLong();\n}\n"
    },
    "contracts/interfaces/hats/HatsEvents.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface HatsEvents {\n    /// @notice Emitted when a new hat is created\n    /// @param id The id for the new hat\n    /// @param details A description of the Hat\n    /// @param maxSupply The total instances of the Hat that can be worn at once\n    /// @param eligibility The address that can report on the Hat wearer's status\n    /// @param toggle The address that can deactivate the Hat\n    /// @param mutable_ Whether the hat's properties are changeable after creation\n    /// @param imageURI The image uri for this hat and the fallback for its\n    event HatCreated(\n        uint256 id,\n        string details,\n        uint32 maxSupply,\n        address eligibility,\n        address toggle,\n        bool mutable_,\n        string imageURI\n    );\n\n    /// @notice Emitted when a hat wearer's standing is updated\n    /// @dev Eligibility is excluded since the source of truth for eligibility is the eligibility module and may change without a transaction\n    /// @param hatId The id of the wearer's hat\n    /// @param wearer The wearer's address\n    /// @param wearerStanding Whether the wearer is in good standing for the hat\n    event WearerStandingChanged(\n        uint256 hatId,\n        address wearer,\n        bool wearerStanding\n    );\n\n    /// @notice Emitted when a hat's status is updated\n    /// @param hatId The id of the hat\n    /// @param newStatus Whether the hat is active\n    event HatStatusChanged(uint256 hatId, bool newStatus);\n\n    /// @notice Emitted when a hat's details are updated\n    /// @param hatId The id of the hat\n    /// @param newDetails The updated details\n    event HatDetailsChanged(uint256 hatId, string newDetails);\n\n    /// @notice Emitted when a hat's eligibility module is updated\n    /// @param hatId The id of the hat\n    /// @param newEligibility The updated eligibiliy module\n    event HatEligibilityChanged(uint256 hatId, address newEligibility);\n\n    /// @notice Emitted when a hat's toggle module is updated\n    /// @param hatId The id of the hat\n    /// @param newToggle The updated toggle module\n    event HatToggleChanged(uint256 hatId, address newToggle);\n\n    /// @notice Emitted when a hat's mutability is updated\n    /// @param hatId The id of the hat\n    event HatMutabilityChanged(uint256 hatId);\n\n    /// @notice Emitted when a hat's maximum supply is updated\n    /// @param hatId The id of the hat\n    /// @param newMaxSupply The updated max supply\n    event HatMaxSupplyChanged(uint256 hatId, uint32 newMaxSupply);\n\n    /// @notice Emitted when a hat's image URI is updated\n    /// @param hatId The id of the hat\n    /// @param newImageURI The updated image URI\n    event HatImageURIChanged(uint256 hatId, string newImageURI);\n\n    /// @notice Emitted when a tophat linkage is requested by its admin\n    /// @param domain The domain of the tree tophat to link\n    /// @param newAdmin The tophat's would-be admin in the parent tree\n    event TopHatLinkRequested(uint32 domain, uint256 newAdmin);\n\n    /// @notice Emitted when a tophat is linked to a another tree\n    /// @param domain The domain of the newly-linked tophat\n    /// @param newAdmin The tophat's new admin in the parent tree\n    event TopHatLinked(uint32 domain, uint256 newAdmin);\n}\n"
    },
    "contracts/interfaces/hats/IHats.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\nimport \"./IHatsIdUtilities.sol\";\nimport \"./HatsErrors.sol\";\nimport \"./HatsEvents.sol\";\n\ninterface IHats is IHatsIdUtilities, HatsErrors, HatsEvents {\n    function mintTopHat(\n        address _target,\n        string memory _details,\n        string memory _imageURI\n    ) external returns (uint256 topHatId);\n\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) external returns (uint256 newHatId);\n\n    function batchCreateHats(\n        uint256[] calldata _admins,\n        string[] calldata _details,\n        uint32[] calldata _maxSupplies,\n        address[] memory _eligibilityModules,\n        address[] memory _toggleModules,\n        bool[] calldata _mutables,\n        string[] calldata _imageURIs\n    ) external returns (bool success);\n\n    function getNextId(uint256 _admin) external view returns (uint256 nextId);\n\n    function mintHat(\n        uint256 _hatId,\n        address _wearer\n    ) external returns (bool success);\n\n    function batchMintHats(\n        uint256[] calldata _hatIds,\n        address[] calldata _wearers\n    ) external returns (bool success);\n\n    function setHatStatus(\n        uint256 _hatId,\n        bool _newStatus\n    ) external returns (bool toggled);\n\n    function checkHatStatus(uint256 _hatId) external returns (bool toggled);\n\n    function setHatWearerStatus(\n        uint256 _hatId,\n        address _wearer,\n        bool _eligible,\n        bool _standing\n    ) external returns (bool updated);\n\n    function checkHatWearerStatus(\n        uint256 _hatId,\n        address _wearer\n    ) external returns (bool updated);\n\n    function renounceHat(uint256 _hatId) external;\n\n    function transferHat(uint256 _hatId, address _from, address _to) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function makeHatImmutable(uint256 _hatId) external;\n\n    function changeHatDetails(\n        uint256 _hatId,\n        string memory _newDetails\n    ) external;\n\n    function changeHatEligibility(\n        uint256 _hatId,\n        address _newEligibility\n    ) external;\n\n    function changeHatToggle(uint256 _hatId, address _newToggle) external;\n\n    function changeHatImageURI(\n        uint256 _hatId,\n        string memory _newImageURI\n    ) external;\n\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external;\n\n    function requestLinkTopHatToTree(\n        uint32 _topHatId,\n        uint256 _newAdminHat\n    ) external;\n\n    function approveLinkTopHatToTree(\n        uint32 _topHatId,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external;\n\n    function unlinkTopHatFromTree(uint32 _topHatId, address _wearer) external;\n\n    function relinkTopHatWithinTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                              VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function viewHat(\n        uint256 _hatId\n    )\n        external\n        view\n        returns (\n            string memory details,\n            uint32 maxSupply,\n            uint32 supply,\n            address eligibility,\n            address toggle,\n            string memory imageURI,\n            uint16 lastHatId,\n            bool mutable_,\n            bool active\n        );\n\n    function isWearerOfHat(\n        address _user,\n        uint256 _hatId\n    ) external view returns (bool isWearer);\n\n    function isAdminOfHat(\n        address _user,\n        uint256 _hatId\n    ) external view returns (bool isAdmin);\n\n    function isInGoodStanding(\n        address _wearer,\n        uint256 _hatId\n    ) external view returns (bool standing);\n\n    function isEligible(\n        address _wearer,\n        uint256 _hatId\n    ) external view returns (bool eligible);\n\n    function getHatEligibilityModule(\n        uint256 _hatId\n    ) external view returns (address eligibility);\n\n    function getHatToggleModule(\n        uint256 _hatId\n    ) external view returns (address toggle);\n\n    function getHatMaxSupply(\n        uint256 _hatId\n    ) external view returns (uint32 maxSupply);\n\n    function hatSupply(uint256 _hatId) external view returns (uint32 supply);\n\n    function getImageURIForHat(\n        uint256 _hatId\n    ) external view returns (string memory _uri);\n\n    function balanceOf(\n        address wearer,\n        uint256 hatId\n    ) external view returns (uint256 balance);\n\n    function balanceOfBatch(\n        address[] calldata _wearers,\n        uint256[] calldata _hatIds\n    ) external view returns (uint256[] memory);\n\n    function uri(uint256 id) external view returns (string memory _uri);\n}\n"
    },
    "contracts/interfaces/hats/IHatsIdUtilities.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface IHatsIdUtilities {\n    function buildHatId(\n        uint256 _admin,\n        uint16 _newHat\n    ) external pure returns (uint256 id);\n\n    function getHatLevel(uint256 _hatId) external view returns (uint32 level);\n\n    function getLocalHatLevel(\n        uint256 _hatId\n    ) external pure returns (uint32 level);\n\n    function isTopHat(uint256 _hatId) external view returns (bool _topHat);\n\n    function isLocalTopHat(\n        uint256 _hatId\n    ) external pure returns (bool _localTopHat);\n\n    function isValidHatId(\n        uint256 _hatId\n    ) external view returns (bool validHatId);\n\n    function getAdminAtLevel(\n        uint256 _hatId,\n        uint32 _level\n    ) external view returns (uint256 admin);\n\n    function getAdminAtLocalLevel(\n        uint256 _hatId,\n        uint32 _level\n    ) external pure returns (uint256 admin);\n\n    function getTopHatDomain(\n        uint256 _hatId\n    ) external view returns (uint32 domain);\n\n    function getTippyTopHatDomain(\n        uint32 _topHatDomain\n    ) external view returns (uint32 domain);\n\n    function noCircularLinkage(\n        uint32 _topHatDomain,\n        uint256 _linkedAdmin\n    ) external view returns (bool notCircular);\n\n    function sameTippyTopHatDomain(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat\n    ) external view returns (bool sameDomain);\n}\n"
    },
    "contracts/interfaces/IBaseFreezeVoting.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\n/**\n * A specification for a contract which manages the ability to call for and cast a vote\n * to freeze a subDAO.\n *\n * The participants of this vote are parent token holders or signers. The DAO should be\n * able to operate as normal throughout the freeze voting process, however if the vote\n * passes, further transaction executions on the subDAO should be blocked via a Safe guard\n * module (see [MultisigFreezeGuard](../MultisigFreezeGuard.md) / [AzoriusFreezeGuard](../AzoriusFreezeGuard.md)).\n */\ninterface IBaseFreezeVoting {\n\n    /**\n     * Allows an address to cast a \"freeze vote\", which is a vote to freeze the DAO\n     * from executing transactions, even if they've already passed via a Proposal.\n     *\n     * If a vote to freeze has not already been initiated, a call to this function will do\n     * so.\n     *\n     * This function should be publicly callable by any DAO token holder or signer.\n     */\n    function castFreezeVote() external;\n\n    /**\n     * Unfreezes the DAO.\n     */\n    function unfreeze() external;\n\n    /**\n     * Updates the freeze votes threshold for future freeze votes. This is the number of token\n     * votes necessary to begin a freeze on the subDAO.\n     *\n     * @param _freezeVotesThreshold number of freeze votes required to activate a freeze\n     */\n    function updateFreezeVotesThreshold(uint256 _freezeVotesThreshold) external;\n\n    /**\n     * Updates the freeze proposal period for future freeze votes. This is the length of time\n     * (in blocks) that a freeze vote is conducted for.\n     *\n     * @param _freezeProposalPeriod number of blocks a freeze proposal has to succeed\n     */\n    function updateFreezeProposalPeriod(uint32 _freezeProposalPeriod) external;\n\n    /**\n     * Updates the freeze period. This is the length of time (in blocks) the subDAO is actually\n     * frozen for if a freeze vote passes.\n     *\n     * This period can be overridden by a call to `unfreeze()`, which would require a passed Proposal\n     * from the parentDAO.\n     *\n     * @param _freezePeriod number of blocks a freeze lasts, from time of freeze proposal creation\n     */\n    function updateFreezePeriod(uint32 _freezePeriod) external;\n\n    /**\n     * Returns true if the DAO is currently frozen, false otherwise.\n     *\n     * @return bool whether the DAO is currently frozen\n     */\n    function isFrozen() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC20Claim.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\n/**\n * A simple specification for an ERC-20 claim contract, that allows for parent \n * DAOs that have created a new ERC-20 token voting subDAO to allocate a certain\n * amount of those tokens as claimable by the parent DAO token holders or signers.\n */\ninterface IERC20Claim {\n\n    /**\n     * Allows parent token holders to claim tokens allocated by a \n     * subDAO during its creation.\n     *\n     * @param claimer address which is being claimed for, allowing any address to\n     *      process a claim for any other address\n     */\n    function claimTokens(address claimer) external;\n\n    /**\n     * Gets an address' token claim amount.\n     *\n     * @param claimer address to check the claim amount of\n     * @return uint256 the given address' claim amount\n     */\n    function getClaimAmount(address claimer) external view returns (uint256);\n\n    /**\n     * Returns unclaimed tokens after the claim deadline to the funder.\n     */\n    function reclaim() external;\n}\n"
    },
    "contracts/interfaces/IFractalModule.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * A specification for a Safe module contract that allows for a \"parent-child\"\n * DAO relationship.\n *\n * Adding the module should allow for a designated set of addresses to execute\n * transactions on the Safe, which in our implementation is the set of parent\n * DAOs.\n */\ninterface IFractalModule {\n\n    /**\n     * Allows an authorized address to execute arbitrary transactions on the Safe.\n     *\n     * @param execTxData data of the transaction to execute\n     */\n    function execTx(bytes memory execTxData) external;\n\n    /**\n     * Adds `_controllers` to the list of controllers, which are allowed\n     * to execute transactions on the Safe.\n     *\n     * @param _controllers addresses to add to the contoller list\n     */\n    function addControllers(address[] memory _controllers) external;\n\n    /**\n     * Removes `_controllers` from the list of controllers.\n     *\n     * @param _controllers addresses to remove from the controller list\n     */\n    function removeControllers(address[] memory _controllers) external;\n}\n"
    },
    "contracts/interfaces/IFractalRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\n/**\n * A utility contract which logs events pertaining to Fractal DAO metadata.\n */\ninterface IFractalRegistry {\n\n    /**\n     * Updates a DAO's registered \"name\". This is a simple string\n     * with no restrictions or validation for uniqueness.\n     *\n     * @param _name new DAO name\n     */\n    function updateDAOName(string memory _name) external;\n\n    /**\n     * Declares an address as a subDAO of the caller's address.\n     *\n     * This declaration has no binding logic, and serves only\n     * to allow us to find the list of \"potential\" subDAOs of any \n     * given Safe address.\n     *\n     * Given the list of declaring events, we can then check each\n     * Safe still has a [FractalModule](../FractalModule.md) attached.\n     *\n     * If no FractalModule is attached, we'll exclude it from the\n     * DAO hierarchy.\n     *\n     * In the case of a Safe attaching a FractalModule without calling \n     * to declare it, we would unfortunately not know to display it \n     * as a subDAO.\n     *\n     * @param _subDAOAddress address of the subDAO to declare \n     *      as a child of the caller\n     */\n    function declareSubDAO(address _subDAOAddress) external;\n}\n"
    },
    "contracts/interfaces/IHatsProposalCreationWhitelistV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {IHats} from \"./hats/IHats.sol\";\n\n/**\n * @title IHatsProposalCreationWhitelistV1\n * @dev Interface for HatsProposalCreationWhitelistV1 contract that manages proposal creation permissions\n * based on Hats Protocol.\n */\ninterface IHatsProposalCreationWhitelistV1 {\n    /**\n     * @dev Emitted when a Hat is added to the whitelist.\n     */\n    event HatWhitelisted(uint256 hatId);\n\n    /**\n     * @dev Emitted when a Hat is removed from the whitelist.\n     */\n    event HatUnwhitelisted(uint256 hatId);\n\n    /**\n     * @dev Error thrown when the Hats contract address is missing.\n     */\n    error MissingHatsContract();\n\n    /**\n     * @dev Error thrown when no Hats are whitelisted.\n     */\n    error NoHatsWhitelisted();\n\n    /**\n     * @dev Error thrown when attempting to whitelist a Hat that is already whitelisted.\n     */\n    error HatAlreadyWhitelisted();\n\n    /**\n     * @dev Error thrown when attempting to remove a Hat that is not whitelisted.\n     */\n    error HatNotWhitelisted();\n\n    /**\n     * @dev Returns the Hats contract.\n     * @return The Hats contract interface.\n     */\n    function hatsContract() external view returns (IHats);\n\n    /**\n     * @dev Adds a Hat to the whitelist for proposal creation.\n     * @param _hatId The ID of the Hat to whitelist\n     */\n    function whitelistHat(uint256 _hatId) external;\n\n    /**\n     * @dev Removes a Hat from the whitelist for proposal creation.\n     * @param _hatId The ID of the Hat to remove from the whitelist\n     */\n    function unwhitelistHat(uint256 _hatId) external;\n\n    /**\n     * @dev Checks if an address is wearing any of the whitelisted Hats.\n     * @param _address The address to check for wearing whitelisted Hats.\n     * @return Returns true if the address is wearing any of the whitelisted Hats, false otherwise.\n     */\n    function isWearingWhitelistedHat(\n        address _address\n    ) external view returns (bool);\n\n    /**\n     * @dev Returns the IDs of all whitelisted Hats.\n     * @return An array of whitelisted Hat IDs.\n     */\n    function getWhitelistedHatIds() external view returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/IKeyValuePairs.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\n/**\n * A utility contract to log key / value pair events for the calling address.\n */\ninterface IKeyValuePairs {\n\n    /**\n     * Logs the given key / value pairs, along with the caller's address.\n     *\n     * @param _keys the keys\n     * @param _values the values\n     */\n    function updateValues(string[] memory _keys, string[] memory _values) external;\n}\n"
    },
    "contracts/interfaces/ILightAccount.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\ninterface ILightAccount {\n    function owner() external view returns (address);\n\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ILightAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\ninterface ILightAccountFactory {\n    /// @notice Calculate the counterfactual address of this account as it would be returned by `createAccount`.\n    /// @param owner The owner of the account to be created.\n    /// @param salt A salt, which can be changed to create multiple accounts with the same owner.\n    /// @return The address of the account that would be created with `createAccount`.\n    function getAddress(\n        address owner,\n        uint256 salt\n    ) external view returns (address);\n}\n"
    },
    "contracts/interfaces/ILockableV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\ninterface ILockableV1 {\n    event Locked(bool isLocked);\n    event Whitelisted(address indexed account, bool isWhitelisted);\n\n    error IsLocked();\n    error CannotSwitchLockState(bool newLockState);\n\n    function lock(bool _locked) external;\n\n    function locked() external view returns (bool);\n\n    function whitelist(address account, bool isWhitelisted) external;\n\n    function whitelisted(address account) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMintableV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\ninterface IMintableV1 {\n    function mint(address to, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IMultisigFreezeGuard.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\n/**\n * A specification for a Safe Guard contract which allows for multi-sig DAOs (Safes)\n * to operate in a fashion similar to [Azorius](../azorius/Azorius.md) token voting DAOs.\n *\n * This Guard is intended to add a timelock period and execution period to a Safe\n * multi-sig contract, allowing parent DAOs to have the ability to properly\n * freeze multi-sig subDAOs.\n *\n * Without a timelock period, a vote to freeze the Safe would not be possible\n * as the multi-sig child could immediately execute any transactions they would like\n * in response.\n *\n * An execution period is also required. This is to prevent executing the transaction after\n * a potential freeze period is enacted. Without it a subDAO could just wait for a freeze\n * period to elapse and then execute their desired transaction.\n *\n * See https://docs.safe.global/learn/safe-core/safe-core-protocol/guards.\n */\ninterface IMultisigFreezeGuard {\n\n    /**\n     * Allows the caller to begin the `timelock` of a transaction.\n     *\n     * Timelock is the period during which a proposed transaction must wait before being\n     * executed, after it has passed.  This period is intended to allow the parent DAO\n     * sufficient time to potentially freeze the DAO, if they should vote to do so.\n     *\n     * The parameters for doing so are identical to [ISafe's](./ISafe.md) `execTransaction` function.\n     *\n     * @param _to destination address\n     * @param _value ETH value\n     * @param _data data payload\n     * @param _operation Operation type, Call or DelegateCall\n     * @param _safeTxGas gas that should be used for the safe transaction\n     * @param _baseGas gas costs that are independent of the transaction execution\n     * @param _gasPrice max gas price that should be used for this transaction\n     * @param _gasToken token address (or 0 if ETH) that is used for the payment\n     * @param _refundReceiver address of the receiver of gas payment (or 0 if tx.origin)\n     * @param _signatures packed signature data\n     * @param _nonce nonce to use for the safe transaction\n     */\n    function timelockTransaction(\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        Enum.Operation _operation,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address payable _refundReceiver,\n        bytes memory _signatures,\n        uint256 _nonce\n    ) external;\n\n    /**\n     * Sets the subDAO's timelock period.\n     *\n     * @param _timelockPeriod new timelock period for the subDAO (in blocks)\n     */\n    function updateTimelockPeriod(uint32 _timelockPeriod) external;\n\n    /**\n     * Updates the execution period.\n     *\n     * Execution period is the time period during which a subDAO's passed Proposals must be executed,\n     * otherwise they will be expired.\n     *\n     * This period begins immediately after the timelock period has ended.\n     *\n     * @param _executionPeriod number of blocks a transaction has to be executed within\n     */\n    function updateExecutionPeriod(uint32 _executionPeriod) external;\n\n    /**\n     * Gets the block number that the given transaction was timelocked at.\n     *\n     * @param _signaturesHash hash of the transaction signatures\n     * @return uint32 block number in which the transaction began its timelock period\n     */\n    function getTransactionTimelockedBlock(bytes32 _signaturesHash) external view returns (uint32);\n}\n"
    },
    "contracts/interfaces/ISafe.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\n/**\n * The specification of methods available on a Safe contract wallet.\n * \n * This interface does not encompass every available function on a Safe,\n * only those which are used within the Azorius contracts.\n *\n * For the complete set of functions available on a Safe, see:\n * https://github.com/safe-global/safe-contracts/blob/main/contracts/Safe.sol\n */\ninterface ISafe {\n\n    /**\n     * Returns the current transaction nonce of the Safe.\n     * Each transaction should has a different nonce to prevent replay attacks.\n     *\n     * @return uint256 current transaction nonce\n     */\n    function nonce() external view returns (uint256);\n\n    /**\n     * Set a guard contract that checks transactions before execution.\n     * This can only be done via a Safe transaction.\n     *\n     * See https://docs.gnosis-safe.io/learn/safe-tools/guards.\n     * See https://github.com/safe-global/safe-contracts/blob/main/contracts/base/GuardManager.sol.\n     * \n     * @param _guard address of the guard to be used or the 0 address to disable a guard\n     */\n    function setGuard(address _guard) external;\n\n    /**\n     * Executes an arbitrary transaction on the Safe.\n     *\n     * @param _to destination address\n     * @param _value ETH value\n     * @param _data data payload\n     * @param _operation Operation type, Call or DelegateCall\n     * @param _safeTxGas gas that should be used for the safe transaction\n     * @param _baseGas gas costs that are independent of the transaction execution\n     * @param _gasPrice max gas price that should be used for this transaction\n     * @param _gasToken token address (or 0 if ETH) that is used for the payment\n     * @param _refundReceiver address of the receiver of gas payment (or 0 if tx.origin)\n     * @param _signatures packed signature data\n     * @return success bool whether the transaction was successful or not\n     */\n    function execTransaction(\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        Enum.Operation _operation,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address payable _refundReceiver,\n        bytes memory _signatures\n    ) external payable returns (bool success);\n\n    /**\n     * Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\n     *\n     * @param _dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param _data That should be signed (this is passed to an external validator contract)\n     * @param _signatures Signature data that should be verified. Can be packed ECDSA signature \n     *      ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(bytes32 _dataHash, bytes memory _data, bytes memory _signatures) external view;\n\n    /**\n     * Returns the pre-image of the transaction hash.\n     *\n     * @param _to destination address\n     * @param _value ETH value\n     * @param _data data payload\n     * @param _operation Operation type, Call or DelegateCall\n     * @param _safeTxGas gas that should be used for the safe transaction\n     * @param _baseGas gas costs that are independent of the transaction execution\n     * @param _gasPrice max gas price that should be used for this transaction\n     * @param _gasToken token address (or 0 if ETH) that is used for the payment\n     * @param _refundReceiver address of the receiver of gas payment (or 0 if tx.origin)\n     * @param _nonce transaction nonce\n     * @return bytes hash bytes\n     */\n    function encodeTransactionData(\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        Enum.Operation _operation,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address _refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes memory);\n\n    /**\n     * Returns if the given address is an owner of the Safe.\n     *\n     * See https://github.com/safe-global/safe-contracts/blob/main/contracts/base/OwnerManager.sol.\n     *\n     * @param _owner the address to check\n     * @return bool whether _owner is an owner of the Safe\n     */\n    function isOwner(address _owner) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IVersion.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\ninterface IVersion {\n    function getVersion() external view returns (uint16);\n}\n"
    },
    "contracts/KeyValuePairs.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { IKeyValuePairs } from \"./interfaces/IKeyValuePairs.sol\";\n\n/**\n * Implementation of [IKeyValuePairs](./interfaces/IKeyValuePairs.md), a utility \n * contract to log key / value pair events for the calling address.\n */\ncontract KeyValuePairs is IKeyValuePairs {\n\n    event ValueUpdated(address indexed theAddress, string key, string value);\n\n    error IncorrectValueCount();\n\n    /** @inheritdoc IKeyValuePairs*/\n    function updateValues(string[] memory _keys, string[] memory _values) external {\n\n        uint256 keyCount = _keys.length;\n\n        if (keyCount != _values.length)\n            revert IncorrectValueCount();\n\n        for (uint256 i; i < keyCount; ) {\n            emit ValueUpdated(msg.sender, _keys[i], _values[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/mocks/MockHats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport {IHats} from \"../interfaces/hats/IHats.sol\";\nimport {IHatsIdUtilities} from \"../interfaces/hats/IHatsIdUtilities.sol\";\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) internal _balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        _balanceOf[from][id] -= amount;\n        _balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    from,\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            _balanceOf[from][id] -= amount;\n            _balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOf(\n        address owner,\n        uint256 id\n    ) public view virtual returns (uint256 balance) {\n        balance = _balanceOf[owner][id];\n    }\n\n    function balanceOfBatch(\n        address[] calldata owners,\n        uint256[] calldata ids\n    ) public view virtual returns (uint256[] memory balances) {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = _balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            _balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    address(0),\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            _balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        _balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\n/// @notice see HatsErrors.sol for description\nerror MaxLevelsReached();\nerror InvalidUnlink();\n\n/// @title Hats Id Utilities\n/// @dev Functions for working with Hat Ids from Hats Protocol. Factored out of Hats.sol\n/// for easier use by other contracts.\n/// @author Haberdasher Labs\ncontract MockHatsIdUtilities is IHatsIdUtilities {\n    /// @notice Mapping of tophats requesting to link to admin hats in other trees\n    /// @dev Linkage only occurs if request is approved by the new admin\n    mapping(uint32 => uint256) public linkedTreeRequests; // topHatDomain => requested new admin\n\n    /// @notice Mapping of approved & linked tophats to admin hats in other trees, used for grafting one hats tree onto another\n    /// @dev Trees can only be linked to another tree via their tophat\n    mapping(uint32 => uint256) public linkedTreeAdmins; // topHatDomain => hatId\n\n    /**\n     * Hat Ids serve as addresses. A given Hat's Id represents its location in its\n     * hat tree: its level, its admin, its admin's admin (etc, all the way up to the\n     * tophat).\n     *\n     * The top level consists of 4 bytes and references all tophats.\n     *\n     * Each level below consists of 16 bits, and contains up to 65,536 child hats.\n     *\n     * A uint256 contains 4 bytes of space for tophat addresses, giving room for ((256 -\n     * 32) / 16) = 14 levels of delegation, with the admin at each level having space for\n     * 65,536 different child hats.\n     *\n     * A hat tree consists of a single tophat and has a max depth of 14 levels.\n     */\n\n    /// @dev Number of bits of address space for tophat ids, ie the tophat domain\n    uint256 internal constant TOPHAT_ADDRESS_SPACE = 32;\n\n    /// @dev Number of bits of address space for each level below the tophat\n    uint256 internal constant LOWER_LEVEL_ADDRESS_SPACE = 16;\n\n    /// @dev Maximum number of levels below the tophat, ie max tree depth\n    ///      (256 - TOPHAT_ADDRESS_SPACE) / LOWER_LEVEL_ADDRESS_SPACE;\n    uint256 internal constant MAX_LEVELS = 14;\n\n    /// @notice Constructs a valid hat id for a new hat underneath a given admin\n    /// @dev Reverts if the admin has already reached `MAX_LEVELS`\n    /// @param _admin the id of the admin for the new hat\n    /// @param _newHat the uint16 id of the new hat\n    /// @return id The constructed hat id\n    function buildHatId(\n        uint256 _admin,\n        uint16 _newHat\n    ) public pure returns (uint256 id) {\n        uint256 mask;\n        for (uint256 i = 0; i < MAX_LEVELS; ) {\n            unchecked {\n                mask = uint256(\n                    type(uint256).max >>\n                        // should not overflow given known constants\n                        (TOPHAT_ADDRESS_SPACE + (LOWER_LEVEL_ADDRESS_SPACE * i))\n                );\n            }\n            if (_admin & mask == 0) {\n                unchecked {\n                    id =\n                        _admin |\n                        (uint256(_newHat) <<\n                            // should not overflow given known constants\n                            (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - 1 - i)));\n                }\n                return id;\n            }\n\n            // should not overflow based on < MAX_LEVELS stopping condition\n            unchecked {\n                ++i;\n            }\n        }\n\n        // if _admin is already at MAX_LEVELS, child hats are not possible, so we revert\n        revert MaxLevelsReached();\n    }\n\n    /// @notice Identifies the level a given hat in its hat tree\n    /// @param _hatId the id of the hat in question\n    /// @return level (0 to type(uint32).max)\n    function getHatLevel(uint256 _hatId) public view returns (uint32 level) {\n        // uint256 mask;\n        // uint256 i;\n        level = getLocalHatLevel(_hatId);\n\n        uint256 treeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n\n        if (treeAdmin != 0) {\n            level = 1 + level + getHatLevel(treeAdmin);\n        }\n    }\n\n    /// @notice Identifies the level a given hat in its local hat tree\n    /// @dev Similar to getHatLevel, but does not account for linked trees\n    /// @param _hatId the id of the hat in question\n    /// @return level The local level, from 0 to 14\n    function getLocalHatLevel(\n        uint256 _hatId\n    ) public pure returns (uint32 level) {\n        if (_hatId & uint256(type(uint224).max) == 0) return 0;\n        if (_hatId & uint256(type(uint208).max) == 0) return 1;\n        if (_hatId & uint256(type(uint192).max) == 0) return 2;\n        if (_hatId & uint256(type(uint176).max) == 0) return 3;\n        if (_hatId & uint256(type(uint160).max) == 0) return 4;\n        if (_hatId & uint256(type(uint144).max) == 0) return 5;\n        if (_hatId & uint256(type(uint128).max) == 0) return 6;\n        if (_hatId & uint256(type(uint112).max) == 0) return 7;\n        if (_hatId & uint256(type(uint96).max) == 0) return 8;\n        if (_hatId & uint256(type(uint80).max) == 0) return 9;\n        if (_hatId & uint256(type(uint64).max) == 0) return 10;\n        if (_hatId & uint256(type(uint48).max) == 0) return 11;\n        if (_hatId & uint256(type(uint32).max) == 0) return 12;\n        if (_hatId & uint256(type(uint16).max) == 0) return 13;\n        return 14;\n    }\n\n    /// @notice Checks whether a hat is a topHat\n    /// @param _hatId The hat in question\n    /// @return _isTopHat Whether the hat is a topHat\n    function isTopHat(uint256 _hatId) public view returns (bool _isTopHat) {\n        _isTopHat =\n            isLocalTopHat(_hatId) &&\n            linkedTreeAdmins[getTopHatDomain(_hatId)] == 0;\n    }\n\n    /// @notice Checks whether a hat is a topHat in its local hat tree\n    /// @dev Similar to isTopHat, but does not account for linked trees\n    /// @param _hatId The hat in question\n    /// @return _isLocalTopHat Whether the hat is a topHat for its local tree\n    function isLocalTopHat(\n        uint256 _hatId\n    ) public pure returns (bool _isLocalTopHat) {\n        _isLocalTopHat = _hatId > 0 && uint224(_hatId) == 0;\n    }\n\n    function isValidHatId(\n        uint256 _hatId\n    ) public pure returns (bool validHatId) {\n        // valid top hats are valid hats\n        if (isLocalTopHat(_hatId)) return true;\n\n        uint32 level = getLocalHatLevel(_hatId);\n        uint256 admin;\n        // for each subsequent level up the tree, check if the level is 0 and return false if so\n        for (uint256 i = level - 1; i > 0; ) {\n            // truncate to find the (truncated) admin at this level\n            // we don't need to check _hatId's own level since getLocalHatLevel already ensures that its non-empty\n            admin = _hatId >> (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - i));\n            // if the lowest level of the truncated admin is empty, the hat id is invalid\n            if (uint16(admin) == 0) return false;\n\n            unchecked {\n                --i;\n            }\n        }\n        // if there are no empty levels, return true\n        return true;\n    }\n\n    /// @notice Gets the hat id of the admin at a given level of a given hat\n    /// @dev This function traverses trees by following the linkedTreeAdmin\n    ///       pointer to a hat located in a different tree\n    /// @param _hatId the id of the hat in question\n    /// @param _level the admin level of interest\n    /// @return admin The hat id of the resulting admin\n    function getAdminAtLevel(\n        uint256 _hatId,\n        uint32 _level\n    ) public view returns (uint256 admin) {\n        uint256 linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n        if (linkedTreeAdmin == 0)\n            return admin = getAdminAtLocalLevel(_hatId, _level);\n\n        uint32 localTopHatLevel = getHatLevel(getAdminAtLocalLevel(_hatId, 0));\n\n        if (localTopHatLevel <= _level)\n            return\n                admin = getAdminAtLocalLevel(_hatId, _level - localTopHatLevel);\n\n        return admin = getAdminAtLevel(linkedTreeAdmin, _level);\n    }\n\n    /// @notice Gets the hat id of the admin at a given level of a given hat\n    ///         local to the tree containing the hat.\n    /// @param _hatId the id of the hat in question\n    /// @param _level the admin level of interest\n    /// @return admin The hat id of the resulting admin\n    function getAdminAtLocalLevel(\n        uint256 _hatId,\n        uint32 _level\n    ) public pure returns (uint256 admin) {\n        uint256 mask = type(uint256).max <<\n            (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - _level));\n\n        admin = _hatId & mask;\n    }\n\n    /// @notice Gets the tophat domain of a given hat\n    /// @dev A domain is the identifier for a given hat tree, stored in the first 4 bytes of a hat's id\n    /// @param _hatId the id of the hat in question\n    /// @return domain The domain of the hat's tophat\n    function getTopHatDomain(\n        uint256 _hatId\n    ) public pure returns (uint32 domain) {\n        domain = uint32(_hatId >> (LOWER_LEVEL_ADDRESS_SPACE * MAX_LEVELS));\n    }\n\n    /// @notice Gets the domain of the highest parent tophat  the \"tippy tophat\"\n    /// @param _topHatDomain the 32 bit domain of a (likely linked) tophat\n    /// @return domain The tippy tophat domain\n    function getTippyTopHatDomain(\n        uint32 _topHatDomain\n    ) public view returns (uint32 domain) {\n        uint256 linkedAdmin = linkedTreeAdmins[_topHatDomain];\n        if (linkedAdmin == 0) return domain = _topHatDomain;\n        return domain = getTippyTopHatDomain(getTopHatDomain(linkedAdmin));\n    }\n\n    /// @notice Checks For any circular linkage of trees\n    /// @param _topHatDomain the 32 bit domain of the tree to be linked\n    /// @param _linkedAdmin the hatId of the potential tree admin\n    /// @return notCircular circular link has not been found\n    function noCircularLinkage(\n        uint32 _topHatDomain,\n        uint256 _linkedAdmin\n    ) public view returns (bool notCircular) {\n        if (_linkedAdmin == 0) return true;\n        uint32 adminDomain = getTopHatDomain(_linkedAdmin);\n        if (_topHatDomain == adminDomain) return false;\n        uint256 parentAdmin = linkedTreeAdmins[adminDomain];\n        return noCircularLinkage(_topHatDomain, parentAdmin);\n    }\n\n    /// @notice Checks that a tophat domain and its potential linked admin are from the same tree, ie have the same tippy tophat domain\n    /// @param _topHatDomain The 32 bit domain of the tophat to be linked\n    /// @param _newAdminHat The new admin for the linked tree\n    /// @return sameDomain Whether the _topHatDomain and the domain of its potential linked _newAdminHat domains are the same\n    function sameTippyTopHatDomain(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat\n    ) public view returns (bool sameDomain) {\n        // get highest parent domains for current and new tree root admins\n        uint32 currentTippyTophatDomain = getTippyTopHatDomain(_topHatDomain);\n        uint32 newAdminDomain = getTopHatDomain(_newAdminHat);\n        uint32 newHTippyTophatDomain = getTippyTopHatDomain(newAdminDomain);\n\n        // check that both domains are equal\n        sameDomain = (currentTippyTophatDomain == newHTippyTophatDomain);\n    }\n}\n\ncontract MockHats is IHats, ERC1155, MockHatsIdUtilities {\n    /// @notice This contract's version is labeled v1. Previous versions labeled similarly as v1 and v1.0 are deprecated,\n    ///         and should be treated as beta deployments.\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS DATA MODELS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice A Hat object containing the hat's properties\n    /// @dev The members are packed to minimize storage costs\n    /// @custom:member eligibility Module that rules on wearer eligibiliy and standing\n    /// @custom:member maxSupply The max number of hats with this id that can exist\n    /// @custom:member supply The number of this hat that currently exist\n    /// @custom:member lastHatId Indexes how many different child hats an admin has\n    /// @custom:member toggle Module that sets the hat's status\n    /**\n     * @custom:member config Holds status and other settings, with this bitwise schema:\n     *\n     *  0th bit  | `active` status; can be altered by toggle\n     *  1        | `mutable` setting\n     *  2 - 95   | unassigned\n     */\n    /// @custom:member details Holds arbitrary metadata about the hat\n    /// @custom:member imageURI A uri pointing to an image for the hat\n    struct Hat {\n        // 1st storage slot\n        address eligibility; //  20\n        uint32 maxSupply; //      4\n        uint32 supply; //         4\n        uint16 lastHatId; //     2\n        // 2nd slot\n        address toggle; //       20\n        uint96 config; //        12\n        // 3rd+ slot (optional)\n        string details;\n        string imageURI;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The name of the contract, typically including the version\n    string public name;\n\n    /// @notice The first 4 bytes of the id of the last tophat created.\n    uint32 public lastTopHatId; // first tophat id starts at 1\n\n    /// @notice The fallback image URI for hat tokens with no `imageURI` specified in their branch\n    string public baseImageURI;\n\n    /// @dev Internal mapping of hats to hat ids. See HatsIdUtilities.sol for more info on how hat ids work\n    mapping(uint256 => Hat) internal _hats; // key: hatId => value: Hat struct\n\n    /// @notice Mapping of wearers in bad standing for certain hats\n    /// @dev Used by external contracts to trigger penalties for wearers in bad standing\n    ///      hatId => wearer => !standing\n    mapping(uint256 => mapping(address => bool)) public badStandings;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice All arguments are immutable; they can only be set once during construction\n    constructor() {\n        name = \"MockHats\";\n        baseImageURI = \"\";\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates and mints a Hat that is its own admin, i.e. a \"topHat\"\n    /// @dev A topHat has no eligibility and no toggle\n    /// @param _target The address to which the newly created topHat is minted\n    /// @param _details A description of the Hat [optional]. Should not be larger than 7000 bytes\n    ///                 (enforced in changeHatDetails)\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]. Should not be large than 7000 bytes\n    ///                  (enforced in changeHatImageURI)\n    /// @return topHatId The id of the newly created topHat\n    function mintTopHat(\n        address _target,\n        string calldata _details,\n        string calldata _imageURI\n    ) public returns (uint256 topHatId) {\n        // create hat\n\n        topHatId = uint256(++lastTopHatId) << 224;\n\n        _createHat(\n            topHatId,\n            _details, // details\n            1, // maxSupply = 1\n            address(0), // there is no eligibility\n            address(0), // it has no toggle\n            false, // its immutable\n            _imageURI\n        );\n\n        _mintHat(_target, topHatId);\n    }\n\n    /// @notice Creates a new hat. The msg.sender must wear the `_admin` hat.\n    /// @dev Initializes a new Hat struct, but does not mint any tokens.\n    /// @param _details A description of the Hat. Should not be larger than 7000 bytes (enforced in changeHatDetails)\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _admin The id of the Hat that will control who wears the newly created hat\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the Hat\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this hat and the fallback for its\n    ///                  downstream hats [optional]. Should not be larger than 7000 bytes (enforced in changeHatImageURI)\n    /// @return newHatId The id of the newly created Hat\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) public returns (uint256 newHatId) {\n        if (uint16(_admin) > 0) {\n            revert MaxLevelsReached();\n        }\n\n        if (_eligibility == address(0)) revert ZeroAddress();\n        if (_toggle == address(0)) revert ZeroAddress();\n        // check that the admin id is valid, ie does not contain empty levels between filled levels\n        if (!isValidHatId(_admin)) revert InvalidHatId();\n        // construct the next hat id\n        newHatId = getNextId(_admin);\n        // to create a hat, you must be wearing one of its admin hats\n        _checkAdmin(newHatId);\n        // create the new hat\n        _createHat(\n            newHatId,\n            _details,\n            _maxSupply,\n            _eligibility,\n            _toggle,\n            _mutable,\n            _imageURI\n        );\n        // increment _admin.lastHatId\n        // use the overflow check to constrain to correct number of hats per level\n        ++_hats[_admin].lastHatId;\n    }\n\n    /// @notice Creates new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `createHat`.\n    /// @param _admins Array of ids of admins for each hat to create\n    /// @param _details Array of details for each hat to create\n    /// @param _maxSupplies Array of supply caps for each hat to create\n    /// @param _eligibilityModules Array of eligibility module addresses for each hat to\n    /// create\n    /// @param _toggleModules Array of toggle module addresses for each hat to create\n    /// @param _mutables Array of mutable flags for each hat to create\n    /// @param _imageURIs Array of imageURIs for each hat to create\n    /// @return success True if all createHat calls succeeded\n    function batchCreateHats(\n        uint256[] calldata _admins,\n        string[] calldata _details,\n        uint32[] calldata _maxSupplies,\n        address[] memory _eligibilityModules,\n        address[] memory _toggleModules,\n        bool[] calldata _mutables,\n        string[] calldata _imageURIs\n    ) public returns (bool success) {\n        // check if array lengths are the same\n        uint256 length = _admins.length; // save an MLOAD\n\n        {\n            bool sameLengths = (length == _details.length && // details\n                length == _maxSupplies.length && // supplies\n                length == _eligibilityModules.length && // eligibility\n                length == _toggleModules.length && // toggle\n                length == _mutables.length && // mutable\n                length == _imageURIs.length); // imageURI\n            if (!sameLengths) revert BatchArrayLengthMismatch();\n        }\n\n        // loop through and create each hat\n        for (uint256 i = 0; i < length; ) {\n            createHat(\n                _admins[i],\n                _details[i],\n                _maxSupplies[i],\n                _eligibilityModules[i],\n                _toggleModules[i],\n                _mutables[i],\n                _imageURIs[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Gets the id of the next child hat of the hat `_admin`\n    /// @dev Does not incrememnt lastHatId\n    /// @param _admin The id of the hat to serve as the admin for the next child hat\n    /// @return nextId The new hat id\n    function getNextId(uint256 _admin) public view returns (uint256 nextId) {\n        uint16 nextHatId = _hats[_admin].lastHatId + 1;\n        nextId = buildHatId(_admin, nextHatId);\n    }\n\n    /// @notice Gets the id of the next child hat of the hat `_admin` with an offset\n    /// @dev Does not incrememnt lastHatId\n    /// @dev This is for testing purposes\n    /// @param _admin The id of the hat to serve as the admin for the next child hat\n    /// @param _offset The offset to apply to the lastHatId\n    /// @return nextId The new hat id\n    function getNextIdOffset(\n        uint256 _admin,\n        uint8 _offset\n    ) public view returns (uint256 nextId) {\n        uint16 nextHatId = _hats[_admin].lastHatId + 1 + _offset;\n        nextId = buildHatId(_admin, nextHatId);\n    }\n\n    /// @notice Mints an ERC1155-similar token of the Hat to an eligible recipient, who then \"wears\" the hat\n    /// @dev The msg.sender must wear an admin Hat of `_hatId`, and the recipient must be eligible to wear `_hatId`\n    /// @param _hatId The id of the Hat to mint\n    /// @param _wearer The address to which the Hat is minted\n    /// @return success Whether the mint succeeded\n    function mintHat(\n        uint256 _hatId,\n        address _wearer\n    ) public returns (bool success) {\n        Hat storage hat = _hats[_hatId];\n        if (hat.maxSupply == 0) revert HatDoesNotExist(_hatId);\n        // only eligible wearers can receive minted hats\n        if (!isEligible(_wearer, _hatId)) revert NotEligible();\n        // only active hats can be minted\n        if (!_isActive(hat, _hatId)) revert HatNotActive();\n        // only the wearer of one of a hat's admins can mint it\n        _checkAdmin(_hatId);\n        // hat supply cannot exceed maxSupply\n        if (hat.supply >= hat.maxSupply) revert AllHatsWorn(_hatId);\n        // wearers cannot wear the same hat more than once\n        if (_staticBalanceOf(_wearer, _hatId) > 0)\n            revert AlreadyWearingHat(_wearer, _hatId);\n        // if we've made it through all the checks, mint the hat\n        _mintHat(_wearer, _hatId);\n\n        success = true;\n    }\n\n    /// @notice Mints new hats in batch. The msg.sender must be an admin of each hat.\n    /// @dev This is a convenience function that loops through the arrays and calls `mintHat`.\n    /// @param _hatIds Array of ids of hats to mint\n    /// @param _wearers Array of addresses to which the hats will be minted\n    /// @return success True if all mintHat calls succeeded\n    function batchMintHats(\n        uint256[] calldata _hatIds,\n        address[] calldata _wearers\n    ) public returns (bool success) {\n        uint256 length = _hatIds.length;\n        if (length != _wearers.length) revert BatchArrayLengthMismatch();\n\n        for (uint256 i = 0; i < length; ) {\n            mintHat(_hatIds[i], _wearers[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        success = true;\n    }\n\n    /// @notice Toggles a Hat's status from active to deactive, or vice versa\n    /// @dev The msg.sender must be set as the hat's toggle\n    /// @param _hatId The id of the Hat for which to adjust status\n    /// @param _newStatus The new status to set\n    /// @return toggled Whether the status was toggled\n    function setHatStatus(\n        uint256 _hatId,\n        bool _newStatus\n    ) external returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.toggle) {\n            revert NotHatsToggle();\n        }\n\n        toggled = _processHatStatus(_hatId, _newStatus);\n    }\n\n    /// @notice Checks a hat's toggle module and processes the returned status\n    /// @dev May change the hat's status in storage\n    /// @param _hatId The id of the Hat whose toggle we are checking\n    /// @return toggled Whether there was a new status\n    function checkHatStatus(uint256 _hatId) public returns (bool toggled) {\n        Hat storage hat = _hats[_hatId];\n\n        // attempt to retrieve the hat's status from the toggle module\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\n\n        // if unsuccessful (ie toggle was humanistic), process the new status\n        if (!success) revert NotHatsToggle();\n\n        // if successful (ie toggle was mechanistic), process the new status\n        toggled = _processHatStatus(_hatId, newStatus);\n    }\n\n    function _pullHatStatus(\n        Hat storage _hat,\n        uint256 _hatId\n    ) internal view returns (bool success, bool newStatus) {\n        bytes memory data = abi.encodeWithSignature(\n            \"getHatStatus(uint256)\",\n            _hatId\n        );\n        bytes memory returndata;\n        (success, returndata) = _hat.toggle.staticcall(data);\n\n        /*\n         * if function call succeeds with data of length == 32, then we know the contract exists\n         * and has the getHatStatus function.\n         * But  since function selectors don't include return types  we still can't assume that the return data is a boolean,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 32) {\n            // check the returndata manually\n            uint256 uintReturndata = abi.decode(returndata, (uint256));\n            // false condition\n            if (uintReturndata == 0) {\n                newStatus = false;\n                // true condition\n            } else if (uintReturndata == 1) {\n                newStatus = true;\n            }\n            // invalid condition\n            else {\n                success = false;\n            }\n        } else {\n            success = false;\n        }\n    }\n\n    /// @notice Report from a hat's eligibility on the status of one of its wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the hat wearer whose status is being reported\n    /// @param _eligible Whether the wearer is eligible for the hat (will be revoked if\n    /// false)\n    /// @param _standing False if the wearer is no longer in good standing (and potentially should be penalized)\n    /// @return updated Whether the report succeeded\n    function setHatWearerStatus(\n        uint256 _hatId,\n        address _wearer,\n        bool _eligible,\n        bool _standing\n    ) external returns (bool updated) {\n        Hat storage hat = _hats[_hatId];\n\n        if (msg.sender != hat.eligibility) {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(\n            _hatId,\n            _wearer,\n            _eligible,\n            _standing\n        );\n    }\n\n    /// @notice Check a hat's eligibility for a report on the status of one of the hat's wearers and, if `false`, revoke their hat\n    /// @dev Burns the wearer's hat, if revoked\n    /// @param _hatId The id of the hat\n    /// @param _wearer The address of the Hat wearer whose status report is being requested\n    /// @return updated Whether the wearer's status was altered\n    function checkHatWearerStatus(\n        uint256 _hatId,\n        address _wearer\n    ) public returns (bool updated) {\n        bool eligible;\n        bool standing;\n\n        (bool success, bytes memory returndata) = _hats[_hatId]\n            .eligibility\n            .staticcall(\n                abi.encodeWithSignature(\n                    \"getWearerStatus(address,uint256)\",\n                    _wearer,\n                    _hatId\n                )\n            );\n\n        /*\n         * if function call succeeds with data of length == 64, then we know the contract exists\n         * and has the getWearerStatus function (which returns two words).\n         * But  since function selectors don't include return types  we still can't assume that the return data is two booleans,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 64) {\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(\n                returndata,\n                (uint256, uint256)\n            );\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // never eligible if in bad standing\n                eligible = (standing && firstWord == 1) ? true : false;\n            }\n            // returndata is invalid\n            else {\n                revert NotHatsEligibility();\n            }\n        } else {\n            revert NotHatsEligibility();\n        }\n\n        updated = _processHatWearerStatus(_hatId, _wearer, eligible, standing);\n    }\n\n    /// @notice Stop wearing a hat, aka \"renounce\" it\n    /// @dev Burns the msg.sender's hat\n    /// @param _hatId The id of the Hat being renounced\n    function renounceHat(uint256 _hatId) external {\n        if (_staticBalanceOf(msg.sender, _hatId) < 1) {\n            revert NotHatWearer();\n        }\n        // remove the hat\n        _burnHat(msg.sender, _hatId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS INTERNAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal call for creating a new hat\n    /// @dev Initializes a new Hat in storage, but does not mint any tokens\n    /// @param _id ID of the hat to be stored\n    /// @param _details A description of the hat\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\n    /// @param _eligibility The address that can report on the Hat wearer's status\n    /// @param _toggle The address that can deactivate the hat [optional]\n    /// @param _mutable Whether the hat's properties are changeable after creation\n    /// @param _imageURI The image uri for this top hat and the fallback for its\n    ///                  downstream hats [optional]\n    function _createHat(\n        uint256 _id,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) internal {\n        /* \n          We write directly to storage instead of first building the Hat struct in memory.\n          This allows us to cheaply use the existing lastHatId value in case it was incremented by creating a hat while skipping admin levels.\n          (Resetting it to 0 would be bad since this hat's child hat(s) would overwrite the previously created hat(s) at that level.)\n        */\n        Hat storage hat = _hats[_id];\n        hat.details = _details;\n        hat.maxSupply = _maxSupply;\n        hat.eligibility = _eligibility;\n        hat.toggle = _toggle;\n        hat.imageURI = _imageURI;\n        // config is a concatenation of the status and mutability properties\n        hat.config = _mutable ? uint96(3 << 94) : uint96(1 << 95);\n\n        emit HatCreated(\n            _id,\n            _details,\n            _maxSupply,\n            _eligibility,\n            _toggle,\n            _mutable,\n            _imageURI\n        );\n    }\n\n    /// @notice Internal function to process hat status\n    /// @dev Updates a hat's status if different from current\n    /// @param _hatId The id of the Hat in quest\n    /// @param _newStatus The status to potentially change to\n    /// @return updated - Whether the status was updated\n    function _processHatStatus(\n        uint256 _hatId,\n        bool _newStatus\n    ) internal returns (bool updated) {\n        // optimize later\n        Hat storage hat = _hats[_hatId];\n\n        if (_newStatus != _getHatStatus(hat)) {\n            _setHatStatus(hat, _newStatus);\n            emit HatStatusChanged(_hatId, _newStatus);\n            updated = true;\n        }\n    }\n\n    /// @notice Internal call to process wearer status from the eligibility module\n    /// @dev Burns the wearer's Hat token if _eligible is false, and updates badStandings\n    /// state if necessary\n    /// @param _hatId The id of the Hat to revoke\n    /// @param _wearer The address of the wearer in question\n    /// @param _eligible Whether _wearer is eligible for the Hat (if false, this function\n    /// will revoke their Hat)\n    /// @param _standing Whether _wearer is in good standing (to be recorded in storage)\n    /// @return updated Whether the wearer standing was updated\n    function _processHatWearerStatus(\n        uint256 _hatId,\n        address _wearer,\n        bool _eligible,\n        bool _standing\n    ) internal returns (bool updated) {\n        // revoke/burn the hat if _wearer has a positive balance\n        if (_staticBalanceOf(_wearer, _hatId) > 0) {\n            // always ineligible if in bad standing\n            if (!_eligible || !_standing) {\n                _burnHat(_wearer, _hatId);\n            }\n        }\n\n        // record standing for use by other contracts\n        // note: here, standing and badStandings are opposite\n        // i.e. if standing (true = good standing)\n        // then badStandings[_hatId][wearer] will be false\n        // if they are different, then something has changed, and we need to update\n        // badStandings marker\n        if (_standing == badStandings[_hatId][_wearer]) {\n            badStandings[_hatId][_wearer] = !_standing;\n            updated = true;\n\n            emit WearerStandingChanged(_hatId, _wearer, _standing);\n        }\n    }\n\n    /// @notice Internal function to set a hat's status in storage\n    /// @dev Flips the 0th bit of _hat.config via bitwise operation\n    /// @param _hat The hat object\n    /// @param _status The status to set for the hat\n    function _setHatStatus(Hat storage _hat, bool _status) internal {\n        if (_status) {\n            _hat.config |= uint96(1 << 95);\n        } else {\n            _hat.config &= ~uint96(1 << 95);\n        }\n    }\n\n    /**\n     * @notice Internal function to retrieve an account's internal \"static\" balance directly from internal storage,\n     * @dev This function bypasses the dynamic `_isActive` and `_isEligible` checks\n     * @param _account The account to check\n     * @param _hatId The hat to check\n     * @return staticBalance The account's static of the hat, from internal storage\n     */\n    function _staticBalanceOf(\n        address _account,\n        uint256 _hatId\n    ) internal view returns (uint256 staticBalance) {\n        staticBalance = _balanceOf[_account][_hatId];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks whether msg.sender is an admin of a hat, and reverts if not\n    function _checkAdmin(uint256 _hatId) internal view {\n        if (!isAdminOfHat(msg.sender, _hatId)) {\n            revert NotAdmin(msg.sender, _hatId);\n        }\n    }\n\n    /// @notice checks whether the msg.sender is either an admin or wearer or a hat, and reverts the appropriate error if not\n    function _checkAdminOrWearer(uint256 _hatId) internal view {\n        if (\n            !isAdminOfHat(msg.sender, _hatId) &&\n            !isWearerOfHat(msg.sender, _hatId)\n        ) {\n            revert NotAdminOrWearer();\n        }\n    }\n\n    /// @notice Transfers a hat from one wearer to another eligible wearer\n    /// @dev The hat must be mutable, and the transfer must be initiated by an admin\n    /// @param _hatId The hat in question\n    /// @param _from The current wearer\n    /// @param _to The new wearer\n    function transferHat(uint256 _hatId, address _from, address _to) public {\n        _checkAdmin(_hatId);\n        // cannot transfer immutable hats, except for tophats, which can always transfer themselves\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(_hats[_hatId])) revert Immutable();\n        }\n        // Checks storage instead of `isWearerOfHat` since admins may want to transfer revoked Hats to new wearers\n        if (_staticBalanceOf(_from, _hatId) < 1) revert NotHatWearer();\n        // Check if recipient is already wearing hat; also checks storage to maintain balance == 1 invariant\n        if (_staticBalanceOf(_to, _hatId) > 0)\n            revert AlreadyWearingHat(_to, _hatId);\n        // only eligible wearers can receive transferred hats\n        if (!isEligible(_to, _hatId)) revert NotEligible();\n        // only active hats can be transferred\n        if (!_isActive(_hats[_hatId], _hatId)) revert HatNotActive();\n        // we've made it passed all the checks, so adjust balances to execute the transfer\n        _balanceOf[_from][_hatId] = 0;\n        _balanceOf[_to][_hatId] = 1;\n        // emit the ERC1155 standard transfer event\n        emit TransferSingle(msg.sender, _from, _to, _hatId, 1);\n    }\n\n    /// @notice Set a mutable hat to immutable\n    /// @dev Sets the second bit of hat.config to 0\n    /// @param _hatId The id of the Hat to make immutable\n    function makeHatImmutable(uint256 _hatId) external {\n        _checkAdmin(_hatId);\n\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.config &= ~uint96(1 << 94);\n\n        emit HatMutabilityChanged(_hatId);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats.\n    /// @param _hatId The id of the Hat to change\n    /// @param _newDetails The new details. Must not be larger than 7000 bytes.\n    function changeHatDetails(\n        uint256 _hatId,\n        string calldata _newDetails\n    ) external {\n        if (bytes(_newDetails).length > 7000) revert StringTooLong();\n\n        _checkAdmin(_hatId);\n\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own details, but otherwise only mutable hat details can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.details = _newDetails;\n\n        emit HatDetailsChanged(_hatId, _newDetails);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newEligibility The new eligibility module\n    function changeHatEligibility(\n        uint256 _hatId,\n        address _newEligibility\n    ) external {\n        if (_newEligibility == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        hat.eligibility = _newEligibility;\n\n        emit HatEligibilityChanged(_hatId, _newEligibility);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable\n    /// @param _hatId The id of the Hat to change\n    /// @param _newToggle The new toggle module\n    function changeHatToggle(uint256 _hatId, address _newToggle) external {\n        if (_newToggle == address(0)) revert ZeroAddress();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        // record hat status from old toggle before changing; ensures smooth transition to new toggle,\n        // especially in case of switching from mechanistic to humanistic toggle\n        // a) attempt to retrieve hat status from old toggle\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\n        // b) if succeeded, (ie if old toggle was mechanistic), store the retrieved status\n        if (success) _processHatStatus(_hatId, newStatus);\n\n        // set the new toggle\n        hat.toggle = _newToggle;\n\n        emit HatToggleChanged(_hatId, _newToggle);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable, except for tophats\n    /// @param _hatId The id of the Hat to change\n    /// @param _newImageURI The new imageURI. Must not be larger than 7000 bytes.\n    function changeHatImageURI(\n        uint256 _hatId,\n        string calldata _newImageURI\n    ) external {\n        if (bytes(_newImageURI).length > 7000) revert StringTooLong();\n\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        // a tophat can change its own imageURI, but otherwise only mutable hat imageURIs can be changed\n        if (!isTopHat(_hatId)) {\n            if (!_isMutable(hat)) revert Immutable();\n        }\n\n        hat.imageURI = _newImageURI;\n\n        emit HatImageURIChanged(_hatId, _newImageURI);\n    }\n\n    /// @notice Change a hat's details\n    /// @dev Hat must be mutable; new max supply cannot be less than current supply\n    /// @param _hatId The id of the Hat to change\n    /// @param _newMaxSupply The new max supply\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external {\n        _checkAdmin(_hatId);\n        Hat storage hat = _hats[_hatId];\n\n        if (!_isMutable(hat)) {\n            revert Immutable();\n        }\n\n        if (_newMaxSupply < hat.supply) {\n            revert NewMaxSupplyTooLow();\n        }\n\n        if (_newMaxSupply != hat.maxSupply) {\n            hat.maxSupply = _newMaxSupply;\n            emit HatMaxSupplyChanged(_hatId, _newMaxSupply);\n        }\n    }\n\n    /// @notice Submits a request to link a Hat Tree under a parent tree. Requests can be\n    /// submitted by either...\n    ///     a) the wearer of a topHat, previous to any linkage, or\n    ///     b) the admin(s) of an already-linked topHat (aka tree root), where such a\n    ///        request is to move the tree root to another admin within the same parent\n    ///        tree\n    /// @dev A topHat can have at most 1 request at a time. Submitting a new request will\n    ///      replace the existing request.\n    /// @param _topHatDomain The domain of the topHat to link\n    /// @param _requestedAdminHat The hat that will administer the linked tree\n    function requestLinkTopHatToTree(\n        uint32 _topHatDomain,\n        uint256 _requestedAdminHat\n    ) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n\n        // The wearer of an unlinked tophat is also the admin of same; once a tophat is linked, its wearer is no longer its admin\n        _checkAdmin(fullTopHatId);\n\n        linkedTreeRequests[_topHatDomain] = _requestedAdminHat;\n        emit TopHatLinkRequested(_topHatDomain, _requestedAdminHat);\n    }\n\n    /// @notice Approve a request to link a Tree under a parent tree, with options to add eligibility or toggle modules and change its metadata\n    /// @dev Requests can only be approved by wearer or an admin of the `_newAdminHat`, and there\n    ///      can only be one link per tree root at a given time.\n    /// @param _topHatDomain The 32 bit domain of the topHat to link\n    /// @param _newAdminHat The hat that will administer the linked tree\n    /// @param _eligibility Optional new eligibility module for the linked topHat\n    /// @param _toggle Optional new toggle module for the linked topHat\n    /// @param _details Optional new details for the linked topHat\n    /// @param _imageURI Optional new imageURI for the linked topHat\n    function approveLinkTopHatToTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external {\n        // for everything but the last hat level, check the admin of `_newAdminHat`'s theoretical child hat, since either wearer or admin of `_newAdminHat` can approve\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n            _checkAdmin(buildHatId(_newAdminHat, 1));\n        } else {\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\n            _checkAdminOrWearer(_newAdminHat);\n        }\n\n        // Linkages must be initiated by a request\n        if (_newAdminHat != linkedTreeRequests[_topHatDomain])\n            revert LinkageNotRequested();\n\n        // remove the request -- ensures all linkages are initialized by unique requests,\n        // except for relinks (see `relinkTopHatWithinTree`)\n        delete linkedTreeRequests[_topHatDomain];\n\n        // execute the link. Replaces existing link, if any.\n        _linkTopHatToTree(\n            _topHatDomain,\n            _newAdminHat,\n            _eligibility,\n            _toggle,\n            _details,\n            _imageURI\n        );\n    }\n\n    /**\n     * @notice Unlink a Tree from the parent tree\n     * @dev This can only be called by an admin of the tree root. Fails if the topHat to unlink has no non-zero wearer, which can occur if...\n     *     - It's wearer is in badStanding\n     *     - It has been revoked from its wearer (and possibly burned)\n     *     - It is not active (ie toggled off)\n     * @param _topHatDomain The 32 bit domain of the topHat to unlink\n     * @param _wearer The current wearer of the topHat to unlink\n     */\n    function unlinkTopHatFromTree(\n        uint32 _topHatDomain,\n        address _wearer\n    ) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n        _checkAdmin(fullTopHatId);\n\n        // prevent unlinking if the topHat has no non-zero wearer\n        // since we cannot search the entire address space for a wearer, we require the caller to provide the wearer\n        if (_wearer == address(0) || !isWearerOfHat(_wearer, fullTopHatId))\n            revert InvalidUnlink();\n\n        // execute the unlink\n        delete linkedTreeAdmins[_topHatDomain];\n        // remove the request  ensures all linkages are initialized by unique requests\n        delete linkedTreeRequests[_topHatDomain];\n\n        // reset eligibility and storage to defaults for unlinked top hats\n        Hat storage hat = _hats[fullTopHatId];\n        delete hat.eligibility;\n        delete hat.toggle;\n\n        emit TopHatLinked(_topHatDomain, 0);\n    }\n\n    /// @notice Move a tree root to a different position within the same parent tree,\n    ///         without a request. Valid destinations include within the same local tree as the origin,\n    ///         or to the local tree of the tippyTopHat. TippyTopHat wearers can bypass this restriction\n    ///         to relink to anywhere in its full tree.\n    /// @dev Caller must be both an admin tree root and admin or wearer of `_newAdminHat`.\n    /// @param _topHatDomain The 32 bit domain of the topHat to relink\n    /// @param _newAdminHat The new admin for the linked tree\n    /// @param _eligibility Optional new eligibility module for the linked topHat\n    /// @param _toggle Optional new toggle module for the linked topHat\n    /// @param _details Optional new details for the linked topHat\n    /// @param _imageURI Optional new imageURI for the linked topHat\n    function relinkTopHatWithinTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) external {\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n\n        // msg.sender being capable of both requesting and approving allows us to skip the request step\n        _checkAdmin(fullTopHatId); // \"requester\" must be admin\n\n        // \"approver\" can be wearer or admin\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\n            _checkAdmin(buildHatId(_newAdminHat, 1));\n        } else {\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\n            _checkAdminOrWearer(_newAdminHat);\n        }\n\n        // execute the new link, replacing the old link\n        _linkTopHatToTree(\n            _topHatDomain,\n            _newAdminHat,\n            _eligibility,\n            _toggle,\n            _details,\n            _imageURI\n        );\n    }\n\n    /// @notice Internal function to link a Tree under a parent Tree, with protection against circular linkages and relinking to a separate Tree,\n    ///         with options to add eligibility or toggle modules and change its metadata\n    /// @dev Linking `_topHatDomain` replaces any existing links\n    /// @param _topHatDomain The 32 bit domain of the topHat to link\n    /// @param _newAdminHat The new admin for the linked tree\n    /// @param _eligibility Optional new eligibility module for the linked topHat\n    /// @param _toggle Optional new toggle module for the linked topHat\n    /// @param _details Optional new details for the linked topHat\n    /// @param _imageURI Optional new imageURI for the linked topHat\n    function _linkTopHatToTree(\n        uint32 _topHatDomain,\n        uint256 _newAdminHat,\n        address _eligibility,\n        address _toggle,\n        string calldata _details,\n        string calldata _imageURI\n    ) internal {\n        if (!noCircularLinkage(_topHatDomain, _newAdminHat))\n            revert CircularLinkage();\n        {\n            uint256 linkedAdmin = linkedTreeAdmins[_topHatDomain];\n\n            // disallow relinking to separate tree\n            if (linkedAdmin > 0) {\n                uint256 tippyTopHat = uint256(\n                    getTippyTopHatDomain(_topHatDomain)\n                ) << 224;\n                if (!isWearerOfHat(msg.sender, tippyTopHat)) {\n                    uint256 destLocalTopHat = uint256(\n                        (_newAdminHat >> 224) << 224\n                    ); // (256 - TOPHAT_ADDRESS_SPACE);\n                    // for non-tippyTopHat wearers: destination local tophat must be either...\n                    // a) the same as origin local tophat, or\n                    // b) within the tippy top hat's local tree\n                    uint256 originLocalTopHat = (linkedAdmin >> 224) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\n                    if (\n                        destLocalTopHat != originLocalTopHat &&\n                        destLocalTopHat != tippyTopHat\n                    ) {\n                        revert CrossTreeLinkage();\n                    }\n                    // for tippyTopHat weerers: destination must be within the same super tree\n                } else if (\n                    !sameTippyTopHatDomain(_topHatDomain, _newAdminHat)\n                ) {\n                    revert CrossTreeLinkage();\n                }\n            }\n        }\n\n        // update and log the linked topHat's modules and metadata, if any changes\n        uint256 topHatId = uint256(_topHatDomain) << 224;\n        Hat storage hat = _hats[topHatId];\n\n        if (_eligibility != address(0)) {\n            hat.eligibility = _eligibility;\n            emit HatEligibilityChanged(topHatId, _eligibility);\n        }\n        if (_toggle != address(0)) {\n            hat.toggle = _toggle;\n            emit HatToggleChanged(topHatId, _toggle);\n        }\n\n        uint256 length = bytes(_details).length;\n        if (length > 0) {\n            if (length > 7000) revert StringTooLong();\n            hat.details = _details;\n            emit HatDetailsChanged(topHatId, _details);\n        }\n\n        length = bytes(_imageURI).length;\n        if (length > 0) {\n            if (length > 7000) revert StringTooLong();\n            hat.imageURI = _imageURI;\n            emit HatImageURIChanged(topHatId, _imageURI);\n        }\n\n        // store the new linked admin\n        linkedTreeAdmins[_topHatDomain] = _newAdminHat;\n        emit TopHatLinked(_topHatDomain, _newAdminHat);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              HATS VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice View the properties of a given Hat\n    /// @param _hatId The id of the Hat\n    /// @return details The details of the Hat\n    /// @return maxSupply The max supply of tokens for this Hat\n    /// @return supply The number of current wearers of this Hat\n    /// @return eligibility The eligibility address for this Hat\n    /// @return toggle The toggle address for this Hat\n    /// @return imageURI The image URI used for this Hat\n    /// @return lastHatId The most recently created Hat with this Hat as admin; also the count of Hats with this Hat as admin\n    /// @return mutable_ Whether this hat's properties can be changed\n    /// @return active Whether the Hat is current active, as read from `_isActive`\n    function viewHat(\n        uint256 _hatId\n    )\n        public\n        view\n        returns (\n            string memory details,\n            uint32 maxSupply,\n            uint32 supply,\n            address eligibility,\n            address toggle,\n            string memory imageURI,\n            uint16 lastHatId,\n            bool mutable_,\n            bool active\n        )\n    {\n        Hat storage hat = _hats[_hatId];\n        details = hat.details;\n        maxSupply = hat.maxSupply;\n        supply = hat.supply;\n        eligibility = hat.eligibility;\n        toggle = hat.toggle;\n        imageURI = getImageURIForHat(_hatId);\n        lastHatId = hat.lastHatId;\n        mutable_ = _isMutable(hat);\n        active = _isActive(hat, _hatId);\n    }\n\n    /// @notice Checks whether a given address wears a given Hat\n    /// @dev Convenience function that wraps `balanceOf`\n    /// @param _user The address in question\n    /// @param _hatId The id of the Hat that the `_user` might wear\n    /// @return isWearer Whether the `_user` wears the Hat.\n    function isWearerOfHat(\n        address _user,\n        uint256 _hatId\n    ) public view returns (bool isWearer) {\n        isWearer = (balanceOf(_user, _hatId) > 0);\n    }\n\n    /// @notice Checks whether a given address serves as the admin of a given Hat\n    /// @dev Recursively checks if `_user` wears the admin Hat of the Hat in question. This is recursive since there may be a string of Hats as admins of Hats.\n    /// @param _user The address in question\n    /// @param _hatId The id of the Hat for which the `_user` might be the admin\n    /// @return isAdmin Whether the `_user` has admin rights for the Hat\n    function isAdminOfHat(\n        address _user,\n        uint256 _hatId\n    ) public view returns (bool isAdmin) {\n        uint256 linkedTreeAdmin;\n        uint32 adminLocalHatLevel;\n        if (isLocalTopHat(_hatId)) {\n            linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n            if (linkedTreeAdmin == 0) {\n                // tree is not linked\n                return isAdmin = isWearerOfHat(_user, _hatId);\n            } else {\n                // tree is linked\n                if (isWearerOfHat(_user, linkedTreeAdmin)) {\n                    return isAdmin = true;\n                }\n                // user wears the treeAdmin\n                else {\n                    adminLocalHatLevel = getLocalHatLevel(linkedTreeAdmin);\n                    _hatId = linkedTreeAdmin;\n                }\n            }\n        } else {\n            // if we get here, _hatId is not a tophat of any kind\n            // get the local tree level of _hatId's admin\n            adminLocalHatLevel = getLocalHatLevel(_hatId) - 1;\n        }\n\n        // search up _hatId's local address space for an admin hat that the _user wears\n        while (adminLocalHatLevel > 0) {\n            if (\n                isWearerOfHat(\n                    _user,\n                    getAdminAtLocalLevel(_hatId, adminLocalHatLevel)\n                )\n            ) {\n                return isAdmin = true;\n            }\n            // should not underflow given stopping condition > 0\n            unchecked {\n                --adminLocalHatLevel;\n            }\n        }\n\n        // if we get here, we've reached the top of _hatId's local tree, ie the local tophat\n        // check if the user wears the local tophat\n        if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, 0)))\n            return isAdmin = true;\n\n        // if not, we check if it's linked to another tree\n        linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\n        if (linkedTreeAdmin == 0) {\n            // tree is not linked\n            // we've already learned that user doesn't wear the local tophat, so there's nothing else to check; we return false\n            return isAdmin = false;\n        } else {\n            // tree is linked\n            // check if user is wearer of linkedTreeAdmin\n            if (isWearerOfHat(_user, linkedTreeAdmin)) return true;\n            // if not, recurse to traverse the parent tree for a hat that the user wears\n            isAdmin = isAdminOfHat(_user, linkedTreeAdmin);\n        }\n    }\n\n    /// @notice Checks the active status of a hat\n    /// @dev For internal use instead of `isActive` when passing Hat as param is preferable\n    /// @param _hat The Hat struct\n    /// @param _hatId The id of the hat\n    /// @return active The active status of the hat\n    function _isActive(\n        Hat storage _hat,\n        uint256 _hatId\n    ) internal view returns (bool active) {\n        (bool success, bytes memory returndata) = _hat.toggle.staticcall(\n            abi.encodeWithSignature(\"getHatStatus(uint256)\", _hatId)\n        );\n\n        /*\n         * if function call succeeds with data of length == 32, then we know the contract exists\n         * and has the getHatStatus function.\n         * But  since function selectors don't include return types  we still can't assume that the return data is a boolean,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 32) {\n            // check the returndata manually\n            uint256 uintReturndata = uint256(bytes32(returndata));\n            // false condition\n            if (uintReturndata == 0) {\n                active = false;\n                // true condition\n            } else if (uintReturndata == 1) {\n                active = true;\n            }\n            // invalid condition\n            else {\n                active = _getHatStatus(_hat);\n            }\n        } else {\n            active = _getHatStatus(_hat);\n        }\n    }\n\n    /// @notice Checks the active status of a hat\n    /// @param _hatId The id of the hat\n    /// @return active Whether the hat is active\n    function isActive(uint256 _hatId) external view returns (bool active) {\n        active = _isActive(_hats[_hatId], _hatId);\n    }\n\n    /// @notice Internal function to retrieve a hat's status from storage\n    /// @dev reads the 0th bit of the hat's config\n    /// @param _hat The hat object\n    /// @return status Whether the hat is active\n    function _getHatStatus(\n        Hat storage _hat\n    ) internal view returns (bool status) {\n        status = (_hat.config >> 95 != 0);\n    }\n\n    /// @notice Internal function to retrieve a hat's mutability setting\n    /// @dev reads the 1st bit of the hat's config\n    /// @param _hat The hat object\n    /// @return _mutable Whether the hat is mutable\n    function _isMutable(\n        Hat storage _hat\n    ) internal view returns (bool _mutable) {\n        _mutable = (_hat.config & uint96(1 << 94) != 0);\n    }\n\n    /// @notice Checks whether a wearer of a Hat is in good standing\n    /// @param _wearer The address of the Hat wearer\n    /// @param _hatId The id of the Hat\n    /// @return standing Whether the wearer is in good standing\n    function isInGoodStanding(\n        address _wearer,\n        uint256 _hatId\n    ) public view returns (bool standing) {\n        (bool success, bytes memory returndata) = _hats[_hatId]\n            .eligibility\n            .staticcall(\n                abi.encodeWithSignature(\n                    \"getWearerStatus(address,uint256)\",\n                    _wearer,\n                    _hatId\n                )\n            );\n\n        /*\n         * if function call succeeds with data of length == 64, then we know the contract exists\n         * and has the getWearerStatus function (which returns two words).\n         * But  since function selectors don't include return types  we still can't assume that the return data is two booleans,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 64) {\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(\n                returndata,\n                (uint256, uint256)\n            );\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // returndata is invalid\n            } else {\n                standing = !badStandings[_hatId][_wearer];\n            }\n        } else {\n            standing = !badStandings[_hatId][_wearer];\n        }\n    }\n\n    /// @notice Internal call to check whether an address is eligible for a given Hat\n    /// @dev Tries an external call to the Hat's eligibility module, defaulting to existing badStandings state if the call fails (ie if the eligibility module address does not conform to the IHatsEligibility interface)\n    /// @param _wearer The address of the Hat wearer\n    /// @param _hat The Hat object\n    /// @param _hatId The id of the Hat\n    /// @return eligible Whether the wearer is eligible for the Hat\n    function _isEligible(\n        address _wearer,\n        Hat storage _hat,\n        uint256 _hatId\n    ) internal view returns (bool eligible) {\n        (bool success, bytes memory returndata) = _hat.eligibility.staticcall(\n            abi.encodeWithSignature(\n                \"getWearerStatus(address,uint256)\",\n                _wearer,\n                _hatId\n            )\n        );\n\n        /*\n         * if function call succeeds with data of length == 64, then we know the contract exists\n         * and has the getWearerStatus function (which returns two words).\n         * But  since function selectors don't include return types  we still can't assume that the return data is two booleans,\n         * so we treat it as a uint so it will always safely decode without throwing.\n         */\n        if (success && returndata.length == 64) {\n            bool standing;\n            // check the returndata manually\n            (uint256 firstWord, uint256 secondWord) = abi.decode(\n                returndata,\n                (uint256, uint256)\n            );\n            // returndata is valid\n            if (firstWord < 2 && secondWord < 2) {\n                standing = (secondWord == 1) ? true : false;\n                // never eligible if in bad standing\n                eligible = (standing && firstWord == 1) ? true : false;\n            }\n            // returndata is invalid\n            else {\n                eligible = !badStandings[_hatId][_wearer];\n            }\n        } else {\n            eligible = !badStandings[_hatId][_wearer];\n        }\n    }\n\n    /// @notice Checks whether an address is eligible for a given Hat\n    /// @dev Public function for use when passing a Hat object is not possible or preferable\n    /// @param _hatId The id of the Hat\n    /// @param _wearer The address to check\n    /// @return eligible Whether the wearer is eligible for the Hat\n    function isEligible(\n        address _wearer,\n        uint256 _hatId\n    ) public view returns (bool eligible) {\n        eligible = _isEligible(_wearer, _hats[_hatId], _hatId);\n    }\n\n    /// @notice Gets the current supply of a Hat\n    /// @dev Only tracks explicit burns and mints, not dynamic revocations\n    /// @param _hatId The id of the Hat\n    /// @return supply The current supply of the Hat\n    function hatSupply(uint256 _hatId) external view returns (uint32 supply) {\n        supply = _hats[_hatId].supply;\n    }\n\n    /// @notice Gets the eligibility module for a hat\n    /// @param _hatId The hat whose eligibility module we're looking for\n    /// @return eligibility The eligibility module for this hat\n    function getHatEligibilityModule(\n        uint256 _hatId\n    ) external view returns (address eligibility) {\n        eligibility = _hats[_hatId].eligibility;\n    }\n\n    /// @notice Gets the toggle module for a hat\n    /// @param _hatId The hat whose toggle module we're looking for\n    /// @return toggle The toggle module for this hat\n    function getHatToggleModule(\n        uint256 _hatId\n    ) external view returns (address toggle) {\n        toggle = _hats[_hatId].toggle;\n    }\n\n    /// @notice Gets the max supply for a hat\n    /// @param _hatId The hat whose max supply we're looking for\n    /// @return maxSupply The maximum possible quantity of this hat that could be minted\n    function getHatMaxSupply(\n        uint256 _hatId\n    ) external view returns (uint32 maxSupply) {\n        maxSupply = _hats[_hatId].maxSupply;\n    }\n\n    /// @notice Gets the imageURI for a given hat\n    /// @dev If this hat does not have an imageURI set, recursively get the imageURI from\n    ///      its admin\n    /// @param _hatId The hat whose imageURI we're looking for\n    /// @return _uri The imageURI of this hat or, if empty, its admin\n    function getImageURIForHat(\n        uint256 _hatId\n    ) public view returns (string memory _uri) {\n        // check _hatId first to potentially avoid the `getHatLevel` call\n        Hat storage hat = _hats[_hatId];\n\n        string memory imageURI = hat.imageURI; // save 1 SLOAD\n\n        // if _hatId has an imageURI, we return it\n        if (bytes(imageURI).length > 0) {\n            return imageURI;\n        }\n\n        // otherwise, we check its branch of admins\n        uint256 level = getHatLevel(_hatId);\n\n        // but first we check if _hatId is a tophat, in which case we fall back to the global image uri\n        if (level == 0) return baseImageURI;\n\n        // otherwise, we check each of its admins for a valid imageURI\n        uint256 id;\n\n        // already checked at `level` above, so we start the loop at `level - 1`\n        for (uint256 i = level - 1; i > 0; ) {\n            id = getAdminAtLevel(_hatId, uint32(i));\n            hat = _hats[id];\n            imageURI = hat.imageURI;\n\n            if (bytes(imageURI).length > 0) {\n                return imageURI;\n            }\n            // should not underflow given stopping condition is > 0\n            unchecked {\n                --i;\n            }\n        }\n\n        id = getAdminAtLevel(_hatId, 0);\n        hat = _hats[id];\n        imageURI = hat.imageURI;\n\n        if (bytes(imageURI).length > 0) {\n            return imageURI;\n        }\n\n        // if none of _hatId's admins has an imageURI of its own, we again fall back to the global image uri\n        _uri = baseImageURI;\n    }\n\n    /// @notice Constructs the URI for a Hat, using data from the Hat struct\n    /// @return _uri An ERC1155-compatible JSON string\n    function _constructURI(uint256) internal pure returns (string memory _uri) {\n        _uri = \"\";\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 OVERRIDES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Gets the Hat token balance of a user for a given Hat\n    /// @dev Balance is dynamic based on the hat's status and wearer's eligibility, so off-chain balance data indexed from events may not be in sync\n    /// @param _wearer The address whose balance is being checked\n    /// @param _hatId The id of the Hat\n    /// @return balance The `wearer`'s balance of the Hat tokens. Can never be > 1.\n    function balanceOf(\n        address _wearer,\n        uint256 _hatId\n    ) public view override(ERC1155, IHats) returns (uint256 balance) {\n        Hat storage hat = _hats[_hatId];\n\n        balance = 0;\n\n        if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\n            balance = super.balanceOf(_wearer, _hatId);\n        }\n    }\n\n    /// @notice Internal call to mint a Hat token to a wearer\n    /// @dev Unsafe if called when `_wearer` has a non-zero balance of `_hatId`\n    /// @param _wearer The wearer of the Hat and the recipient of the newly minted token\n    /// @param _hatId The id of the Hat to mint\n    function _mintHat(address _wearer, uint256 _hatId) internal {\n        unchecked {\n            // should not overflow since `mintHat` enforces max balance of 1\n            _balanceOf[_wearer][_hatId] = 1;\n\n            // increment Hat supply counter\n            // should not overflow given AllHatsWorn check in `mintHat`\n            ++_hats[_hatId].supply;\n        }\n\n        emit TransferSingle(msg.sender, address(0), _wearer, _hatId, 1);\n    }\n\n    /// @notice Internal call to burn a wearer's Hat token\n    /// @dev Unsafe if called when `_wearer` doesn't have a zero balance of `_hatId`\n    /// @param _wearer The wearer from which to burn the Hat token\n    /// @param _hatId The id of the Hat to burn\n    function _burnHat(address _wearer, uint256 _hatId) internal {\n        // neither should underflow since `_burnHat` is never called on non-positive balance\n        unchecked {\n            _balanceOf[_wearer][_hatId] = 0;\n\n            // decrement Hat supply counter\n            --_hats[_hatId].supply;\n        }\n\n        emit TransferSingle(msg.sender, _wearer, address(0), _hatId, 1);\n    }\n\n    /// @notice Approvals are not necessary for Hats since transfers are not handled by the wearer\n    /// @dev Admins should use `transferHat()` to transfer\n    function setApprovalForAll(address, bool) public pure override {\n        revert();\n    }\n\n    /// @notice Safe transfers are not necessary for Hats since transfers are not handled by the wearer\n    /// @dev Admins should use `transferHat()` to transfer\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override {\n        revert();\n    }\n\n    /// @notice Safe transfers are not necessary for Hats since transfers are not handled by the wearer\n    function safeBatchTransferFrom(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public pure override {\n        revert();\n    }\n\n    /**\n     * @notice ERC165 interface detection\n     *  @dev While Hats Protocol conforms to the ERC1155 *interface*, it does not fully conform to the ERC1155 *specification*\n     *  since it does not implement the ERC1155Receiver functionality.\n     *  For this reason, this function overrides the ERC1155 implementation to return false for ERC1155.\n     *  @param interfaceId The interface identifier, as specified in ERC-165\n     *  @return bool True if the contract implements `interfaceId` and false otherwise\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            // interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /// @notice Batch retrieval for wearer balances\n    /// @dev Given the higher gas overhead of Hats balanceOf checks, large batches may be high cost or run into gas limits\n    /// @param _wearers Array of addresses to check balances for\n    /// @param _hatIds Array of Hat ids to check, using the same index as _wearers\n    function balanceOfBatch(\n        address[] calldata _wearers,\n        uint256[] calldata _hatIds\n    ) public view override(ERC1155, IHats) returns (uint256[] memory balances) {\n        if (_wearers.length != _hatIds.length)\n            revert BatchArrayLengthMismatch();\n\n        balances = new uint256[](_wearers.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i; i < _wearers.length; ++i) {\n                balances[i] = balanceOf(_wearers[i], _hatIds[i]);\n            }\n        }\n    }\n\n    /// @notice View the uri for a Hat\n    /// @param id The id of the Hat\n    /// @return _uri An 1155-compatible JSON object\n    function uri(\n        uint256 id\n    ) public pure override(ERC1155, IHats) returns (string memory _uri) {\n        _uri = _constructURI(id);\n    }\n}\n"
    },
    "contracts/mocks/MockHatsAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\ncontract MockHatsAccount {\n    // see https://github.com/Hats-Protocol/hats-account/blob/00650b3de756352d303ca08e4b024376f1d1db98/src/HatsAccountBase.sol#L41\n    // for my inspiration\n\n    function tokenId() public view returns (uint256) {\n        bytes memory footer = new bytes(0x20);\n        assembly {\n            // copy 0x20 bytes from final word of footer\n            extcodecopy(address(), add(footer, 0x20), 0x8d, 0x20)\n        }\n        return abi.decode(footer, (uint256));\n    }\n\n    function tokenImplementation() public view returns (address) {\n        bytes memory footer = new bytes(0x20);\n        assembly {\n            // copy 0x20 bytes from third word of footer\n            extcodecopy(address(), add(footer, 0x20), 0x6d, 0x20)\n        }\n        return abi.decode(footer, (address));\n    }\n\n    function execute(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        uint8\n    ) external returns (bytes memory) {\n        (bool success, bytes memory result) = to.call{value: value}(data);\n        require(success, \"HatsAccount: execution failed\");\n        return result;\n    }\n}\n"
    },
    "contracts/mocks/MockHatsProposalCreationWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport \"../azorius/strategies/HatsProposalCreationWhitelist.sol\";\n\ncontract MockHatsProposalCreationWhitelist is HatsProposalCreationWhitelist {\n    function setUp(bytes memory initializeParams) public override initializer {\n        __Ownable_init();\n        super.setUp(initializeParams);\n    }\n}\n"
    },
    "contracts/mocks/MockVotingStrategy.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity =0.8.19;\n\nimport { BaseStrategy, IBaseStrategy } from \"../azorius/BaseStrategy.sol\";\n\n/**\n * A mock [BaseStrategy](../BaseStrategy.md) used only for testing purposes.\n * Not intended for actual on-chain use.\n */\ncontract MockVotingStrategy is BaseStrategy {\n    address public proposer;\n\n    /**\n     * Sets up the contract with its initial parameters.\n     *\n     * @param initializeParams encoded initialization parameters\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        address _proposer = abi.decode(initializeParams, (address));\n        proposer = _proposer;\n    }\n\n    /** @inheritdoc IBaseStrategy*/\n    function initializeProposal(bytes memory _data) external override {}\n\n    /** @inheritdoc IBaseStrategy*/\n    function isPassed(uint32) external pure override returns (bool) {\n        return false;\n    }\n\n    /** @inheritdoc IBaseStrategy*/\n    function isProposer(address _proposer) external view override returns (bool) {\n        return _proposer == proposer;\n    }\n\n    /** @inheritdoc IBaseStrategy*/\n    function votingEndBlock(uint32) external pure override returns (uint32) {\n        return 0;\n    }\n}\n"
    },
    "contracts/MultisigFreezeGuard.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { IMultisigFreezeGuard } from \"./interfaces/IMultisigFreezeGuard.sol\";\nimport { IBaseFreezeVoting } from \"./interfaces/IBaseFreezeVoting.sol\";\nimport { ISafe } from \"./interfaces/ISafe.sol\";\nimport { IGuard } from \"@gnosis.pm/zodiac/contracts/interfaces/IGuard.sol\";\nimport { FactoryFriendly } from \"@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol\";\nimport { Enum } from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport { BaseGuard } from \"@gnosis.pm/zodiac/contracts/guard/BaseGuard.sol\";\n\n/**\n * Implementation of [IMultisigFreezeGuard](./interfaces/IMultisigFreezeGuard.md).\n */\ncontract MultisigFreezeGuard is FactoryFriendly, IGuard, IMultisigFreezeGuard, BaseGuard {\n\n    /** Timelock period (in blocks). */\n    uint32 public timelockPeriod;\n\n    /** Execution period (in blocks). */\n    uint32 public executionPeriod;\n\n    /**\n     * Reference to the [IBaseFreezeVoting](./interfaces/IBaseFreezeVoting.md)\n     * implementation that determines whether the Safe is frozen.\n     */\n    IBaseFreezeVoting public freezeVoting;\n\n    /** Reference to the Safe that can be frozen. */\n    ISafe public childGnosisSafe;\n\n    /** Mapping of signatures hash to the block during which it was timelocked. */\n    mapping(bytes32 => uint32) internal transactionTimelockedBlock;\n\n    event MultisigFreezeGuardSetup(\n        address creator,\n        address indexed owner,\n        address indexed freezeVoting,\n        address indexed childGnosisSafe\n    );\n    event TransactionTimelocked(\n        address indexed timelocker,\n        bytes32 indexed transactionHash,\n        bytes indexed signatures\n    );\n    event TimelockPeriodUpdated(uint32 timelockPeriod);\n    event ExecutionPeriodUpdated(uint32 executionPeriod);\n\n    error AlreadyTimelocked();\n    error NotTimelocked();\n    error Timelocked();\n    error Expired();\n    error DAOFrozen();\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `uint256 _timelockPeriod`,\n     * `uint256 _executionPeriod`, `address _owner`, `address _freezeVoting`, `address _childGnosisSafe`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        __Ownable_init();\n        (\n            uint32 _timelockPeriod,\n            uint32 _executionPeriod,\n            address _owner,\n            address _freezeVoting,\n            address _childGnosisSafe\n        ) = abi.decode(\n                initializeParams,\n                (uint32, uint32, address, address, address)\n            );\n\n        _updateTimelockPeriod(_timelockPeriod);\n        _updateExecutionPeriod(_executionPeriod);\n        transferOwnership(_owner);\n        freezeVoting = IBaseFreezeVoting(_freezeVoting);\n        childGnosisSafe = ISafe(_childGnosisSafe);\n\n        emit MultisigFreezeGuardSetup(\n            msg.sender,\n            _owner,\n            _freezeVoting,\n            _childGnosisSafe\n        );\n    }\n\n    /** @inheritdoc IMultisigFreezeGuard*/\n    function timelockTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        uint256 nonce\n    ) external {\n        bytes32 signaturesHash = keccak256(signatures);\n\n        if (transactionTimelockedBlock[signaturesHash] != 0)\n            revert AlreadyTimelocked();\n\n        bytes memory transactionHashData = childGnosisSafe\n            .encodeTransactionData(\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                nonce\n            );\n\n        bytes32 transactionHash = keccak256(transactionHashData);\n\n        // if signatures are not valid, this will revert\n        childGnosisSafe.checkSignatures(\n            transactionHash,\n            transactionHashData,\n            signatures\n        );\n\n        transactionTimelockedBlock[signaturesHash] = uint32(block.number);\n\n        emit TransactionTimelocked(msg.sender, transactionHash, signatures);\n    }\n\n    /** @inheritdoc IMultisigFreezeGuard*/\n    function updateTimelockPeriod(uint32 _timelockPeriod) external onlyOwner {\n        _updateTimelockPeriod(_timelockPeriod);\n    }\n\n    /** @inheritdoc IMultisigFreezeGuard*/\n    function updateExecutionPeriod(uint32 _executionPeriod) external onlyOwner {\n        executionPeriod = _executionPeriod;\n    }\n\n    /**\n     * Called by the Safe to check if the transaction is able to be executed and reverts\n     * if the guard conditions are not met.\n     */\n    function checkTransaction(\n        address,\n        uint256,\n        bytes memory,\n        Enum.Operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory signatures,\n        address\n    ) external view override(BaseGuard, IGuard) {\n        bytes32 signaturesHash = keccak256(signatures);\n\n        if (transactionTimelockedBlock[signaturesHash] == 0)\n            revert NotTimelocked();\n\n        if (\n            block.number <\n            transactionTimelockedBlock[signaturesHash] + timelockPeriod\n        ) revert Timelocked();\n\n        if (\n            block.number >\n            transactionTimelockedBlock[signaturesHash] +\n                timelockPeriod +\n                executionPeriod\n        ) revert Expired();\n\n        if (freezeVoting.isFrozen()) revert DAOFrozen();\n    }\n\n    /**\n     * A callback performed after a transaction is executed on the Safe. This is a required\n     * function of the `BaseGuard` and `IGuard` interfaces that we do not make use of.\n     */\n    function checkAfterExecution(bytes32, bool) external view override(BaseGuard, IGuard) {\n        // not implementated\n    }\n\n    /** @inheritdoc IMultisigFreezeGuard*/\n    function getTransactionTimelockedBlock(bytes32 _signaturesHash) public view returns (uint32) {\n        return transactionTimelockedBlock[_signaturesHash];\n    }\n\n    /** Internal implementation of `updateTimelockPeriod` */\n    function _updateTimelockPeriod(uint32 _timelockPeriod) internal {\n        timelockPeriod = _timelockPeriod;\n        emit TimelockPeriodUpdated(_timelockPeriod);\n    }\n\n    /** Internal implementation of `updateExecutionPeriod` */\n    function _updateExecutionPeriod(uint32 _executionPeriod) internal {\n        executionPeriod = _executionPeriod;\n        emit ExecutionPeriodUpdated(_executionPeriod);\n    }\n}\n"
    },
    "contracts/MultisigFreezeVoting.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { BaseFreezeVoting, IBaseFreezeVoting } from \"./BaseFreezeVoting.sol\";\nimport { ISafe } from \"./interfaces/ISafe.sol\";\n\n/**\n * A BaseFreezeVoting implementation which handles freezes on multi-sig (Safe) based DAOs.\n */\ncontract MultisigFreezeVoting is BaseFreezeVoting {\n    ISafe public parentGnosisSafe;\n\n    event MultisigFreezeVotingSetup(\n        address indexed owner,\n        address indexed parentGnosisSafe\n    );\n\n    error NotOwner();\n    error AlreadyVoted();\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `uint256 _freezeVotesThreshold`, `uint256 _freezeProposalPeriod`, `uint256 _freezePeriod`,\n     * `address _parentGnosisSafe`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (\n            address _owner,\n            uint256 _freezeVotesThreshold,\n            uint32 _freezeProposalPeriod,\n            uint32 _freezePeriod,\n            address _parentGnosisSafe\n        ) = abi.decode(\n                initializeParams,\n                (address, uint256, uint32, uint32, address)\n            );\n\n        __Ownable_init();\n        _transferOwnership(_owner);\n        _updateFreezeVotesThreshold(_freezeVotesThreshold);\n        _updateFreezeProposalPeriod(_freezeProposalPeriod);\n        _updateFreezePeriod(_freezePeriod);\n        parentGnosisSafe = ISafe(_parentGnosisSafe);\n\n        emit MultisigFreezeVotingSetup(_owner, _parentGnosisSafe);\n    }\n\n    /** @inheritdoc IBaseFreezeVoting*/\n    function castFreezeVote() external override {\n        if (!parentGnosisSafe.isOwner(msg.sender)) revert NotOwner();\n\n        if (block.number > freezeProposalCreatedBlock + freezeProposalPeriod) {\n            // create a new freeze proposal and count the caller's vote\n\n            freezeProposalCreatedBlock = uint32(block.number);\n\n            freezeProposalVoteCount = 1;\n\n            emit FreezeProposalCreated(msg.sender);\n        } else {\n            // there is an existing freeze proposal, count the caller's vote\n\n            if (userHasFreezeVoted[msg.sender][freezeProposalCreatedBlock])\n                revert AlreadyVoted();\n\n            freezeProposalVoteCount++;\n        }\n\n        userHasFreezeVoted[msg.sender][freezeProposalCreatedBlock] = true;\n\n        emit FreezeVoteCast(msg.sender, 1);\n    }\n}\n"
    },
    "contracts/Version.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {IVersion} from \"./interfaces/IVersion.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @title Version\n * @dev Abstract contract providing standardized contract identification\n *\n * Inheriting contracts MUST implement:\n * - getVersion()\n */\nabstract contract Version is IVersion, ERC165 {\n    /**\n     * @dev Returns the version number of this contract implementation\n     * Inheriting contracts MUST override this function.\n     */\n    function getVersion() public view virtual returns (uint16);\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IVersion).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/VotesERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { FactoryFriendly } from \"@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol\";\nimport { ERC165Storage } from \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20VotesUpgradeable, ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport { ERC20SnapshotUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\n\n/**\n * An implementation of the Open Zeppelin `IVotes` voting token standard.\n */\ncontract VotesERC20 is\n    IERC20Upgradeable,\n    ERC20SnapshotUpgradeable,\n    ERC20VotesUpgradeable,\n    ERC165Storage,\n    FactoryFriendly\n{\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `string memory _name`,\n     * `string memory _symbol`, `address[] memory _allocationAddresses`, \n     * `uint256[] memory _allocationAmounts`\n     */\n    function setUp(bytes memory initializeParams) public virtual override initializer {\n        (\n            string memory _name,                    // token name\n            string memory _symbol,                  // token symbol\n            address[] memory _allocationAddresses,  // addresses of initial allocations\n            uint256[] memory _allocationAmounts     // amounts of initial allocations\n        ) = abi.decode(\n                initializeParams,\n                (string, string, address[], uint256[])\n            );\n\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n        _registerInterface(type(IERC20Upgradeable).interfaceId);\n\n        uint256 holderCount = _allocationAddresses.length;\n        for (uint256 i; i < holderCount; ) {\n            _mint(_allocationAddresses[i], _allocationAmounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * See `ERC20SnapshotUpgradeable._snapshot()`.\n     */\n    function captureSnapShot() external returns (uint256 snapId) {\n        snapId = _snapshot();\n    }\n\n    // -- The functions below are overrides required by extended contracts. --\n\n    /** Overridden without modification. */\n    function _mint(\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._mint(to, amount);\n    }\n\n    /** Overridden without modification. */\n    function _burn(\n        address account,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._burn(account, amount);\n    }\n\n    /** Overridden without modification. */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, ERC20SnapshotUpgradeable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    /** Overridden without modification. */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/VotesERC20LockableV1.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport {ILockableV1} from \"./interfaces/ILockableV1.sol\";\nimport {IMintableV1} from \"./interfaces/IMintableV1.sol\";\nimport {VotesERC20} from \"./VotesERC20.sol\";\nimport {Version} from \"./Version.sol\";\nimport {ERC165Storage} from \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\n\ncontract VotesERC20LockableV1 is ILockableV1, IMintableV1, VotesERC20, Version {\n    uint16 private constant VERSION = 1;\n\n    bool public locked;\n    mapping(address => bool) public whitelisted;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    modifier isTransferable(address from) {\n        if (\n            locked &&\n            // overrides while locked\n            !(from == owner() || // owner can always transfer\n                whitelisted[from] || // whitelisted addresses can always transfer\n                from == address(0)) // can always mint when locked\n        ) {\n            revert IsLocked();\n        }\n        _;\n    }\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `address _owner`,\n     * `bool _locked`, `string memory _name`, `string memory _symbol`,\n     * `address[] memory _allocationAddresses`, `uint256[] memory _allocationAmounts`\n     */\n    function initialize(bytes memory initializeParams) public virtual {\n        (\n            address _owner, // token owner\n            bool _locked, // whether the token is locked\n            string memory _name, // token name\n            string memory _symbol, // token symbol\n            address[] memory _allocationAddresses, // addresses of initial allocations\n            uint256[] memory _allocationAmounts // amounts of initial allocations\n        ) = abi.decode(\n                initializeParams,\n                (address, bool, string, string, address[], uint256[])\n            );\n        super.setUp(\n            abi.encode(_name, _symbol, _allocationAddresses, _allocationAmounts)\n        );\n        _transferOwnership(_owner);\n        locked = _locked;\n    }\n\n    function lock(bool _locked) external onlyOwner {\n        if (_locked == locked) {\n            revert CannotSwitchLockState(_locked);\n        }\n        locked = _locked;\n        emit Locked(_locked);\n    }\n\n    function whitelist(address account, bool isWhitelisted) external onlyOwner {\n        bool currentlyWhitelisted = whitelisted[account];\n        whitelisted[account] = isWhitelisted;\n        if (currentlyWhitelisted != isWhitelisted) {\n            emit Whitelisted(account, isWhitelisted);\n        }\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override isTransferable(from) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function getVersion() public view virtual override returns (uint16) {\n        return VERSION;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165Storage, Version) returns (bool) {\n        return\n            interfaceId == type(ILockableV1).interfaceId ||\n            interfaceId == type(IMintableV1).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/VotesERC20Wrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport { ERC20VotesUpgradeable, ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport { ERC20WrapperUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20WrapperUpgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { VotesERC20 } from \"./VotesERC20.sol\";\n\n/**\n * An extension of `VotesERC20` which supports wrapping / unwrapping an existing ERC20 token,\n * to allow for importing an existing token into the Azorius governance framework.\n */\ncontract VotesERC20Wrapper is VotesERC20, ERC20WrapperUpgradeable {\n    \n    constructor() {\n      _disableInitializers();\n    }\n\n    /**\n     * Initialize function, will be triggered when a new instance is deployed.\n     *\n     * @param initializeParams encoded initialization parameters: `address _underlyingTokenAddress`\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        (address _underlyingTokenAddress) = abi.decode(initializeParams, (address));\n\n        // not necessarily upgradeable, but required to pass into __ERC20Wrapper_init\n        ERC20Upgradeable token = ERC20Upgradeable(_underlyingTokenAddress);\n\n        __ERC20Wrapper_init(token);\n\n        string memory name = string.concat(\"Wrapped \", token.name());\n        __ERC20_init(name, string.concat(\"W\", token.symbol()));\n        __ERC20Permit_init(name);\n        _registerInterface(type(IERC20Upgradeable).interfaceId);\n    }\n\n    // -- The functions below are overrides required by extended contracts. --\n\n    /** Overridden without modification. */\n    function _mint(\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, VotesERC20) {\n        super._mint(to, amount);\n    }\n\n    /** Overridden without modification. */\n    function _burn(\n        address account,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, VotesERC20) {\n        super._burn(account, amount);\n    }\n\n    /** Overridden without modification. */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, VotesERC20) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    /** Overridden without modification. */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, VotesERC20) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    /** Overridden without modification. */\n    function decimals() public view virtual override(ERC20Upgradeable, ERC20WrapperUpgradeable) returns (uint8) {\n        return super.decimals();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}