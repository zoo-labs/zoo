import * as fs from 'fs';
import * as path from 'path';

export interface TestResult {
  name: string;
  passed: boolean;
  crashed?: boolean;
  errorMsg?: string;
  screenshotPath?: string;
  durationMs?: number;
}

export interface SummaryOptions {
  resultsDir: string;
  governanceType?: string;
  timestamp: string;
  totalRunTimeStr: string;
  wallClockDuration?: number;
  openSummary?: boolean;
  skipMarkdown?: boolean;
  baseUrl?: string;
}

export function generateTestSummary(testResults: TestResult[], options: SummaryOptions): void {
  const { resultsDir, governanceType, timestamp, totalRunTimeStr, openSummary = true, skipMarkdown = false, baseUrl } = options;
  
  if (!fs.existsSync(resultsDir)) {
    fs.mkdirSync(resultsDir, { recursive: true });
  }

  const passedCount = testResults.filter(r => r.passed).length;
  const totalCount = testResults.length;
  const failedCount = testResults.filter(r => !r.passed && !r.crashed && r.errorMsg !== 'Skipped due to header-loads failure.').length;
  const crashedCount = testResults.filter(r => r.crashed).length;
  const skippedCount = testResults.filter(r => r.errorMsg === 'Skipped due to header-loads failure.').length;

  // Generate Markdown summary (skip if part of multi-governance run)
  if (!skipMarkdown && !process.env.SKIP_MARKDOWN) {
    generateMarkdownSummary(testResults, {
      resultsDir,
      passedCount,
      totalCount,
      timestamp,
      totalRunTimeStr
    });
  }

  // Generate HTML summary
  generateHtmlSummary(testResults, {
    resultsDir,
    passedCount,
    totalCount,
    failedCount,
    crashedCount,
    skippedCount,
    timestamp,
    totalRunTimeStr,
    governanceType
  });

  // Open HTML summary if requested and not running as part of multi-governance
  if (openSummary && !process.env.SCREENSHOTS_DIR) {
    const htmlSummaryPath = path.join(resultsDir, 'test-results-summary.html');
    if (process.platform === 'win32') {
      require('child_process').spawn('cmd', ['/c', 'start', '', htmlSummaryPath], { stdio: 'ignore', detached: true });
    } else {
      const openCmd = process.platform === 'darwin' ? 'open' : 'xdg-open';
      require('child_process').spawn(openCmd, [htmlSummaryPath], { stdio: 'ignore', detached: true });
    }
  }
}

function generateMarkdownSummary(testResults: TestResult[], options: {
  resultsDir: string;
  passedCount: number;
  totalCount: number;
  timestamp: string;
  totalRunTimeStr: string;
  baseUrl?: string;
}): void {
  const { resultsDir, passedCount, totalCount, timestamp, totalRunTimeStr, baseUrl } = options;

  let md = `## 🧪 UI Automation Test Results\n\n`;
  md += `> 📸 Download all screenshots from the workflow artifacts above. Extract the test results file and open the html summary to quickly review results and screenshots.\n\n`;
  md += `**Timestamp:** ${timestamp}  \n`;
  if (baseUrl) {
    md += `**Base URL:** ${baseUrl}  \n`;
  }
  md += `**Total run time:** ${totalRunTimeStr}  `;
  md += `**${passedCount}/${totalCount} tests passed**\n\n`;
  md += `| Test Name | Result | Run Time | Screenshot |\n|---|---|---|---|\n`;

  let errorId = 0;
  for (const r of testResults) {
    let resultEmoji;
    if (r.passed) {
      resultEmoji = '✅';
    } else if (r.crashed) {
      resultEmoji = '⚪';
    } else if (r.errorMsg === 'Skipped due to header-loads failure.') {
      resultEmoji = '⚠️';
    } else {
      resultEmoji = '❌';
    }
    let runTime = '';
    if (typeof r.durationMs === 'number') {
      const seconds = r.durationMs / 1000;
      if (seconds >= 60) {
        runTime = (seconds / 60).toFixed(1) + ' min';
      } else {
        runTime = seconds.toFixed(2) + 's';
      }
    }
    
    // Remove screenshot link for PR comment, just show 'Available' if screenshot exists
    let screenshotCell = '';
    screenshotCell = '';
    if (r.screenshotPath && fs.existsSync(r.screenshotPath)) {
      try {
        const stats = fs.statSync(r.screenshotPath);
        if (stats.size > 0) {
          screenshotCell = 'Available';
        }
      } catch {}
    }
    
    let testNameCell = r.name;
    md += `| ${testNameCell} | ${resultEmoji} | ${runTime} | ${screenshotCell} |\n`;
    errorId++;
  }

  // Add error details as collapsible sections
  errorId = 0;
  for (const r of testResults) {
    if (!r.passed && r.errorMsg && r.errorMsg !== 'Skipped due to header-loads failure.') {
      md += `\n<details id="error-details-${errorId}"><summary><b>Error details for ${r.name}</b></summary>\n\n`;
      md += `\n\u0060\u0060\u0060\n${r.errorMsg.replace(/\r\n/g, '\n').replace(/\r/g, '\n')}\n\u0060\u0060\u0060\n`;
      md += '</details>\n';
      errorId++;
    }
  }

  md += `\n---\n*Generated by UI automation workflow.*\n`;

  const summaryPath = path.join(resultsDir, 'test-results-summary.md');
  fs.writeFileSync(summaryPath, md);
}

function generateHtmlSummary(testResults: TestResult[], options: {
  resultsDir: string;
  passedCount: number;
  totalCount: number;
  failedCount: number;
  crashedCount: number;
  skippedCount: number;
  timestamp: string;
  totalRunTimeStr: string;
  governanceType?: string;
  baseUrl?: string;
}): void {
  const { resultsDir, passedCount, totalCount, failedCount, crashedCount, skippedCount, timestamp, totalRunTimeStr, governanceType, baseUrl } = options;

  let html = `<!DOCTYPE html>\n<html lang='en'>\n<head>\n<meta charset='UTF-8'>\n<title>Test Results Summary</title>\n<style>\nbody { font-family: Arial, sans-serif; background: #fafbfc; color: #222; }\ntable { border-collapse: collapse; width: 100%; margin-top: 1em; }\nth, td { border: 1px solid #ccc; padding: 8px 12px; text-align: left; }\nth { background: #f3f3f3; }\n.pass { color: #228B22; font-weight: bold; }\n.fail { color: #B22222; font-weight: bold; }\n.crash { color: #666; font-weight: bold; }\n.skipped { color: #b59a00; font-weight: bold; }\ntr:nth-child(even) { background: #f9f9f9; }\ntr.data-row:hover { background: #e0eaff !important; }\n.bar-container { width: 100%; height: 24px; background: #eee; border-radius: 6px; overflow: hidden; margin: 18px 0 10px 0; border: 1px solid #ccc; display: flex; }\n.bar-pass { background: #228B22; height: 100%; }\n.bar-fail { background: #B22222; height: 100%; }\n.bar-crash { background: #666; height: 100%; }\n.bar-skipped { background: #b59a00; height: 100%; }\n.error-link { color: #0074d9; cursor: pointer; text-decoration: underline; font-size: 0.95em; margin-left: 8px; }\n.error-details { display: none; color: #B22222; font-size: 0.95em; background: #fff8f8; border: 1px solid #f3cccc; border-radius: 4px; margin-top: 4px; padding: 8px; white-space: pre-wrap; }\n</style>\n<script>\n`;

  if (governanceType) {
    html += `function toggleError(gov, id) {\n  var details = document.getElementById(gov + '-error-details-' + id);\n  var link = document.getElementById(gov + '-error-link-' + id);\n  if (details.style.display === 'block') {\n    details.style.display = 'none';\n    link.textContent = '(show error)';\n  } else {\n    details.style.display = 'block';\n    link.textContent = '(hide error)';\n  }\n}\n`;
  } else {
    html += `function toggleError(id) {\n  var details = document.getElementById('error-details-' + id);\n  var link = document.getElementById('error-link-' + id);\n  if (details.style.display === 'block') {\n    details.style.display = 'none';\n    link.textContent = '(show error)';\n  } else {\n    details.style.display = 'block';\n    link.textContent = '(hide error)';\n  }\n}\n`;
  }

  html += `</script>\n</head>\n<body>\n<h2>Test Results Summary</h2>\n<p><b>Timestamp:</b> ${timestamp}</p>\n${baseUrl ? `<p><b>Base URL:</b> ${baseUrl}</p>\n` : ''}<p><b>Total run time:</b> ${totalRunTimeStr}</p>\n<p><b>${passedCount}/${totalCount} tests passed</b></p>\n<div class='bar-container'>\n  <div class='bar-pass' style='width:${passedCount/totalCount*100}%' title='Passed: ${passedCount}'></div>\n  <div class='bar-fail' style='width:${failedCount/totalCount*100}%' title='Failed: ${failedCount}'></div>\n  <div class='bar-crash' style='width:${crashedCount/totalCount*100}%' title='No Run: ${crashedCount}'></div>\n  <div class='bar-skipped' style='width:${skippedCount/totalCount*100}%' title='Skipped: ${skippedCount}'></div>\n</div>\n<table>\n<thead><tr><th>Test Name</th><th>Result</th><th>Run Time</th><th>Screenshot</th></tr></thead>\n<tbody>\n`;

  let errorId = 0;
  for (const r of testResults) {
    let resultClass, resultText;
    if (r.passed) {
      resultClass = 'pass';
      resultText = 'PASS';
    } else if (r.crashed) {
      resultClass = 'crash';
      resultText = 'NO RUN';
    } else if (r.errorMsg === 'Skipped due to header-loads failure.') {
      resultClass = 'skipped';
      resultText = 'SKIPPED';
    } else {
      resultClass = 'fail';
      resultText = 'FAIL';
    }
    let runTime = '';
    if (typeof r.durationMs === 'number') {
      const seconds = r.durationMs / 1000;
      if (seconds >= 60) {
        runTime = (seconds / 60).toFixed(1) + ' min';
      } else {
        runTime = seconds.toFixed(2) + 's';
      }
    }
    
    let screenshotLink = '';
    if (r.screenshotPath && fs.existsSync(r.screenshotPath)) {
      const relPath = path.relative(resultsDir, r.screenshotPath).replace(/\\/g, '/');
      screenshotLink = `<a href='${relPath}' target='_blank'>View</a>`;
    }
    
    let testNameCell = r.name;
    if (!r.passed && r.errorMsg && resultClass !== 'skipped') {
      const idPrefix = governanceType ? `${governanceType}-` : '';
      const onclickHandler = governanceType 
        ? `onclick="toggleError('${governanceType}', ${errorId})"` 
        : `onclick='toggleError(${errorId})'`;
      testNameCell += ` <span id='${idPrefix}error-link-${errorId}' class='error-link' ${onclickHandler}>(show error)</span>`;
    }
    
    html += `<tr class='data-row'><td>${testNameCell}</td><td class='${resultClass}'>${resultText}</td><td>${runTime}</td><td>${screenshotLink}</td></tr>\n`;
    
    if (!r.passed && r.errorMsg && resultClass !== 'skipped') {
      const idPrefix = governanceType ? `${governanceType}-` : '';
      html += `<tr><td colspan='4'><div id='${idPrefix}error-details-${errorId}' class='error-details'>${r.errorMsg.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div></td></tr>\n`;
      errorId++;
    }
  }
  
  html += `</tbody></table>\n</body>\n</html>\n`;
  
  const htmlSummaryPath = path.join(resultsDir, 'test-results-summary.html');
  fs.writeFileSync(htmlSummaryPath, html);
}

export async function generateCombinedSummary(
  resultsByGov: Record<string, Record<string, { result: string, runTime: string, screenshot: string }>>,
  allTestNames: Set<string>,
  wallClockStart: number,
  firstTimestamp: string,
  totalPassed: number,
  totalCount: number,
  totalFailed: number,
  totalCrashed: number,
  totalSkipped: number,
  totalDuration: number,
  resultsDir: string,
  allSummaries: string[],
  baseUrl?: string
): Promise<void> {
  try {
    const governanceTypes = Object.keys(resultsByGov); // Use actual governance types that have data
    
    const summaryPath = path.join(resultsDir, 'test-results-summary.html');
    const mdSummaryPath = path.join(resultsDir, 'test-results-summary.md');

  // Generate combined HTML
  const percentPassed = totalCount ? (totalPassed / totalCount) * 100 : 0;
  const percentFailed = totalCount ? (totalFailed / totalCount) * 100 : 0;
  const percentCrashed = totalCount ? (totalCrashed / totalCount) * 100 : 0;
  const percentSkipped = totalCount ? (totalSkipped / totalCount) * 100 : 0;
  
  let totalRunTimeStr = '';
  if (totalDuration >= 60) {
    totalRunTimeStr = (totalDuration / 60).toFixed(1) + ' min';
  } else {
    totalRunTimeStr = totalDuration.toFixed(2) + 's';
  }

  const summarySection = `
  <h2>All Governance Test Results Summary</h2>
  <p><b>Start Timestamp:</b> ${firstTimestamp}</p>
  ${baseUrl ? `<p><b>Base URL:</b> ${baseUrl}</p>\n  ` : ''}<p><b>Cumulative run time:</b> ${totalRunTimeStr}</p>
  <p><b>${totalPassed}/${totalCount} tests passed</b></p>
  <div class='bar-container'>
    <div class='bar-pass' style='width:${percentPassed}%' title='Passed: ${totalPassed}'></div>
    <div class='bar-fail' style='width:${percentFailed}%' title='Failed: ${totalFailed}'></div>
    <div class='bar-crash' style='width:${percentCrashed}%' title='No Run: ${totalCrashed}'></div>
    <div class='bar-skipped' style='width:${percentSkipped}%' title='Skipped: ${totalSkipped}'></div>
  </div>
  `;

  // Read individual HTML summaries and combine them
  // HTML summaries are now passed in as a parameter

  const combinedHtml = `<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><title>All Governance Test Results</title>
  <style>
  body { font-family: Arial, sans-serif; background: #fafbfc; color: #222; }
  .bar-container { width: 100%; height: 24px; background: #eee; border-radius: 6px; overflow: hidden; margin: 18px 0 10px 0; border: 1px solid #ccc; display: flex; }
  .bar-pass { background: #228B22; height: 100%; }
  .bar-fail { background: #B22222; height: 100%; }
  .bar-crash { background: #666; height: 100%; }
  .bar-skipped { background: #b59a00; height: 100%; }
  </style>
  <script>
  function toggleError(gov, id) {
    var details = document.getElementById(gov + '-error-details-' + id);
    var link = document.getElementById(gov + '-error-link-' + id);
    if (details.style.display === 'block') {
      details.style.display = 'none';
      link.textContent = '(show error)';
    } else {
      details.style.display = 'block';
      link.textContent = '(hide error)';
    }
  }
  </script>
  </head><body>\n${summarySection}\n${allSummaries.join('<hr style=\"margin:2em 0\">')}\n</body></html>`;
  
  fs.writeFileSync(summaryPath, combinedHtml);

  // Generate combined Markdown
  const governanceOnlyTypes = governanceTypes.filter(g => g !== 'general');
  const govHeaders = governanceOnlyTypes.map(g => g.toUpperCase());
  
  // Separate general tests from governance-specific tests
  const generalTests = new Set<string>();
  const governanceTests = new Set<string>();
  
  for (const testName of allTestNames) {
    if (resultsByGov['general'] && resultsByGov['general'][testName]) {
      generalTests.add(testName);
    } else {
      governanceTests.add(testName);
    }
  }
  
  // Calculate summary stats first - need to count tests first
  let mdTotalPassed = 0;
  let mdTotalCount = 0;
  
  // Count general tests
  if (resultsByGov['general']) {
    for (const testName of generalTests) {
      const r = resultsByGov['general'][testName];
      if (r) {
        mdTotalCount++;
        if (r.result.includes('✅')) mdTotalPassed++;
      }
    }
  }
  
  // Count governance-specific tests
  for (const testName of governanceTests) {
    let testPassedCount = 0;
    let testRunCount = 0;
    
    for (const gov of governanceOnlyTypes) {
      const govResults = resultsByGov[gov];
      const r = govResults ? govResults[testName] : undefined;
      if (r) {
        testRunCount++;
        if (r.result.includes('✅')) testPassedCount++;
      }
    }
    mdTotalPassed += testPassedCount;
    mdTotalCount += testRunCount;
  }
  
  const wallClockEnd = Date.now();
  const wallClockDuration = wallClockEnd - wallClockStart;
  let wallClockRunTimeStr = '';
  if (wallClockDuration >= 60 * 1000) {
    wallClockRunTimeStr = (wallClockDuration / 1000 / 60).toFixed(1) + ' min';
  } else {
    wallClockRunTimeStr = (wallClockDuration / 1000).toFixed(2) + 's';
  }
  
  const baseUrlLine = baseUrl ? `**Base URL:** ${baseUrl}  \n` : '';
  const mdSummaryStats = `${baseUrlLine}**Summary:** ${mdTotalPassed}/${mdTotalCount} tests passed | Total runtime: ${wallClockRunTimeStr}\n\n`;
  
  // Build markdown
  let combinedMd = `# 🧪 UI Automation Test Results\n\n**Start Timestamp:** ${firstTimestamp}  \n`;
  combinedMd += mdSummaryStats;
  combinedMd += `> 📸 Download all screenshots from the workflow artifacts above. \nExtract the test results file and open the html summary to quickly review results and screenshots.\n\n`;

  combinedMd += `<details>`
  combinedMd += `<summary>Click to expand full test results</summary>`;
  
  combinedMd += `\n\n**Legend:**\n`;
  combinedMd += `\n- Each cell shows: result (✅/❌), run time, and screenshot status.\n`;
  combinedMd += `- ✅ = Passed, ❌ = Failed, ⚪ = No Run, ⚠️ = Skipped\n`;
  combinedMd += `- Example: \`✅ (2.29s, Available)\` means the test passed, took 2.29 seconds, and a screenshot is available.\n`;
  combinedMd += `- \`N/A\` means the test was not run for that governance type.\n\n`;
  
  // Generate General Tests Table (if any general tests exist)
  if (generalTests.size > 0) {
    combinedMd += `## General Tests\n\n`;
    combinedMd += `| Test Name | Result |\n|---|---|\n`;
    
    const sortedGeneralTests = Array.from(generalTests).sort();
    for (const testName of sortedGeneralTests) {
      const r = resultsByGov['general'][testName];
      if (r) {
        let cell = `${r.result}`;
        if (r.runTime) cell += ` (${r.runTime}`;
        if (r.screenshot && r.screenshot !== '') cell += `, ${r.screenshot}`;
        if (r.runTime) cell += ')';
        combinedMd += `| ${testName} | ${cell} |\n`;
      }
    }
    combinedMd += `\n`;
  }
  
  // Generate Governance-Specific Tests Table (if any governance tests exist)
  if (governanceTests.size > 0) {
    combinedMd += `## Governance-Specific Tests\n\n`;
    combinedMd += `| Test Name | ${govHeaders.join(' | ')} |\n|---|${govHeaders.map(()=>'---').join('|')}|\n`;
    
    const sortedGovernanceTests = Array.from(governanceTests).sort();
    for (const testName of sortedGovernanceTests) {
      const row = [testName];
      
      for (const gov of governanceOnlyTypes) {
        const govResults = resultsByGov[gov];
        const r = govResults ? govResults[testName] : undefined;
        if (r) {
          let cell = `${r.result}`;
          if (r.runTime) cell += ` (${r.runTime}`;
          if (r.screenshot && r.screenshot !== '') cell += `, ${r.screenshot}`;
          if (r.runTime) cell += ')';
          row.push(cell);
        } else {
          row.push('N/A');
        }
      }
      combinedMd += `| ${row.join(' | ')} |\n`;
    }
  }

  combinedMd += `</details>`;
  combinedMd += `\n\n---\n*Generated by UI automation workflow.*\n`;

  fs.writeFileSync(mdSummaryPath, combinedMd);

  // Small delay to ensure all other processes complete
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Write the combined markdown again to ensure it's not overwritten
  fs.writeFileSync(mdSummaryPath, combinedMd);

  // Open the combined summary
  if (process.platform === 'win32') {
    require('child_process').spawn('cmd', ['/c', 'start', '', summaryPath], { stdio: 'ignore', detached: true });
  } else {
    const openCmd = process.platform === 'darwin' ? 'open' : 'xdg-open';
    require('child_process').spawn(openCmd, [summaryPath], { stdio: 'ignore', detached: true });
  }
  
  // Small delay to ensure file operations complete
  await new Promise(resolve => setTimeout(resolve, 500));
  
  } catch (error) {
    console.error('Error generating combined summary:', error);
    throw error;
  }
}
