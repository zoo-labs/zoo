import { AxiosRequestConfig, AxiosResponse } from "axios";
import { Signer } from "ethers";
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */
export interface paths {
    "/activity/v1": {
        /** This API can be used to scrape all of the activities */
        get: operations["getActivityV1"];
    };
    "/activity/v2": {
        /** This API can be used to scrape all of the activities */
        get: operations["getActivityV2"];
    };
    "/activity/v3": {
        /** This API can be used to scrape all of the activities */
        get: operations["getActivityV3"];
    };
    "/activity/v4": {
        /** This API can be used to scrape all of the activities */
        get: operations["getActivityV4"];
    };
    "/admin/get-marketplaces": {
        get: operations["getAdminGetmarketplaces"];
    };
    "/admin/open-api": {
        get: operations["getAdminOpenapi"];
    };
    "/admin/rate-limit-rules": {
        get: operations["getAdminRatelimitrules"];
    };
    "/assets/v1": {
        get: operations["getAssetsV1"];
    };
    "/attributes/v1": {
        get: operations["getAttributesV1"];
    };
    "/collection/v1": {
        /** Get detailed information about a single collection, including real-time stats. */
        get: operations["getCollectionV1"];
    };
    "/collection/v2": {
        /** Get detailed information about a single collection, including real-time stats. */
        get: operations["getCollectionV2"];
    };
    "/collection/v3": {
        /** Get detailed information about a single collection, including real-time stats. */
        get: operations["getCollectionV3"];
    };
    "/collections/v1": {
        /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
        get: operations["getCollectionsV1"];
    };
    "/collections/v2": {
        /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
        get: operations["getCollectionsV2"];
    };
    "/collections/v3": {
        /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
        get: operations["getCollectionsV3"];
    };
    "/collections/v4": {
        /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
        get: operations["getCollectionsV4"];
    };
    "/collections/v5": {
        /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
        get: operations["getCollectionsV5"];
    };
    "/orders/v1": {
        /** Access orders with various filters applied. If you need orders created by a single user, use the positions API instead. */
        get: operations["getOrdersV1"];
        post: operations["postOrdersV1"];
    };
    "/orders/v2": {
        /** Access orders with various filters applied. If you need orders created by a single user, use the positions API instead. */
        get: operations["getOrdersV2"];
    };
    "/owners/v1": {
        /** Get owners with various filters applied, and a summary of their ownership. Useful for exploring top owners in a collection or attribute. */
        get: operations["getOwnersV1"];
    };
    "/sales/v1": {
        /** Get recent sales for a contract or token. */
        get: operations["getSalesV1"];
    };
    "/sales/v2": {
        /** Get recent sales for a contract or token. */
        get: operations["getSalesV2"];
    };
    "/sales/v3": {
        /** Get recent sales for a contract or token. Note: this API is returns rich metadata, and has advanced filters, so is only designed for small amounts of recent sales. If you want access to sales in bulk, use the `Aggregator > Bulk Sales` API. */
        get: operations["getSalesV3"];
    };
    "/sales/v4": {
        /** Get recent sales for a contract or token. */
        get: operations["getSalesV4"];
    };
    "/sources/v1": {
        /** This API returns a list of sources */
        get: operations["getSourcesV1"];
    };
    "/stats/v1": {
        /** Get aggregate stats for a particular set (collection, attribute or single token) */
        get: operations["getStatsV1"];
    };
    "/stats/v2": {
        /** Get aggregate stats for a particular set (collection, attribute or single token) */
        get: operations["getStatsV2"];
    };
    "/tokens/v1": {
        /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
        get: operations["getTokensV1"];
    };
    "/tokens/v2": {
        /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
        get: operations["getTokensV2"];
    };
    "/tokens/v3": {
        /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
        get: operations["getTokensV3"];
    };
    "/tokens/v4": {
        /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the tokens/details API */
        get: operations["getTokensV4"];
    };
    "/tokens/v5": {
        /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. */
        get: operations["getTokensV5"];
    };
    "/transfers/v2": {
        /** Get recent transfers for a contract or token. */
        get: operations["getTransfersV2"];
    };
    "/admin/get-api-key/{key}": {
        get: operations["getAdminGetapikeyKey"];
    };
    "/api-keys/{key}/rate-limits": {
        /** Get the rate limits for the given API key */
        get: operations["getApikeysKeyRatelimits"];
    };
    "/collections/activity/v4": {
        /** This API can be used to build a feed for a collection */
        get: operations["getCollectionsActivityV4"];
    };
    "/collections/activity/v5": {
        /** This API can be used to build a feed for a collection */
        get: operations["getCollectionsActivityV5"];
    };
    "/collections/daily-volumes/v1": {
        /** Get date, volume, rank and sales count for each collection */
        get: operations["getCollectionsDailyvolumesV1"];
    };
    "/collections/sources/v1": {
        /** This API returns aggregated listings info for the given collection per source */
        get: operations["getCollectionsSourcesV1"];
    };
    "/collections/{collectionOrSlug}/v1": {
        /** Get detailed information about a single collection, including real-time stats. */
        get: operations["getCollectionsCollectionorslugV1"];
    };
    "/events/asks/v2": {
        /** Get updates any time an asks status changes */
        get: operations["getEventsAsksV2"];
    };
    "/events/asks/v3": {
        /** Get updates any time an asks status changes */
        get: operations["getEventsAsksV3"];
    };
    "/events/bids/v1": {
        /** Get updates any time a bid status changes */
        get: operations["getEventsBidsV1"];
    };
    "/events/bids/v2": {
        /** Get updates any time a bid status changes */
        get: operations["getEventsBidsV2"];
    };
    "/events/bids/v3": {
        /** Get updates any time a bid status changes */
        get: operations["getEventsBidsV3"];
    };
    "/events/orders/v1": {
        /** Get updates any time an order status changes */
        get: operations["getEventsOrdersV1"];
    };
    "/execute/bid/v2": {
        /** Generate a bid and submit it to multiple marketplaces */
        get: operations["getExecuteBidV2"];
    };
    "/execute/buy/v2": {
        get: operations["getExecuteBuyV2"];
    };
    "/execute/buy/v3": {
        get: operations["getExecuteBuyV3"];
    };
    "/execute/cancel/v1": {
        /** Cancel an existing order on any marketplace */
        get: operations["getExecuteCancelV1"];
    };
    "/execute/cancel/v2": {
        /** Cancel an existing order on any marketplace */
        get: operations["getExecuteCancelV2"];
    };
    "/execute/list/v2": {
        /** Generate a listing and submit it to multiple marketplaces */
        get: operations["getExecuteListV2"];
    };
    "/execute/sell/v3": {
        get: operations["getExecuteSellV3"];
    };
    "/liquidity/users/v1": {
        /** This API calculates the total liquidity created by users, based on the number of tokens they are top bidder for. */
        get: operations["getLiquidityUsersV1"];
    };
    "/liquidity/users/v2": {
        /** This API calculates the total liquidity created by users, based on the number of tokens they are top bidder for. */
        get: operations["getLiquidityUsersV2"];
    };
    "/orders/all/v1": {
        /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersAllV1"];
    };
    "/orders/all/v2": {
        /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersAllV2"];
    };
    "/orders/asks/v1": {
        /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersAsksV1"];
    };
    "/orders/asks/v2": {
        /** Get a list of asks (listings), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersAsksV2"];
    };
    "/orders/asks/v3": {
        /** Get a list of asks (listings), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersAsksV3"];
    };
    "/orders/asks/v4": {
        /** Get a list of asks (listings), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersAsksV4"];
    };
    "/orders/bids/v1": {
        /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersBidsV1"];
    };
    "/orders/bids/v2": {
        /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersBidsV2"];
    };
    "/orders/bids/v3": {
        /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersBidsV3"];
    };
    "/orders/bids/v4": {
        /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersBidsV4"];
    };
    "/orders/bids/v5": {
        /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
        get: operations["getOrdersBidsV5"];
    };
    "/orders/executed/v1": {
        get: operations["getOrdersExecutedV1"];
    };
    "/owners/common-collections/v1": {
        /** This API can be used to find top common collections among the given owners */
        get: operations["getOwnersCommoncollectionsV1"];
    };
    "/owners/cross-collections/v1": {
        /** Find which addresses own the most of a group of collections. */
        get: operations["getOwnersCrosscollectionsV1"];
    };
    "/redirect/logo/v1": {
        get: operations["getRedirectLogoV1"];
    };
    "/redirect/token/v1": {
        get: operations["getRedirectTokenV1"];
    };
    "/sales/bulk/v1": {
        /** Note: this API is optimized for bulk access, and offers minimal filters/metadata. If you need more flexibility, try the `NFT API > Sales` endpoint */
        get: operations["getSalesBulkV1"];
    };
    "/search/collections/v1": {
        get: operations["getSearchCollectionsV1"];
    };
    "/tokens/bootstrap/v1": {
        /** Get the latest price event per token in a collection, so that you can listen to future events and keep track of prices */
        get: operations["getTokensBootstrapV1"];
    };
    "/tokens/details/v2": {
        /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
        get: operations["getTokensDetailsV2"];
    };
    "/tokens/details/v3": {
        /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
        get: operations["getTokensDetailsV3"];
    };
    "/tokens/details/v4": {
        /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
        get: operations["getTokensDetailsV4"];
    };
    "/tokens/floor/v1": {
        /** This API will return the best price of every token in a collection that is currently on sale. Note: Prices are returned in the native currency of the network. */
        get: operations["getTokensFloorV1"];
    };
    "/tokens/ids/v1": {
        /** This API is optimized for quickly fetching a list of tokens ids in by collection, contract, token set id. */
        get: operations["getTokensIdsV1"];
    };
    "/transfers/bulk/v1": {
        /** Note: this API is optimized for bulk access, and offers minimal filters/metadata. If you need more flexibility, try the `NFT API > Transfers` endpoint */
        get: operations["getTransfersBulkV1"];
    };
    "/users/activity/v2": {
        /** This API can be used to build a feed for a user */
        get: operations["getUsersActivityV2"];
    };
    "/users/activity/v3": {
        /** This API can be used to build a feed for a user */
        get: operations["getUsersActivityV3"];
    };
    "/users/activity/v4": {
        /** This API can be used to build a feed for a user */
        get: operations["getUsersActivityV4"];
    };
    "/users/activity/v5": {
        /** This API can be used to build a feed for a user */
        get: operations["getUsersActivityV5"];
    };
    "/collections/{collection}/attributes/v1": {
        get: operations["getCollectionsCollectionAttributesV1"];
    };
    "/collections/{collection}/activity/v2": {
        /** This API can be used to build a feed for a collection */
        get: operations["getCollectionsCollectionActivityV2"];
    };
    "/collections/{collection}/activity/v1": {
        /** This API can be used to build a feed for a collection */
        get: operations["getCollectionsCollectionActivityV1"];
    };
    "/collections/{collection}/activity/v3": {
        /** This API can be used to build a feed for a collection */
        get: operations["getCollectionsCollectionActivityV3"];
    };
    "/collections/{collection}/top-bids/v1": {
        /** When users are placing collection or trait bids, this API can be used to show them where the bid is in the context of other bids, and how many tokens it will be the top bid for. */
        get: operations["getCollectionsCollectionTopbidsV1"];
    };
    "/collections/{collection}/owners-distribution/v1": {
        /** This API can be used to show what the distribution of owners in a collection looks like. */
        get: operations["getCollectionsCollectionOwnersdistributionV1"];
    };
    "/collections-sets/{collectionsSetId}/owners-distribution/v1": {
        /** This API can be used to show what the distribution of owners in a collections set looks like. */
        get: operations["getCollectionssetsCollectionssetidOwnersdistributionV1"];
    };
    "/events/collections/floor-ask/v1": {
        /**
         * Every time the floor price of a collection changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
         *
         * There are multiple event types, which describe what caused the change in price:
         *
         * - `new-order` > new listing at a lower price
         *
         * - `expiry` > the previous best listing expired
         *
         * - `sale` > the previous best listing was filled
         *
         * - `cancel` > the previous best listing was cancelled
         *
         * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
         *
         * - `approval-change` > the best listing was invalidated due to revoked approval
         *
         * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
         *
         * - `reprice` > price update for dynamic orders (e.g. dutch auctions)
         *
         * - `bootstrap` > initial loading of data, so that all tokens have a price associated
         *
         * Some considerations to keep in mind
         *
         * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
         *
         * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
         */
        get: operations["getEventsCollectionsFlooraskV1"];
    };
    "/events/collections/top-bid/v1": {
        /** Every time the top offer of a collection changes (i.e. the 'top bid'), an event is generated. This API is designed to be polled at high frequency. */
        get: operations["getEventsCollectionsTopbidV1"];
    };
    "/events/collections/top-bid/v2": {
        /** Every time the top offer of a collection changes (i.e. the 'top bid'), an event is generated. This API is designed to be polled at high frequency. */
        get: operations["getEventsCollectionsTopbidV2"];
    };
    "/events/tokens/floor-ask/v2": {
        /**
         * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
         *
         * There are multiple event types, which describe what caused the change in price:
         *
         * - `new-order` > new listing at a lower price
         *
         * - `expiry` > the previous best listing expired
         *
         * - `sale` > the previous best listing was filled
         *
         * - `cancel` > the previous best listing was cancelled
         *
         * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
         *
         * - `approval-change` > the best listing was invalidated due to revoked approval
         *
         * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
         *
         * - `reprice` > price update for dynamic orders (e.g. dutch auctions)
         *
         * - `bootstrap` > initial loading of data, so that all tokens have a price associated
         *
         * Some considerations to keep in mind
         *
         * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
         *
         * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
         */
        get: operations["getEventsTokensFlooraskV2"];
    };
    "/events/tokens/floor-ask/v3": {
        /**
         * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
         *
         * There are multiple event types, which describe what caused the change in price:
         *
         * - `new-order` > new listing at a lower price
         *
         * - `expiry` > the previous best listing expired
         *
         * - `sale` > the previous best listing was filled
         *
         * - `cancel` > the previous best listing was cancelled
         *
         * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
         *
         * - `approval-change` > the best listing was invalidated due to revoked approval
         *
         * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
         *
         * - `reprice` > price update for dynamic orders (e.g. dutch auctions)
         *
         * - `bootstrap` > initial loading of data, so that all tokens have a price associated
         *
         * Some considerations to keep in mind
         *
         * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
         *
         * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
         */
        get: operations["getEventsTokensFlooraskV3"];
    };
    "/oracle/collections/floor-ask/v4": {
        /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
        get: operations["getOracleCollectionsFlooraskV4"];
    };
    "/oracle/collections/floor-ask/v5": {
        /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0xAeB1D03929bF87F69888f381e73FBf75753d75AF. */
        get: operations["getOracleCollectionsFlooraskV5"];
    };
    "/oracle/collections/top-bid/v1": {
        /** Get a signed message of any collection's top bid price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
        get: operations["getOracleCollectionsTopbidV1"];
    };
    "/oracle/collections/top-bid/v2": {
        /** Get a signed message of any collection's top bid price (spot or twap). The oracle's address is 0xAeB1D03929bF87F69888f381e73FBf75753d75AF. */
        get: operations["getOracleCollectionsTopbidV2"];
    };
    "/oracle/tokens/status/v1": {
        /** Get a signed message of a token's details (flagged status and last transfer time). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
        get: operations["getOracleTokensStatusV1"];
    };
    "/oracle/tokens/status/v2": {
        /** Get a signed message of a token's details (flagged status and last transfer time). The oracle's address is 0xAeB1D03929bF87F69888f381e73FBf75753d75AF. */
        get: operations["getOracleTokensStatusV2"];
    };
    "/tokens/flag/changes/v1": {
        /** This API return the recent flagged/un-flagged tokens across all collections sorted by change time */
        get: operations["getTokensFlagChangesV1"];
    };
    "/tokens/{token}/activity/v3": {
        /** This API can be used to build a feed for a token */
        get: operations["getTokensTokenActivityV3"];
    };
    "/tokens/{token}/activity/v1": {
        /** This API can be used to build a feed for a token */
        get: operations["getTokensTokenActivityV1"];
    };
    "/tokens/{token}/activity/v2": {
        /** This API can be used to build a feed for a token */
        get: operations["getTokensTokenActivityV2"];
    };
    "/tokens/{token}/activity/v4": {
        /** This API can be used to build a feed for a token */
        get: operations["getTokensTokenActivityV4"];
    };
    "/transactions/{txHash}/synced/v1": {
        /** Get a boolean response on whether a particular transaction was synced or not. */
        get: operations["getTransactionsTxhashSyncedV1"];
    };
    "/users/{user}/tokens/v6": {
        /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
        get: operations["getUsersUserTokensV6"];
    };
    "/users/{user}/tokens/v4": {
        /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
        get: operations["getUsersUserTokensV4"];
    };
    "/users/{user}/tokens/v2": {
        /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
        get: operations["getUsersUserTokensV2"];
    };
    "/users/{user}/positions/v1": {
        /** Get aggregate user liquidity, grouped by collection. Useful for showing a summary of liquidity being provided (orders made). */
        get: operations["getUsersUserPositionsV1"];
    };
    "/users/{user}/collections/v1": {
        /** Get aggregate stats for a user, grouped by collection. Useful for showing total portfolio information. */
        get: operations["getUsersUserCollectionsV1"];
    };
    "/users/{user}/activity/v1": {
        /** This API can be used to build a feed for a user */
        get: operations["getUsersUserActivityV1"];
    };
    "/users/{user}/collections/v2": {
        /** Get aggregate stats for a user, grouped by collection. Useful for showing total portfolio information. */
        get: operations["getUsersUserCollectionsV2"];
    };
    "/users/{user}/tokens/v1": {
        /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
        get: operations["getUsersUserTokensV1"];
    };
    "/users/{user}/tokens/v3": {
        /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
        get: operations["getUsersUserTokensV3"];
    };
    "/users/{user}/tokens/v5": {
        /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
        get: operations["getUsersUserTokensV5"];
    };
    "/collections/{collection}/attributes/explore/v4": {
        /** Get detailed aggregate about attributes in a collection, attribute floors */
        get: operations["getCollectionsCollectionAttributesExploreV4"];
    };
    "/collections/{collection}/attributes/explore/v2": {
        /** Get detailed aggregate about attributes in a collection, attribute floors */
        get: operations["getCollectionsCollectionAttributesExploreV2"];
    };
    "/collections/{collection}/attributes/all/v2": {
        get: operations["getCollectionsCollectionAttributesAllV2"];
    };
    "/collections/{collection}/attributes/all/v1": {
        get: operations["getCollectionsCollectionAttributesAllV1"];
    };
    "/collections/{collection}/attributes/static/v1": {
        get: operations["getCollectionsCollectionAttributesStaticV1"];
    };
    "/collections/{collection}/attributes/explore/v1": {
        get: operations["getCollectionsCollectionAttributesExploreV1"];
    };
    "/collections/{collection}/attributes/explore/v3": {
        /** Get detailed aggregate about attributes in a collection, attribute floors */
        get: operations["getCollectionsCollectionAttributesExploreV3"];
    };
    "/oracle/collections/{collection}/floor-ask/v2": {
        /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
        get: operations["getOracleCollectionsCollectionFlooraskV2"];
    };
    "/oracle/collections/{collection}/floor-ask/v1": {
        /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
        get: operations["getOracleCollectionsCollectionFlooraskV1"];
    };
    "/oracle/collections/{collection}/floor-ask/v3": {
        /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
        get: operations["getOracleCollectionsCollectionFlooraskV3"];
    };
    "/orders/users/{user}/top-bids/v2": {
        /** Return the top bids for the given user tokens */
        get: operations["getOrdersUsersUserTopbidsV2"];
    };
    "/orders/users/{user}/top-bids/v1": {
        /** Return the top bids for the given user tokens */
        get: operations["getOrdersUsersUserTopbidsV1"];
    };
    "/orders/users/{user}/top-bids/v3": {
        /** Return the top bids for the given user tokens */
        get: operations["getOrdersUsersUserTopbidsV3"];
    };
    "/redirect/collections/{collection}/image/v1": {
        get: operations["getRedirectCollectionsCollectionImageV1"];
    };
    "/redirect/currency/{address}/icon/v1": {
        get: operations["getRedirectCurrencyAddressIconV1"];
    };
    "/redirect/sources/{source}/logo/v2": {
        get: operations["getRedirectSourcesSourceLogoV2"];
    };
    "/redirect/tokens/{token}/image/v1": {
        get: operations["getRedirectTokensTokenImageV1"];
    };
    "/redirect/sources/{source}/tokens/{token}/link/v2": {
        get: operations["getRedirectSourcesSourceTokensTokenLinkV2"];
    };
    "/collections/{collection}/community/v1": {
        put: operations["putCollectionsCollectionCommunityV1"];
    };
    "/api-keys": {
        /**
         * The API key can be used in every route, by setting it as a request header **x-api-key**.
         *
         * <a href='https://docs.reservoir.tools/reference/getting-started'>Learn more</a> about API Keys and Rate Limiting
         */
        post: operations["postApikeys"];
    };
    "/admin/calc-rarity": {
        post: operations["postAdminCalcrarity"];
    };
    "/admin/create-rate-limit-rule": {
        post: operations["postAdminCreateratelimitrule"];
    };
    "/admin/delete-rate-limit-rule": {
        post: operations["postAdminDeleteratelimitrule"];
    };
    "/admin/fix-blocks": {
        post: operations["postAdminFixblocks"];
    };
    "/admin/fix-cache": {
        post: operations["postAdminFixcache"];
    };
    "/admin/fix-orders": {
        post: operations["postAdminFixorders"];
    };
    "/admin/fix-token-cache": {
        post: operations["postAdminFixtokencache"];
    };
    "/admin/flag-address": {
        post: operations["postAdminFlagaddress"];
    };
    "/admin/index-metadata": {
        post: operations["postAdminIndexmetadata"];
    };
    "/admin/refresh-collection": {
        post: operations["postAdminRefreshcollection"];
    };
    "/admin/refresh-collection-flags": {
        post: operations["postAdminRefreshcollectionflags"];
    };
    "/admin/refresh-token": {
        post: operations["postAdminRefreshtoken"];
    };
    "/admin/resync-floor-events": {
        post: operations["postAdminResyncfloorevents"];
    };
    "/admin/resync-source": {
        post: operations["postAdminResyncsource"];
    };
    "/admin/revalidate-order": {
        post: operations["postAdminRevalidateorder"];
    };
    "/admin/routers": {
        post: operations["postAdminRouters"];
    };
    "/admin/set-community": {
        post: operations["postAdminSetcommunity"];
    };
    "/admin/sync-arweave": {
        post: operations["postAdminSyncarweave"];
    };
    "/admin/sync-daily-volumes": {
        post: operations["postAdminSyncdailyvolumes"];
    };
    "/admin/sync-events": {
        post: operations["postAdminSyncevents"];
    };
    "/admin/update-api-key": {
        post: operations["postAdminUpdateapikey"];
    };
    "/admin/update-rate-limit-rule": {
        post: operations["postAdminUpdateratelimitrule"];
    };
    "/admin/update-source": {
        post: operations["postAdminUpdatesource"];
    };
    "/collections-sets/v1": {
        post: operations["postCollectionssetsV1"];
    };
    "/contracts-sets/v1": {
        post: operations["postContractssetsV1"];
    };
    "/order/v2": {
        post: operations["postOrderV2"];
    };
    "/order/v3": {
        post: operations["postOrderV3"];
    };
    "/order/v4": {
        post: operations["postOrderV4"];
    };
    "/seaport/offers": {
        post: operations["postSeaportOffers"];
    };
    "/token-sets/v1": {
        post: operations["postTokensetsV1"];
    };
    "/token-sets/v2": {
        post: operations["postTokensetsV2"];
    };
    "/websocket/user-auth": {
        post: operations["postWebsocketUserauth"];
    };
    "/collections/refresh/v1": {
        post: operations["postCollectionsRefreshV1"];
    };
    "/execute/bid/v4": {
        /** Generate a bid and submit it to multiple marketplaces */
        post: operations["postExecuteBidV4"];
    };
    "/execute/bid/v5": {
        /** Generate bids and submit them to multiple marketplaces */
        post: operations["postExecuteBidV5"];
    };
    "/execute/buy/v4": {
        post: operations["postExecuteBuyV4"];
    };
    "/execute/buy/v5": {
        post: operations["postExecuteBuyV5"];
    };
    "/execute/buy/v6": {
        post: operations["postExecuteBuyV6"];
    };
    "/execute/buy/v7": {
        post: operations["postExecuteBuyV7"];
    };
    "/execute/list/v3": {
        /** Generate a listing and submit it to multiple marketplaces */
        post: operations["postExecuteListV3"];
    };
    "/execute/list/v4": {
        /** Generate a listing and submit it to multiple marketplaces */
        post: operations["postExecuteListV4"];
    };
    "/execute/list/v5": {
        /** Generate listings and submit them to multiple marketplaces */
        post: operations["postExecuteListV5"];
    };
    "/execute/permit-signature/v1": {
        post: operations["postExecutePermitsignatureV1"];
    };
    "/execute/sell/v4": {
        post: operations["postExecuteSellV4"];
    };
    "/execute/sell/v5": {
        post: operations["postExecuteSellV5"];
    };
    "/execute/sell/v6": {
        post: operations["postExecuteSellV6"];
    };
    "/execute/sell/v7": {
        post: operations["postExecuteSellV7"];
    };
    "/tokens/flag/v1": {
        post: operations["postTokensFlagV1"];
    };
    "/tokens/refresh/v1": {
        post: operations["postTokensRefreshV1"];
    };
    "/tokens/simulate-floor/v1": {
        post: operations["postTokensSimulatefloorV1"];
    };
    "/tokens/simulate-top-bid/v1": {
        post: operations["postTokensSimulatetopbidV1"];
    };
    "/management/orders/simulate/v1": {
        post: operations["postManagementOrdersSimulateV1"];
    };
}
export interface definitions {
    source: {
        [key: string]: unknown;
    };
    /** @description Amount of items returned in response. */
    Model1: {
        id?: number;
        type?: string;
        contract?: string;
        collectionId?: string;
        tokenId?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        source?: definitions["source"];
    };
    activities: definitions["Model1"][];
    getActivityV1Response: {
        /** @description Use continuation token to request next offset of items. */
        continuation?: number;
        activities?: definitions["activities"];
    };
    order: {
        id?: string;
        /** @enum {string} */
        side?: "ask" | "bid";
        source?: definitions["source"];
    };
    /** @description Amount of items returned in response. */
    Model2: {
        id?: number;
        type?: string;
        contract?: string;
        collectionId?: string;
        tokenId?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["order"];
    };
    Model3: definitions["Model2"][];
    getActivityV2Response: {
        /** @description Use continuation token to request next offset of items. */
        continuation?: number;
        activities?: definitions["Model3"];
    };
    data: {
        collectionId?: string;
        collectionName?: string;
        tokenName?: string;
        image?: string;
    };
    Model4: {
        /** @enum {string} */
        kind?: "token";
        data?: definitions["data"];
    };
    Model5: {
        id?: string;
        /** @enum {string} */
        side?: "ask" | "bid";
        source?: definitions["source"];
        metadata?: definitions["Model4"];
    };
    /** @description Amount of items returned in response. */
    Model6: {
        id?: number;
        type?: string;
        contract?: string;
        collectionId?: string;
        tokenId?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["Model5"];
    };
    Model7: definitions["Model6"][];
    getActivityV3Response: {
        continuation?: string;
        activities?: definitions["Model7"];
    };
    token: {
        tokenId?: string;
        name?: string;
        image?: string;
    };
    collection: {
        id?: string;
        name?: string;
        image?: string;
    };
    Model8: {
        token?: definitions["token"];
        collection?: definitions["collection"];
    };
    Model9: {
        /** @enum {string} */
        kind?: "token";
        data?: definitions["Model8"];
    };
    Model10: {
        id?: string;
        /** @enum {string} */
        side?: "ask" | "bid";
        source?: definitions["source"];
        criteria?: definitions["Model9"];
    };
    /** @description Amount of items returned in response. */
    Model11: {
        id?: number;
        type?: string;
        contract?: string;
        collectionId?: string;
        tokenId?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["Model10"];
    };
    Model12: definitions["Model11"][];
    getActivityV4Response: {
        continuation?: string;
        activities?: definitions["Model12"];
    };
    fee: {
        bps?: number;
        percent?: number;
    };
    Model13: {
        name?: string;
        imageUrl?: string;
        fee?: definitions["fee"];
        feeBps?: number;
        orderbook?: string;
        orderKind?: string;
        listingEnabled?: boolean;
    };
    marketplaces: definitions["Model13"][];
    getMarketplacesv1Resp: {
        marketplaces?: definitions["marketplaces"];
    };
    Model14: {
        value: string;
        count?: number;
    };
    values: definitions["Model14"][];
    Model15: {
        key: string;
        /** @enum {string} */
        kind: "string" | "number" | "date" | "range";
        values?: definitions["values"];
    };
    attributes: definitions["Model15"][];
    getAttributesV1Response: {
        attributes?: definitions["attributes"];
    };
    sampleImages: string[];
    royalties: {
        recipient?: string;
        bps?: number;
    };
    lastBuy: {
        value?: number;
        timestamp?: number;
    };
    Model16: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
    };
    floorAsk: {
        id?: string;
        price?: number;
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        token?: definitions["Model16"];
    };
    topBid: {
        id?: string;
        value?: number;
        maker?: string;
        validFrom?: number;
        validUntil?: number;
    };
    rank: {
        "1day"?: number;
        "7day"?: number;
        "30day"?: number;
        allTime?: number;
    };
    volumeChange: {
        "1day"?: number;
        "7day"?: number;
        "30day"?: number;
    };
    Model17: {
        id?: string;
        slug?: string;
        name?: string;
        metadata?: definitions["source"];
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        onSaleCount?: string;
        primaryContract?: string;
        tokenSetId?: string;
        royalties?: definitions["royalties"];
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        floorAsk?: definitions["floorAsk"];
        topBid?: definitions["topBid"];
        rank?: definitions["rank"];
        volume?: definitions["rank"];
        volumeChange?: definitions["volumeChange"];
        floorSale?: definitions["volumeChange"];
        floorSaleChange?: definitions["volumeChange"];
    };
    getCollectionV1Response: {
        collection?: definitions["Model17"];
    };
    Model18: {
        key?: string;
        kind?: string;
        count?: number;
    };
    Model19: definitions["Model18"][];
    Model20: {
        id?: string;
        /** @description Open Sea slug */
        slug?: string;
        name?: string;
        metadata?: definitions["source"];
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        onSaleCount?: string;
        primaryContract?: string;
        tokenSetId?: string;
        royalties?: definitions["royalties"];
        lastBuy?: definitions["lastBuy"];
        floorAsk?: definitions["floorAsk"];
        topBid?: definitions["topBid"];
        rank?: definitions["rank"];
        volume?: definitions["rank"];
        volumeChange?: definitions["volumeChange"];
        floorSale?: definitions["volumeChange"];
        floorSaleChange?: definitions["volumeChange"];
        collectionBidSupported?: boolean;
        ownerCount?: number;
        attributes?: definitions["Model19"];
    };
    getCollectionV2Response: {
        collection?: definitions["Model20"];
    };
    Model21: {
        id?: string;
        sourceDomain?: string;
        price?: number;
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        token?: definitions["Model16"];
    };
    Model22: {
        id?: string;
        /** @description Open Sea slug */
        slug?: string;
        name?: string;
        metadata?: definitions["source"];
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        onSaleCount?: string;
        primaryContract?: string;
        tokenSetId?: string;
        royalties?: definitions["royalties"];
        lastBuy?: definitions["lastBuy"];
        floorAsk?: definitions["Model21"];
        topBid?: definitions["topBid"];
        rank?: definitions["rank"];
        volume?: definitions["rank"];
        volumeChange?: definitions["volumeChange"];
        floorSale?: definitions["volumeChange"];
        floorSaleChange?: definitions["volumeChange"];
        collectionBidSupported?: boolean;
        ownerCount?: number;
        attributes?: definitions["Model19"];
    };
    getCollectionV3Response: {
        collection?: definitions["Model22"];
    };
    Model23: {
        id?: string;
        slug?: string;
        name?: string;
        metadata?: definitions["source"];
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        tokenSetId?: string;
        royalties?: definitions["royalties"];
        floorAskPrice?: number;
        topBidValue?: number;
        topBidMaker?: string;
        rank?: definitions["rank"];
        volume?: definitions["rank"];
    };
    collections: definitions["Model23"][];
    getCollectionsV1Response: {
        collections?: definitions["collections"];
    };
    Model24: {
        id?: string;
        slug?: string;
        name?: string;
        image?: string;
        banner?: string;
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        tokenSetId?: string;
        primaryContract?: string;
        floorAskPrice?: number;
        topBidValue?: number;
        topBidMaker?: string;
        "1dayVolume"?: number;
        "7dayVolume"?: number;
        "30dayVolume"?: number;
        allTimeVolume?: number;
        allTimeRank?: number;
    };
    Model25: definitions["Model24"][];
    getCollectionsV2Response: {
        collections?: definitions["Model25"];
    };
    Model26: {
        id?: string;
        slug?: string;
        name?: string;
        image?: string;
        banner?: string;
        discordUrl?: string;
        externalUrl?: string;
        twitterUsername?: string;
        description?: string;
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        tokenSetId?: string;
        primaryContract?: string;
        floorAskPrice?: number;
        topBidValue?: number;
        topBidMaker?: string;
        rank?: definitions["rank"];
        volume?: definitions["rank"];
        volumeChange?: definitions["volumeChange"];
        floorSale?: definitions["volumeChange"];
    };
    Model27: definitions["Model26"][];
    getCollectionsV3Response: {
        collections?: definitions["Model27"];
    };
    Model28: {
        id?: string;
        slug?: string;
        name?: string;
        image?: string;
        banner?: string;
        discordUrl?: string;
        externalUrl?: string;
        twitterUsername?: string;
        description?: string;
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        tokenSetId?: string;
        primaryContract?: string;
        floorAskPrice?: number;
        topBidValue?: number;
        topBidMaker?: string;
        rank?: definitions["rank"];
        volume?: definitions["rank"];
        volumeChange?: definitions["volumeChange"];
        floorSale?: definitions["volumeChange"];
        floorSaleChange?: definitions["volumeChange"];
    };
    Model29: definitions["Model28"][];
    getCollectionsV4Response: {
        continuation?: string;
        collections?: definitions["Model29"];
    };
    Model30: {
        recipient?: string;
        bps?: number;
    };
    breakdown: definitions["Model30"][];
    Model31: {
        recipient?: string;
        breakdown?: definitions["breakdown"];
        bps?: number;
    };
    currency: {
        contract?: string;
        name?: string;
        symbol?: string;
        decimals?: number;
    };
    amount: {
        raw?: string;
        decimal?: number;
        usd?: number;
        native?: number;
    };
    price: {
        currency?: definitions["currency"];
        amount?: definitions["amount"];
        netAmount?: definitions["amount"];
    };
    Model32: {
        id?: string;
        sourceDomain?: string;
        price?: definitions["price"];
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        token?: definitions["Model16"];
    };
    Model33: {
        id?: string;
        sourceDomain?: string;
        price?: definitions["price"];
        maker?: string;
        validFrom?: number;
        validUntil?: number;
    };
    Model34: {
        id?: string;
        /** @description Open Sea slug */
        slug?: string;
        createdAt?: string;
        name?: string;
        image?: string;
        banner?: string;
        discordUrl?: string;
        externalUrl?: string;
        twitterUsername?: string;
        openseaVerificationStatus?: string;
        description?: string;
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        onSaleCount?: string;
        primaryContract?: string;
        tokenSetId?: string;
        royalties?: definitions["Model31"];
        allRoyalties?: definitions["source"];
        lastBuy?: definitions["lastBuy"];
        floorAsk?: definitions["Model32"];
        topBid?: definitions["Model33"];
        rank?: definitions["rank"];
        volume?: definitions["rank"];
        volumeChange?: definitions["volumeChange"];
        floorSale?: definitions["volumeChange"];
        floorSaleChange?: definitions["volumeChange"];
        salesCount?: definitions["rank"];
        collectionBidSupported?: boolean;
        ownerCount?: number;
        attributes?: definitions["Model19"];
    };
    Model35: definitions["Model34"][];
    getCollectionsV5Response: {
        continuation?: string;
        collections?: definitions["Model35"];
    };
    Model36: {
        kind?: string;
        recipient?: string;
        bps?: number;
    };
    feeBreakdown: definitions["Model36"][];
    Model37: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        fillabilityStatus: string;
        approvalStatus: string;
        tokenSetId: string;
        tokenSetSchemaHash: string;
        maker: string;
        taker: string;
        price: number;
        value: number;
        validFrom: number;
        validUntil: number;
        sourceId?: string;
        feeBps?: number;
        feeBreakdown?: definitions["feeBreakdown"];
        expiration: number;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    orders: definitions["Model37"][];
    getOrdersV1Response: {
        orders?: definitions["orders"];
    };
    Model38: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        fillabilityStatus: string;
        approvalStatus: string;
        tokenSetId: string;
        tokenSetSchemaHash: string;
        maker: string;
        taker: string;
        price: number;
        value: number;
        validFrom: number;
        validUntil: number;
        source?: string;
        feeBps?: number;
        feeBreakdown?: definitions["feeBreakdown"];
        expiration: number;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model39: definitions["Model38"][];
    getOrdersV2Response: {
        orders?: definitions["Model39"];
    };
    ownership: {
        tokenCount?: string;
        onSaleCount?: string;
        floorAskPrice?: number;
        topBidValue?: number;
        totalBidValue?: number;
    };
    Model40: {
        address?: string;
        ownership?: definitions["ownership"];
    };
    owners: definitions["Model40"][];
    getOwnersV1Response: {
        owners?: definitions["owners"];
    };
    Model41: {
        id?: string;
        name?: string;
    };
    Model42: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
        collection?: definitions["Model41"];
    };
    Model43: {
        token?: definitions["Model42"];
        maker?: string;
        taker?: string;
        amount?: string;
        txHash?: string;
        timestamp?: number;
        price?: number;
    };
    sales: definitions["Model43"][];
    getSalesV1Response: {
        sales?: definitions["sales"];
    };
    Model44: {
        token?: definitions["Model42"];
        /** @enum {string} */
        orderSide?: "ask" | "bid";
        from?: string;
        to?: string;
        amount?: string;
        txHash?: string;
        timestamp?: number;
        price?: number;
    };
    Model45: definitions["Model44"][];
    getSalesV2Response: {
        sales?: definitions["Model45"];
    };
    Model46: {
        id?: string;
        saleId?: string;
        token?: definitions["Model42"];
        orderSource?: string;
        orderSourceDomain?: string;
        /** @enum {string} */
        orderSide?: "ask" | "bid";
        orderKind?: string;
        from?: string;
        to?: string;
        amount?: string;
        fillSource?: string;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        timestamp?: number;
        price?: number;
        currency?: string;
        currencyPrice?: number;
        usdPrice?: number;
        washTradingScore?: number;
    };
    Model47: definitions["Model46"][];
    getSalesV3Response: {
        sales?: definitions["Model47"];
        continuation?: string;
    };
    Model48: {
        kind?: string;
        bps?: number;
        recipient?: string;
    };
    Model49: definitions["Model48"][];
    Model50: {
        id?: string;
        saleId?: string;
        token?: definitions["Model42"];
        orderSource?: string;
        /** @enum {string} */
        orderSide?: "ask" | "bid";
        orderKind?: string;
        orderId?: string;
        from?: string;
        to?: string;
        amount?: string;
        fillSource?: string;
        block?: number;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        timestamp?: number;
        price?: definitions["price"];
        washTradingScore?: number;
        royaltyFeeBps?: number;
        marketplaceFeeBps?: number;
        paidFullRoyalty?: boolean;
        feeBreakdown?: definitions["Model49"];
    };
    Model51: definitions["Model50"][];
    getSalesV4Response: {
        sales?: definitions["Model51"];
        continuation?: string;
    };
    Model52: {
        id?: string;
        name?: string;
        icon?: string;
        tokenUrl?: string;
        domain?: string;
    };
    sources: definitions["Model52"][];
    getSourcesV1Response: {
        sources?: definitions["sources"];
        continuation?: string;
    };
    Model53: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
    };
    Model54: {
        id?: string;
        price?: number;
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        token?: definitions["Model53"];
    };
    market: {
        floorAsk?: definitions["Model54"];
        topBid?: definitions["topBid"];
    };
    stats: {
        tokenCount: number;
        onSaleCount: number;
        sampleImages?: definitions["sampleImages"];
        market?: definitions["market"];
    };
    getStatsV1Response: {
        stats?: definitions["stats"];
    };
    Model55: {
        id?: string;
        price?: definitions["price"];
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        token?: definitions["Model53"];
    };
    Model56: {
        id?: string;
        price?: definitions["price"];
        maker?: string;
        validFrom?: number;
        validUntil?: number;
    };
    Model57: {
        floorAsk?: definitions["Model55"];
        topBid?: definitions["Model56"];
    };
    Model58: {
        tokenCount: number;
        onSaleCount: number;
        flaggedTokenCount: number;
        sampleImages?: definitions["sampleImages"];
        market?: definitions["Model57"];
    };
    getStatsV2Response: {
        stats?: definitions["Model58"];
    };
    Model59: {
        contract: string;
        tokenId: string;
        name?: string;
        image?: string;
        collection?: definitions["Model41"];
        topBidValue?: number;
        floorAskPrice?: number;
    };
    tokens: definitions["Model59"][];
    getTokensV1Response: {
        tokens?: definitions["tokens"];
    };
    getTokensV2Response: {
        tokens?: definitions["tokens"];
        continuation?: string;
    };
    Model60: {
        id?: string;
        name?: string;
        image?: string;
        slug?: string;
    };
    Model61: {
        contract: string;
        tokenId: string;
        name?: string;
        image?: string;
        collection?: definitions["Model60"];
        topBidValue?: number;
        floorAskPrice?: number;
    };
    Model62: definitions["Model61"][];
    getTokensV3Response: {
        tokens?: definitions["Model62"];
        continuation?: string;
    };
    Model63: {
        contract: string;
        tokenId: string;
        name?: string;
        image?: string;
        media?: string;
        collection?: definitions["Model60"];
        source?: string;
        sourceDomain?: string;
        topBidValue?: number;
        floorAskPrice?: number;
        rarity?: number;
        rarityRank?: number;
        owner?: string;
        /** @default false */
        isFlagged?: boolean;
        lastFlagUpdate?: string;
    };
    Model64: definitions["Model63"][];
    getTokensV4Response: {
        tokens?: definitions["Model64"];
        continuation?: string;
    };
    Model65: {
        key?: string;
        kind?: string;
        value: string;
        tokenCount?: number;
        onSaleCount?: number;
        floorAskPrice?: number;
        topBidValue?: number;
        createdAt?: string;
    };
    Model66: definitions["Model65"][];
    Model67: {
        contract: string;
        tokenId: string;
        name?: string;
        description?: string;
        image?: string;
        media?: string;
        kind?: string;
        /** @default false */
        isFlagged?: boolean;
        lastFlagUpdate?: string;
        lastFlagChange?: string;
        rarity?: number;
        rarityRank?: number;
        collection?: definitions["Model60"];
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        owner?: string;
        attributes?: definitions["Model66"];
    };
    dynamicPricing: {
        /** @enum {string} */
        kind?: "dutch" | "pool";
        data?: definitions["source"];
    };
    Model68: {
        id?: string;
        price?: definitions["price"];
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        quantityFilled?: number;
        quantityRemaining?: number;
        dynamicPricing?: definitions["dynamicPricing"];
        source?: definitions["source"];
    };
    Model69: {
        id?: string;
        price?: definitions["price"];
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        source?: definitions["source"];
        feeBreakdown?: definitions["feeBreakdown"];
    };
    Model70: {
        floorAsk?: definitions["Model68"];
        topBid?: definitions["Model69"];
    };
    Model71: {
        token?: definitions["Model67"];
        market?: definitions["Model70"];
    };
    Model72: definitions["Model71"][];
    getTokensV5Response: {
        tokens?: definitions["Model72"];
        continuation?: string;
    };
    Model73: {
        token?: definitions["Model42"];
        from?: string;
        to?: string;
        amount?: string;
        txHash?: string;
        block?: number;
        logIndex?: number;
        batchIndex?: number;
        timestamp?: number;
        price?: number;
    };
    transfers: definitions["Model73"][];
    getTransfersV2Response: {
        transfers?: definitions["transfers"];
        continuation?: string;
    };
    getApiKeyRateLimitsResponse: {
        key?: string;
        appName?: string;
        website?: string;
        email?: string;
        active?: boolean;
        tier?: number;
        permissions?: string;
        createdAt?: string;
    };
    Model74: {
        route?: string;
        method?: string;
        allowedRequests?: number;
        perSeconds?: number;
    };
    rateLimits: definitions["Model74"][];
    Model75: {
        rateLimits?: definitions["rateLimits"];
    };
    Model76: {
        tokenId?: string;
        tokenName?: string;
        tokenImage?: string;
    };
    Model77: {
        collectionId?: string;
        collectionName?: string;
        collectionImage?: string;
    };
    Model78: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        createdAt?: string;
        contract?: string;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["Model5"];
    };
    Model79: definitions["Model78"][];
    getCollectionActivityV4Response: {
        continuation?: string;
        activities?: definitions["Model79"];
    };
    Model80: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        createdAt?: string;
        contract?: string;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["Model10"];
    };
    Model81: definitions["Model80"][];
    getCollectionActivityV5Response: {
        continuation?: string;
        activities?: definitions["Model81"];
    };
    Model82: {
        id?: string;
        timestamp?: number;
        volume?: number;
        rank?: number;
        floor_sell_value?: number;
        sales_count?: number;
    };
    Model83: definitions["Model82"][];
    getDailyVolumesV1Response: {
        collections?: definitions["Model83"];
    };
    Model84: {
        onSaleCount?: number;
        sourceDomain?: string;
        floorAskPrice?: number;
    };
    Model85: definitions["Model84"][];
    getSourcesListingsV1Response: {
        sources?: definitions["Model85"];
    };
    Model86: {
        id?: string;
        slug?: string;
        name?: string;
        metadata?: definitions["source"];
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        onSaleCount?: string;
        tokenSetId?: string;
        royalties?: definitions["royalties"];
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        floorAsk?: definitions["floorAsk"];
        topBid?: definitions["topBid"];
        rank?: definitions["rank"];
        volume?: definitions["rank"];
    };
    getCollectionDeprecatedV1Response: {
        collection?: definitions["Model86"];
    };
    Model87: {
        id?: string;
        status?: string;
        contract?: string;
        tokenId?: string;
        maker?: string;
        price?: definitions["price"];
        quantityRemaining?: number;
        nonce?: string;
        validFrom?: number;
        validUntil?: number;
        source?: string;
        isDynamic?: boolean;
    };
    event: {
        id?: number;
        /** @enum {string} */
        kind?: "new-order" | "expiry" | "sale" | "cancel" | "balance-change" | "approval-change" | "bootstrap" | "revalidation" | "reprice";
        txHash?: string;
        txTimestamp?: number;
        createdAt?: string;
    };
    Model88: {
        order?: definitions["Model87"];
        event?: definitions["event"];
    };
    events: definitions["Model88"][];
    getAsksEventsV2Response: {
        events?: definitions["events"];
        continuation?: string;
    };
    Model89: {
        id?: string;
        status?: string;
        contract?: string;
        maker?: string;
        price?: definitions["price"];
        quantityRemaining?: number;
        nonce?: string;
        validFrom?: number;
        validUntil?: number;
        rawData?: definitions["source"];
        kind?: string;
        source?: string;
        isDynamic?: boolean;
        criteria?: definitions["Model9"];
    };
    Model90: {
        order?: definitions["Model89"];
        event?: definitions["event"];
    };
    Model91: definitions["Model90"][];
    getAsksEventsV3Response: {
        events?: definitions["Model91"];
        continuation?: string;
    };
    bid: {
        id?: string;
        status?: string;
        contract?: string;
        tokenSetId?: string;
        maker?: string;
        price?: number;
        value?: number;
        quantityRemaining?: number;
        nonce?: string;
        validFrom?: number;
        validUntil?: number;
        source?: string;
        criteria?: definitions["Model9"];
    };
    Model92: {
        bid?: definitions["bid"];
        event?: definitions["event"];
    };
    Model93: definitions["Model92"][];
    getBidEventsV1Response: {
        events?: definitions["Model93"];
        continuation?: string;
    };
    Model94: {
        id?: string;
        status?: string;
        contract?: string;
        tokenSetId?: string;
        maker?: string;
        price?: number;
        value?: number;
        quantityRemaining?: number;
        nonce?: string;
        validFrom?: number;
        validUntil?: number;
        kind?: string;
        source?: string;
        criteria?: definitions["Model9"];
    };
    Model95: {
        bid?: definitions["Model94"];
        event?: definitions["event"];
    };
    Model96: definitions["Model95"][];
    getBidEventsV2Response: {
        events?: definitions["Model96"];
        continuation?: string;
    };
    Model97: {
        id?: string;
        status?: string;
        contract?: string;
        maker?: string;
        price?: definitions["price"];
        quantityRemaining?: number;
        nonce?: string;
        validFrom?: number;
        validUntil?: number;
        rawData?: definitions["source"];
        kind?: string;
        source?: string;
        criteria?: definitions["Model9"];
    };
    Model98: {
        bid?: definitions["Model97"];
        event?: definitions["event"];
    };
    Model99: definitions["Model98"][];
    getBidEventsV3Response: {
        events?: definitions["Model99"];
        continuation?: string;
    };
    Model100: {
        id?: string;
        status?: string;
        contract?: string;
        tokenId?: string;
        maker?: string;
        price?: number;
        quantityRemaining?: number;
        nonce?: string;
        validFrom?: number;
        validUntil?: number;
        source?: string;
    };
    Model101: {
        order?: definitions["Model100"];
        event?: definitions["event"];
    };
    Model102: definitions["Model101"][];
    getOrderEventsV1Response: {
        events?: definitions["Model102"];
        continuation?: string;
    };
    Model103: {
        action: string;
        description: string;
        /** @enum {string} */
        status: "complete" | "incomplete";
        /** @enum {string} */
        kind: "request" | "signature" | "transaction";
        data?: definitions["source"];
    };
    steps: definitions["Model103"][];
    getExecuteBidV2Response: {
        steps?: definitions["steps"];
        query?: definitions["source"];
    };
    Model104: {
        action: string;
        description: string;
        /** @enum {string} */
        status: "complete" | "incomplete";
        /** @enum {string} */
        kind: "request" | "signature" | "transaction" | "confirmation";
        data?: definitions["source"];
    };
    Model105: definitions["Model104"][];
    Model106: {
        contract?: string;
        tokenId?: string;
        quantity?: number;
        source?: string;
        quote?: number;
    };
    path: definitions["Model106"][];
    getExecuteBuyV2Response: {
        steps?: definitions["Model105"];
        quote?: number;
        path?: definitions["path"];
        query?: definitions["source"];
    };
    Model107: {
        /** @enum {string} */
        status: "complete" | "incomplete";
        data?: definitions["source"];
    };
    items: definitions["Model107"][];
    Model108: {
        action: string;
        description: string;
        /** @enum {string} */
        kind: "transaction";
        items: definitions["items"];
    };
    Model109: definitions["Model108"][];
    Model110: {
        orderId?: string;
        contract?: string;
        tokenId?: string;
        quantity?: number;
        source?: string;
        currency?: string;
        quote?: number;
        rawQuote?: string;
    };
    Model111: definitions["Model110"][];
    getExecuteBuyV3Response: {
        steps?: definitions["Model109"];
        path?: definitions["Model111"];
    };
    getExecuteCancelV1Response: {
        steps?: definitions["Model105"];
        query?: definitions["source"];
    };
    Model112: {
        /** @enum {string} */
        status: "complete" | "incomplete";
        data?: definitions["source"];
        orderIndex?: number;
    };
    Model113: definitions["Model112"][];
    Model114: {
        id: string;
        action: string;
        description: string;
        /** @enum {string} */
        kind: "transaction";
        items: definitions["Model113"];
    };
    Model115: definitions["Model114"][];
    getExecuteCancelV2Response: {
        steps?: definitions["Model115"];
    };
    Model116: {
        user?: string;
        rank: number;
        tokenCount: string;
        liquidity: number;
        maxTopBuyValue: number;
        wethBalance: number;
    };
    liquidity: definitions["Model116"][];
    getUsersLiquidityV1Response: {
        liquidity?: definitions["liquidity"];
    };
    Model117: {
        kind?: string;
        recipient?: string;
        bps?: string;
    };
    Model118: definitions["Model117"][];
    Model119: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price: number;
        value: number;
        validFrom: number;
        validUntil: number;
        source?: string;
        feeBps?: number;
        feeBreakdown?: definitions["Model118"];
        status?: string;
        expiration: number;
        createdAt: string;
        updatedAt: string;
        metadata?: definitions["source"];
        rawData?: definitions["source"];
    };
    Model120: definitions["Model119"][];
    getOrdersAllV1Response: {
        orders?: definitions["Model120"];
        continuation?: string;
    };
    Model121: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price?: definitions["price"];
        validFrom: number;
        validUntil: number;
        source?: string;
        feeBps?: number;
        feeBreakdown?: definitions["Model118"];
        status?: string;
        expiration: number;
        createdAt: string;
        updatedAt: string;
        metadata?: definitions["source"];
        rawData?: definitions["source"];
    };
    Model122: definitions["Model121"][];
    getOrdersAllV2Response: {
        orders?: definitions["Model122"];
        continuation?: string;
    };
    Model123: {
        collectionName?: string;
        tokenName?: string;
        image?: string;
    };
    Model124: {
        /** @enum {string} */
        kind?: "token";
        data?: definitions["Model123"];
    };
    Model125: {
        kind?: string;
        recipient?: string;
        bps?: number;
    };
    Model126: definitions["Model125"][];
    Model127: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price: number;
        value: number;
        validFrom: number;
        validUntil: number;
        metadata?: definitions["Model124"];
        status?: string;
        source?: definitions["source"];
        feeBps?: number;
        feeBreakdown?: definitions["Model126"];
        expiration: number;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model128: definitions["Model127"][];
    getOrdersAsksV1Response: {
        orders?: definitions["Model128"];
        continuation?: string;
    };
    Model129: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price?: definitions["price"];
        validFrom: number;
        validUntil: number;
        quantityFilled?: number;
        quantityRemaining?: number;
        metadata?: definitions["Model124"];
        status?: string;
        source?: definitions["source"];
        feeBps?: number;
        feeBreakdown?: definitions["Model126"];
        expiration: number;
        isZoo?: boolean;
        isDynamic?: boolean;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model130: definitions["Model129"][];
    getOrdersAsksV3Response: {
        orders?: definitions["Model130"];
        continuation?: string;
    };
    Model131: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price?: definitions["price"];
        validFrom: number;
        validUntil: number;
        quantityFilled?: number;
        quantityRemaining?: number;
        criteria?: definitions["Model9"];
        status?: string;
        source?: definitions["source"];
        feeBps?: number;
        feeBreakdown?: definitions["Model126"];
        expiration: number;
        isZoo?: boolean;
        isDynamic?: boolean;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model132: definitions["Model131"][];
    getOrdersAsksV4Response: {
        orders?: definitions["Model132"];
        continuation?: string;
    };
    Model133: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        status?: string;
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price: number;
        value: number;
        validFrom: number;
        validUntil: number;
        metadata?: definitions["Model124"];
        source?: definitions["source"];
        feeBps?: number;
        feeBreakdown?: definitions["Model126"];
        expiration: number;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model134: definitions["Model133"][];
    getOrdersBidsV1Response: {
        orders?: definitions["Model134"];
        continuation?: string;
    };
    Model135: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        status?: string;
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price?: definitions["price"];
        validFrom: number;
        validUntil: number;
        quantityFilled?: number;
        quantityRemaining?: number;
        metadata?: definitions["Model124"];
        source?: definitions["source"];
        feeBps?: number;
        feeBreakdown?: definitions["Model126"];
        expiration: number;
        isZoo?: boolean;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model136: definitions["Model135"][];
    getOrdersBidsV3Response: {
        orders?: definitions["Model136"];
        continuation?: string;
    };
    Model137: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        status?: string;
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price?: definitions["price"];
        validFrom: number;
        validUntil: number;
        quantityFilled?: number;
        quantityRemaining?: number;
        metadata?: definitions["Model4"];
        source?: definitions["source"];
        feeBps?: number;
        feeBreakdown?: definitions["Model126"];
        expiration: number;
        isZoo?: boolean;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model138: definitions["Model137"][];
    getOrdersBidsV4Response: {
        orders?: definitions["Model138"];
        continuation?: string;
    };
    Model139: {
        id: string;
        kind: string;
        /** @enum {string} */
        side: "buy" | "sell";
        status?: string;
        tokenSetId: string;
        tokenSetSchemaHash: string;
        contract?: string;
        maker: string;
        taker: string;
        price?: definitions["price"];
        validFrom: number;
        validUntil: number;
        quantityFilled?: number;
        quantityRemaining?: number;
        criteria?: definitions["Model9"];
        source?: definitions["source"];
        feeBps?: number;
        feeBreakdown?: definitions["Model126"];
        expiration: number;
        isZoo?: boolean;
        createdAt: string;
        updatedAt: string;
        rawData?: definitions["source"];
    };
    Model140: definitions["Model139"][];
    getOrdersBidsV5Response: {
        orders?: definitions["Model140"];
        continuation?: string;
    };
    Model141: {
        address?: string;
        count?: number;
        owners?: definitions["sampleImages"];
    };
    Model142: definitions["Model141"][];
    getCommonCollectionsOwnersV1Response: {
        collections?: definitions["Model142"];
    };
    Model143: {
        address?: string;
        count?: number;
        collections?: definitions["sampleImages"];
    };
    Model144: definitions["Model143"][];
    getCrossCollectionsOwnersV1Response: {
        owners?: definitions["Model144"];
    };
    Model145: {
        contract?: string;
        tokenId?: string;
    };
    Model146: {
        id?: string;
        saleId?: string;
        token?: definitions["Model145"];
        orderSource?: string;
        orderSourceDomain?: string;
        /** @enum {string} */
        orderSide?: "ask" | "bid";
        orderKind?: string;
        from?: string;
        to?: string;
        amount?: string;
        fillSource?: string;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        timestamp?: number;
        price?: number;
    };
    Model147: definitions["Model146"][];
    getSalesBulkV1Response: {
        sales?: definitions["Model147"];
        continuation?: string;
    };
    Model148: {
        collectionId?: string;
        contract?: string;
        image?: string;
        name?: string;
        allTimeVolume?: number;
        floorAskPrice?: number;
        openseaVerificationStatus?: string;
    };
    Model149: definitions["Model148"][];
    getSearchCollectionsV1Response: {
        collections?: definitions["Model149"];
    };
    Model150: {
        contract?: string;
        tokenId?: string;
        image?: string;
        orderId?: string;
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        price?: number;
        source?: string;
    };
    Model151: definitions["Model150"][];
    getTokensBootstrapV1Response: {
        tokens?: definitions["Model151"];
        continuation?: string;
    };
    Model152: {
        key?: string;
        value: string;
    };
    Model153: definitions["Model152"][];
    Model154: {
        contract: string;
        tokenId: string;
        name?: string;
        description?: string;
        image?: string;
        kind?: string;
        collection?: definitions["Model41"];
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        owner?: string;
        attributes?: definitions["Model153"];
    };
    Model155: {
        id?: string;
        price?: number;
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        source?: definitions["source"];
    };
    Model156: {
        floorAsk?: definitions["Model155"];
        topBid?: definitions["topBid"];
    };
    Model157: {
        token?: definitions["Model154"];
        market?: definitions["Model156"];
    };
    Model158: definitions["Model157"][];
    getTokensDetailsV2Response: {
        tokens?: definitions["Model158"];
        continuation?: string;
    };
    Model159: {
        contract: string;
        tokenId: string;
        name?: string;
        description?: string;
        image?: string;
        kind?: string;
        collection?: definitions["Model60"];
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        owner?: string;
        attributes?: definitions["Model153"];
    };
    Model160: {
        token?: definitions["Model159"];
        market?: definitions["Model156"];
    };
    Model161: definitions["Model160"][];
    getTokensDetailsV3Response: {
        tokens?: definitions["Model161"];
        continuation?: string;
    };
    Model162: {
        key?: string;
        value: string;
        tokenCount?: number;
        onSaleCount?: number;
        floorAskPrice?: number;
        topBidValue?: number;
    };
    Model163: definitions["Model162"][];
    Model164: {
        contract: string;
        tokenId: string;
        name?: string;
        description?: string;
        image?: string;
        media?: string;
        kind?: string;
        /** @default false */
        isFlagged?: boolean;
        lastFlagUpdate?: string;
        collection?: definitions["Model60"];
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        owner?: string;
        attributes?: definitions["Model163"];
    };
    Model165: {
        token?: definitions["Model164"];
        market?: definitions["Model156"];
    };
    Model166: definitions["Model165"][];
    getTokensDetailsV4Response: {
        tokens?: definitions["Model166"];
        continuation?: string;
    };
    getTokensFloorV1Response: {
        tokens?: {
            string?: number;
        };
    };
    Model167: string[];
    getTokensIdsV1Response: {
        tokens?: definitions["Model167"];
        continuation?: string;
    };
    Model168: {
        id?: string;
        token?: definitions["Model145"];
        from?: string;
        to?: string;
        amount?: string;
        block?: number;
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        timestamp?: number;
    };
    Model169: definitions["Model168"][];
    getTransfersBulkV1Response: {
        transfers?: definitions["Model169"];
        continuation?: string;
    };
    Model170: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        source?: definitions["source"];
    };
    Model171: definitions["Model170"][];
    getUserActivityV2Response: {
        continuation?: number;
        activities?: definitions["Model171"];
    };
    Model172: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        source?: definitions["source"];
        createdAt?: string;
    };
    Model173: definitions["Model172"][];
    getUserActivityV3Response: {
        continuation?: string;
        activities?: definitions["Model173"];
    };
    Model174: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        contract?: string;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["Model5"];
        createdAt?: string;
    };
    Model175: definitions["Model174"][];
    getUserActivityV4Response: {
        continuation?: string;
        activities?: definitions["Model175"];
    };
    Model176: {
        tokenId?: string;
        tokenName?: string;
        tokenImage?: string;
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        tokenRarityScore?: number;
        tokenRarityRank?: number;
        tokenMedia?: string;
    };
    Model177: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        contract?: string;
        token?: definitions["Model176"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["Model10"];
        createdAt?: string;
    };
    Model178: definitions["Model177"][];
    getUserActivityV5Response: {
        continuation?: string;
        activities?: definitions["Model178"];
    };
    Model179: {
        value: number;
        timestamp: number;
    };
    lastBuys: definitions["Model179"][];
    floorAskPrices: number[];
    Model180: {
        key: string;
        value: string;
        tokenCount: number;
        sampleImages?: definitions["sampleImages"];
        lastBuys?: definitions["lastBuys"];
        lastSells?: definitions["lastBuys"];
        floorAskPrices?: definitions["floorAskPrices"];
        topBid?: definitions["topBid"];
    };
    Model181: definitions["Model180"][];
    getCollectionAttributesV1Response: {
        attributes?: definitions["Model181"];
    };
    Model182: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        createdAt?: string;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        source?: definitions["source"];
    };
    Model183: definitions["Model182"][];
    getCollectionActivityV2Response: {
        continuation?: string;
        activities?: definitions["Model183"];
    };
    Model184: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        createdAt?: string;
        contract?: string;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
        order?: definitions["order"];
    };
    Model185: definitions["Model184"][];
    getCollectionActivityV3Response: {
        continuation?: string;
        activities?: definitions["Model185"];
    };
    Model186: {
        value?: number;
        quantity?: number;
    };
    topBids: definitions["Model186"][];
    getCollectionTopBidsV1Response: {
        topBids?: definitions["topBids"];
    };
    Model187: {
        tokenCount?: number;
        ownerCount?: number;
    };
    ownersDistribution: definitions["Model187"][];
    getCollectionOwnersDistributionV1Response: {
        ownersDistribution?: definitions["ownersDistribution"];
    };
    Model188: {
        id?: string;
    };
    Model189: {
        orderId?: string;
        contract?: string;
        tokenId?: string;
        maker?: string;
        price?: number;
        validUntil?: number;
        source?: string;
    };
    Model190: {
        id?: number;
        /** @enum {string} */
        kind?: "new-order" | "expiry" | "sale" | "cancel" | "balance-change" | "approval-change" | "bootstrap" | "revalidation" | "reprice";
        previousPrice?: number;
        txHash?: string;
        txTimestamp?: number;
        createdAt?: string;
    };
    Model191: {
        collection?: definitions["Model188"];
        floorAsk?: definitions["Model189"];
        event?: definitions["Model190"];
    };
    Model192: definitions["Model191"][];
    getCollectionsFloorAskV1Response: {
        events?: definitions["Model192"];
        continuation?: string;
    };
    Model193: {
        orderId?: string;
        contract?: string;
        tokenSetId?: string;
        maker?: string;
        price?: number;
        validUntil?: number;
        source?: string;
    };
    Model194: {
        collection?: definitions["Model188"];
        topBid?: definitions["Model193"];
        event?: definitions["Model190"];
    };
    Model195: definitions["Model194"][];
    getCollectionsTopbidV1Response: {
        events?: definitions["Model195"];
        continuation?: string;
    };
    Model196: {
        orderId?: string;
        contract?: string;
        tokenSetId?: string;
        maker?: string;
        price?: definitions["price"];
        validUntil?: number;
        source?: string;
    };
    Model197: {
        collection?: definitions["Model188"];
        topBid?: definitions["Model196"];
        event?: definitions["Model190"];
    };
    Model198: definitions["Model197"][];
    getCollectionsTopbidV2Response: {
        events?: definitions["Model198"];
        continuation?: string;
    };
    Model199: {
        orderId?: string;
        maker?: string;
        nonce?: string;
        price?: number;
        validFrom?: number;
        validUntil?: number;
        source?: string;
    };
    Model200: {
        token?: definitions["Model145"];
        floorAsk?: definitions["Model199"];
        event?: definitions["Model190"];
    };
    Model201: definitions["Model200"][];
    getTokensFloorAskV2Response: {
        events?: definitions["Model201"];
        continuation?: string;
    };
    Model202: {
        orderId?: string;
        maker?: string;
        nonce?: string;
        price?: definitions["price"];
        validFrom?: number;
        validUntil?: number;
        source?: string;
        isDynamic?: boolean;
    };
    Model203: {
        token?: definitions["Model145"];
        floorAsk?: definitions["Model202"];
        event?: definitions["Model190"];
    };
    Model204: definitions["Model203"][];
    getTokensFloorAskV3Response: {
        events?: definitions["Model204"];
        continuation?: string;
    };
    message: {
        id: string;
        payload: string;
        timestamp: number;
        signature: string;
    };
    getCollectionFloorAskOracleV4Response: {
        price: number;
        message?: definitions["message"];
        data?: string;
    };
    getCollectionTopBidOracleV1Response: {
        price: number;
        message?: definitions["message"];
    };
    Model205: {
        token: string;
        isFlagged: boolean;
        lastTransferTime: number;
        message?: definitions["message"];
    };
    messages: definitions["Model205"][];
    getTokenStatusOracleV1Response: {
        messages?: definitions["messages"];
    };
    Model206: {
        tokenId: string;
        lastFlagChange?: string;
        /** @default false */
        isFlagged?: boolean;
        contract: string;
    };
    Model207: definitions["Model206"][];
    getFlaggedTokensV1Response: {
        tokens?: definitions["Model207"];
        continuation?: string;
    };
    getTransactionSyncedV1Response: {
        synced: boolean;
    };
    Model208: {
        id?: string;
        name?: string;
        imageUrl?: string;
        floorAskPrice?: number;
    };
    Model209: {
        id?: string;
        price?: definitions["price"];
    };
    Model210: {
        contract?: string;
        tokenId?: string;
        kind?: string;
        name?: string;
        image?: string;
        lastBuy?: definitions["lastBuy"];
        lastSell?: definitions["lastBuy"];
        rarityScore?: number;
        rarityRank?: number;
        media?: string;
        collection?: definitions["Model208"];
        topBid?: definitions["Model209"];
    };
    Model211: {
        id?: string;
        price?: definitions["price"];
        maker?: string;
        validFrom?: number;
        validUntil?: number;
        source?: definitions["source"];
    };
    Model212: {
        tokenCount?: string;
        onSaleCount?: string;
        floorAsk?: definitions["Model211"];
        acquiredAt?: string;
    };
    Model213: {
        token?: definitions["Model210"];
        ownership?: definitions["Model212"];
    };
    Model214: definitions["Model213"][];
    getUserTokensV6Response: {
        tokens?: definitions["Model214"];
        continuation?: string;
    };
    Model215: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
        collection?: definitions["Model208"];
        topBid?: definitions["Model209"];
    };
    Model216: {
        tokenCount?: string;
        onSaleCount?: string;
        floorAskPrice?: definitions["price"];
        acquiredAt?: string;
    };
    Model217: {
        token?: definitions["Model215"];
        ownership?: definitions["Model216"];
    };
    Model218: definitions["Model217"][];
    getUserTokensV4Response: {
        tokens?: definitions["Model218"];
    };
    Model219: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
        collection?: definitions["Model208"];
    };
    Model220: {
        tokenCount?: string;
        onSaleCount?: string;
        floorAskPrice?: number;
        acquiredAt?: string;
    };
    Model221: {
        token?: definitions["Model219"];
        ownership?: definitions["Model220"];
    };
    Model222: definitions["Model221"][];
    getUserTokensV2Response: {
        tokens?: definitions["Model222"];
    };
    set: {
        id?: string;
        metadata?: definitions["Model124"];
        sampleImages?: definitions["sampleImages"];
        image?: string;
        floorAskPrice?: number;
        topBidValue?: number;
    };
    primaryOrder: {
        id?: string;
        value?: number;
        expiration?: number;
    };
    Model223: {
        set?: definitions["set"];
        primaryOrder?: definitions["primaryOrder"];
        totalValid?: number;
    };
    positions: definitions["Model223"][];
    getUserPositionsV1Response: {
        positions?: definitions["positions"];
    };
    metadata: {
        imageUrl?: string;
        discordUrl?: string;
        description?: string;
        externalUrl?: string;
        bannerImageUrl?: string;
        twitterUsername?: string;
    };
    Model224: {
        id?: string;
        name?: string;
        metadata?: definitions["metadata"];
        floorAskPrice?: number;
        topBidValue?: number;
    };
    Model225: {
        tokenCount?: string;
        onSaleCount?: string;
        liquidCount?: string;
    };
    Model226: {
        collection?: definitions["Model224"];
        ownership?: definitions["Model225"];
    };
    Model227: definitions["Model226"][];
    getUserCollectionsV1Response: {
        collections?: definitions["Model227"];
    };
    Model228: {
        type?: string;
        fromAddress?: string;
        toAddress?: string;
        price?: number;
        amount?: number;
        timestamp?: number;
        token?: definitions["Model76"];
        collection?: definitions["Model77"];
        txHash?: string;
        logIndex?: number;
        batchIndex?: number;
    };
    Model229: definitions["Model228"][];
    getUserActivityV1Response: {
        continuation?: number;
        activities?: definitions["Model229"];
    };
    Model230: {
        id?: string;
        slug?: string;
        name?: string;
        image?: string;
        banner?: string;
        discordUrl?: string;
        externalUrl?: string;
        twitterUsername?: string;
        description?: string;
        sampleImages?: definitions["sampleImages"];
        tokenCount?: string;
        tokenSetId?: string;
        primaryContract?: string;
        floorAskPrice?: number;
        topBidValue?: number;
        topBidMaker?: string;
        topBidSourceDomain?: string;
        rank?: definitions["rank"];
        volume?: definitions["rank"];
        volumeChange?: definitions["volumeChange"];
        floorSale?: definitions["volumeChange"];
    };
    Model231: {
        collection?: definitions["Model230"];
        ownership?: definitions["Model225"];
    };
    Model232: definitions["Model231"][];
    getUserCollectionsV2Response: {
        collections?: definitions["Model232"];
    };
    Model233: {
        id?: string;
        value?: number;
        schema?: definitions["source"];
    };
    Model234: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
        collection?: definitions["Model41"];
        topBid?: definitions["Model233"];
    };
    Model235: {
        tokenCount?: string;
        onSaleCount?: string;
        floorSellValue?: number;
        acquiredAt?: number;
    };
    Model236: {
        token?: definitions["Model234"];
        ownership?: definitions["Model235"];
    };
    Model237: definitions["Model236"][];
    getUserTokensV1Response: {
        tokens?: definitions["Model237"];
    };
    Model238: {
        id?: string;
        value?: number;
    };
    Model239: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
        collection?: definitions["Model208"];
        topBid?: definitions["Model238"];
    };
    Model240: {
        token?: definitions["Model239"];
        ownership?: definitions["Model220"];
    };
    Model241: definitions["Model240"][];
    getUserTokensV3Response: {
        tokens?: definitions["Model241"];
    };
    Model242: {
        token?: definitions["Model215"];
        ownership?: definitions["Model212"];
    };
    Model243: definitions["Model242"][];
    getUserTokensV5Response: {
        tokens?: definitions["Model243"];
    };
    Model244: {
        tokenId: string;
        value: number;
        timestamp: number;
    };
    Model245: definitions["Model244"][];
    Model246: {
        key: string;
        value: string;
        tokenCount: number;
        onSaleCount: number;
        sampleImages?: definitions["sampleImages"];
        floorAskPrices?: definitions["floorAskPrices"];
        lastBuys?: definitions["Model245"];
        lastSells?: definitions["Model245"];
        topBid?: definitions["topBid"];
    };
    Model247: definitions["Model246"][];
    getAttributesExploreV4Response: {
        attributes?: definitions["Model247"];
        continuation?: string;
    };
    Model248: {
        key: string;
        value: string;
        tokenCount: number;
        onSaleCount: number;
        sampleImages?: definitions["sampleImages"];
        floorAskPrices?: definitions["floorAskPrices"];
        lastSells?: definitions["Model245"];
        topBid?: definitions["topBid"];
    };
    Model249: definitions["Model248"][];
    getAttributesExploreV2Response: {
        attributes?: definitions["Model249"];
    };
    Model250: {
        value: string;
        count?: number;
        floorAskPrice?: number;
    };
    Model251: definitions["Model250"][];
    Model252: {
        key: string;
        attributeCount?: number;
        /** @enum {string} */
        kind: "string" | "number" | "date" | "range";
        minRange?: number;
        maxRange?: number;
        values?: definitions["Model251"];
    };
    Model253: definitions["Model252"][];
    getAttributesAllV2Response: {
        attributes?: definitions["Model253"];
    };
    Model254: {
        value: string;
        count?: number;
        tokens?: definitions["sampleImages"];
    };
    Model255: definitions["Model254"][];
    Model256: {
        key: string;
        /** @enum {string} */
        kind: "string" | "number" | "date" | "range";
        values?: definitions["Model255"];
    };
    Model257: definitions["Model256"][];
    getAttributesStaticV1Response: {
        attributes?: definitions["Model257"];
    };
    getAttributesExploreV3Response: {
        attributes?: definitions["Model247"];
    };
    Model258: {
        contract?: string;
        tokenId?: string;
        name?: string;
        image?: string;
        floorAskPrice?: number;
        lastSalePrice?: number;
        collection?: definitions["Model208"];
    };
    Model259: {
        id?: string;
        price?: number;
        value?: number;
        maker?: string;
        createdAt?: string;
        validFrom?: number;
        validUntil?: number;
        floorDifferencePercentage?: number;
        source?: definitions["source"];
        feeBreakdown?: definitions["Model126"];
        criteria?: definitions["Model9"];
        token?: definitions["Model258"];
    };
    Model260: definitions["Model259"][];
    getUserTopBidsV2Response: {
        totalTokensWithBids?: number;
        topBids?: definitions["Model260"];
        continuation?: string;
    };
    Model261: {
        id?: string;
        price?: number;
        value?: number;
        maker?: string;
        createdAt?: string;
        validFrom?: number;
        validUntil?: number;
        floorDifferencePercentage?: number;
        source?: definitions["source"];
        feeBreakdown?: definitions["Model126"];
        context?: definitions["Model124"];
        token?: definitions["Model258"];
    };
    Model262: definitions["Model261"][];
    getUserTopBidsV1Response: {
        totalTokensWithBids?: number;
        topBids?: definitions["Model262"];
        continuation?: string;
    };
    Model263: {
        id?: string;
        price?: definitions["price"];
        maker?: string;
        createdAt?: string;
        validFrom?: number;
        validUntil?: number;
        floorDifferencePercentage?: number;
        source?: definitions["source"];
        feeBreakdown?: definitions["Model126"];
        criteria?: definitions["Model9"];
        token?: definitions["Model258"];
    };
    Model264: definitions["Model263"][];
    getUserTopBidsV3Response: {
        totalTokensWithBids?: number;
        totalAmount?: number;
        topBids?: definitions["Model264"];
        continuation?: string;
    };
    Model265: {
        community: string;
    };
    putSetCollectionCommunityV1Response: {
        message?: string;
    };
    getNewApiKeyResponse: {
        key: string;
    };
    Model266: {
        /** @description The collection for which to calculate the rarity, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string;
    };
    Model267: {
        /** @description The route for which the rule is created */
        route: string;
        points: number;
        duration: number;
        /** @enum {number} */
        tier?: 0 | 1 | 2 | 3 | 4;
        /** @default */
        apiKey?: string;
        /**
         * @default
         * @enum {string}
         */
        method?: "get" | "post" | "delete" | "put";
    };
    Model268: {
        /** @description The rule ID to delete */
        ruleId: number;
    };
    Model269: {
        fromBlock: number;
        toBlock: number;
    };
    contracts: string[];
    Model270: {
        /** @enum {string} */
        kind: "tokens-floor-sell" | "tokens-top-buy";
        contracts?: definitions["contracts"];
    };
    Model271: {
        /** @enum {string} */
        by: "id" | "maker" | "token" | "contract";
        id: string;
        token: string;
        maker: string;
        contract: string;
    };
    Model272: {
        /** @enum {string} */
        kind: "tokens-floor-sell" | "tokens-top-buy";
        token: string;
    };
    Model273: {
        address: string;
    };
    Model274: {
        token: string;
    };
    Model275: {
        /** @description Refresh the given collection. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string;
        /**
         * @description If true, will only refresh the collection cache.
         * @default false
         */
        cacheOnly?: boolean;
    };
    Model276: {
        /** @description Refresh tokens for the given collection. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string;
        /** @default false */
        backfill?: boolean;
    };
    Model277: {
        /** @enum {string} */
        method?: "opensea" | "simplehash" | "centerdev" | "soundxyz";
        /** @description Refresh the given token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
    };
    Model278: {
        collection?: string;
        token?: string;
    };
    Model279: {
        /** @description The source domain to sync. Example: `zoolabs.io` */
        source?: string;
    };
    Model280: {
        id: string;
        /** @enum {string} */
        status: "active" | "inactive";
    };
    Model281: {
        address: string;
        domain: string;
    };
    Model282: {
        /** @description Update community for a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string;
        community: string;
        /** @default false */
        doRetries?: boolean;
    };
    Model283: {
        fromBlock: number;
        toBlock: number;
    };
    Model284: {
        /**
         * @description If no days are passed, will automatically resync from beginning of time.
         * @default 0
         */
        days?: number;
    };
    Model285: {
        /** @enum {string} */
        method?: "events";
        events?: definitions["sampleImages"];
    };
    Model286: {
        syncDetails?: definitions["Model285"];
        fromBlock: number;
        toBlock: number;
        blocksPerBatch?: number;
        /** @default false */
        skipNonFillWrites?: boolean;
        /** @default true */
        backfill?: boolean;
    };
    Model287: {
        /** @description The api key to update */
        apiKey?: string;
        /** @enum {number} */
        tier?: 0 | 1 | 2 | 3 | 4;
        active?: boolean;
    };
    Model288: {
        /** @description The rule ID to update */
        ruleId: number;
        /** @enum {number} */
        tier?: 0 | 1 | 2 | 3 | 4;
        points?: number;
        duration?: number;
        apiKey?: string;
        /** @enum {string} */
        method?: "get" | "post" | "delete" | "put";
    };
    Model289: {
        /** @description The source domain to sync. Example: `zoolabs.io` */
        source?: string;
        icon?: string;
        title?: string;
        optimized?: boolean;
    };
    Model290: string[];
    Model291: {
        collections: definitions["Model290"];
    };
    postCreateCollectionsSetV1Response: {
        collectionsSetId?: string;
    };
    Model292: string[];
    Model293: {
        contracts: definitions["Model292"];
    };
    postCreateContractsSetV1Response: {
        contractsSetId?: string;
    };
    Model294: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "seaport-partial" | "x2y2";
        data: definitions["source"];
    };
    attribute: {
        collection: string;
        key: string;
        value: string;
    };
    Model295: {
        order?: definitions["Model294"];
        /**
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "reservoir" | "opensea" | "looks-rare";
        orderbookApiKey?: string;
        /** @description The name of the source */
        source?: string;
        attribute?: definitions["attribute"];
        collection?: string;
        tokenSetId?: string;
        isNonFlagged?: boolean;
    };
    Model296: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "seaport-forward" | "x2y2" | "universe" | "forward" | "infinity" | "flow";
        data: definitions["source"];
    };
    Model297: {
        order?: definitions["Model296"];
        /**
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "reservoir" | "opensea" | "looks-rare" | "x2y2" | "universe" | "infinity" | "flow";
        /** @description Optional API key for the target orderbook */
        orderbookApiKey?: string;
        /** @description The source domain */
        source?: string;
        attribute?: definitions["attribute"];
        collection?: string;
        tokenSetId?: string;
        isNonFlagged?: boolean;
    };
    Model298: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "seaport-v1.2" | "x2y2" | "universe" | "forward" | "infinity" | "flow";
        data: definitions["source"];
    };
    Model299: {
        orderIndex: number;
        merkleProof: definitions["sampleImages"];
    };
    bulkData: {
        /** @enum {string} */
        kind?: "seaport-v1.2";
        data?: definitions["Model299"];
    };
    Model300: {
        order?: definitions["Model298"];
        /**
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "reservoir" | "opensea" | "looks-rare" | "x2y2" | "universe" | "infinity" | "flow";
        /** @description Optional API key for the target orderbook */
        orderbookApiKey?: string;
        attribute?: definitions["attribute"];
        collection?: string;
        tokenSetId?: string;
        isNonFlagged?: boolean;
        bulkData?: definitions["bulkData"];
    };
    Model301: definitions["Model300"][];
    Model302: {
        items?: definitions["Model301"];
        /** @description The source domain */
        source?: string;
    };
    Model303: {
        /** @enum {string} */
        kind: "looks-rare" | "zeroex-v4" | "x2y2" | "seaport" | "element" | "blur" | "rarible" | "manifold" | "infinity";
        data: definitions["source"];
    };
    Model304: definitions["Model303"][];
    Model305: {
        orders?: definitions["Model304"];
    };
    protocol_data: {
        parameters?: string;
        signature?: string;
    };
    Model306: {
        protocol_data?: definitions["protocol_data"];
    };
    seaport_offers: definitions["Model306"][];
    Model307: {
        seaport_offers?: definitions["seaport_offers"];
    };
    tokenIds: string[];
    Model308: {
        /** @description Contract address. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract: string;
        tokenIds: definitions["tokenIds"];
    };
    Model309: string[];
    Model310: {
        tokens: definitions["Model309"];
    };
    Model311: {
        /** @description Refresh the given collection. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string;
        /**
         * @description If true, will force a refresh regardless of cool down. Requires an authorized api key to be passed.
         * @default false
         */
        overrideCoolDown?: boolean;
        /**
         * @description If true, will only refresh the collection metadata.
         * @default false
         */
        metadataOnly?: boolean;
    };
    /** @description List of fees (formatted as `feeRecipient:feeBps`) to be bundled within the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00:100` */
    fees: string[];
    Model312: {
        /** @description Bid on a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string;
        /** @description Bid on a particular token set. */
        tokenSetId?: string;
        /** @description Bid on a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string;
        /** @description Bid on a particular attribute key. Example: `Composition` */
        attributeKey?: string;
        /** @description Bid on a particular attribute value. Example: `Teddy (#33)` */
        attributeValue?: string;
        /** @description Quantity of tokens user is buying. Only compatible with ERC1155 tokens. Example: `5` */
        quantity?: number;
        /** @description Amount bidder is willing to offer in wei. Example: `1000000000000000000` */
        weiPrice: string;
        /**
         * @description Exchange protocol used to create order. Example: `seaport`
         * @default seaport
         * @enum {string}
         */
        orderKind?: "zeroex-v4" | "seaport" | "looks-rare" | "x2y2" | "universe" | "forward" | "infinity" | "flow";
        /**
         * @description Orderbook where order is placed. Example: `Zoo`
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "reservoir" | "opensea" | "looks-rare" | "x2y2" | "universe" | "infinity" | "flow";
        /** @description Optional API key for the target orderbook */
        orderbookApiKey?: string;
        /**
         * @description If true, royalties will be automatically included.
         * @default true
         */
        automatedRoyalties?: boolean;
        fees?: definitions["fees"];
        /**
         * @description If true flagged tokens will be excluded
         * @default false
         */
        excludeFlaggedTokens?: boolean;
        /** @description Unix timestamp (seconds) indicating when listing will be listed. Example: `1656080318` */
        listingTime?: string;
        /** @description Unix timestamp (seconds) indicating when listing will expire. Example: `1656080318` */
        expirationTime?: string;
        /** @description Optional. Random string to make the order unique */
        salt?: string;
        /** @description Optional. Set a custom nonce */
        nonce?: string;
        /** @default 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 */
        currency?: string;
    };
    params: definitions["Model312"][];
    Model313: {
        /** @description Address of wallet making the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        maker: string;
        /** @description Domain of your app that is creating the order, e.g. `myapp.xyz`. This is used for filtering, and to attribute the "order source" of sales in on-chain analytics, to help your app get discovered. Lean more <a href='https://docs.reservoir.tools/docs/calldata-attribution'>here</a> */
        source?: string;
        params?: definitions["params"];
    };
    Model314: {
        id: string;
        /** @enum {string} */
        kind: "request" | "signature" | "transaction";
        action: string;
        description: string;
        items: definitions["Model113"];
    };
    Model315: definitions["Model314"][];
    getExecuteBidV4Response: {
        steps?: definitions["Model315"];
        query?: definitions["source"];
    };
    Model316: {
        /** @description Bid on a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string;
        /** @description Bid on a particular token set. */
        tokenSetId?: string;
        /** @description Bid on a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string;
        /** @description Bid on a particular attribute key. Example: `Composition` */
        attributeKey?: string;
        /** @description Bid on a particular attribute value. Example: `Teddy (#33)` */
        attributeValue?: string;
        /** @description Quantity of tokens user is buying. Only compatible with ERC1155 tokens. Example: `5` */
        quantity?: number;
        /** @description Amount bidder is willing to offer in wei. Example: `1000000000000000000` */
        weiPrice: string;
        /**
         * @description Exchange protocol used to create order. Example: `seaport`
         * @default seaport-v1.2
         * @enum {string}
         */
        orderKind?: "zeroex-v4" | "seaport" | "seaport-v1.2" | "looks-rare" | "x2y2" | "universe" | "infinity" | "flow";
        /**
         * @description Orderbook where order is placed. Example: `Zoo`
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "reservoir" | "opensea" | "looks-rare" | "x2y2" | "universe" | "infinity" | "flow";
        /** @description Optional API key for the target orderbook */
        orderbookApiKey?: string;
        /**
         * @description If true, royalties will be automatically included.
         * @default true
         */
        automatedRoyalties?: boolean;
        fees?: definitions["fees"];
        /**
         * @description If true flagged tokens will be excluded
         * @default false
         */
        excludeFlaggedTokens?: boolean;
        /** @description Unix timestamp (seconds) indicating when listing will be listed. Example: `1656080318` */
        listingTime?: string;
        /** @description Unix timestamp (seconds) indicating when listing will expire. Example: `1656080318` */
        expirationTime?: string;
        /** @description Optional. Random string to make the order unique */
        salt?: string;
        /** @description Optional. Set a custom nonce */
        nonce?: string;
        /** @default 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 */
        currency?: string;
    };
    Model317: definitions["Model316"][];
    Model318: {
        /** @description Address of wallet making the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        maker: string;
        /** @description Domain of your app that is creating the order, e.g. `myapp.xyz`. This is used for filtering, and to attribute the "order source" of sales in on-chain analytics, to help your app get discovered. Lean more <a href='https://docs.reservoir.tools/docs/calldata-attribution'>here</a> */
        source?: string;
        params?: definitions["Model317"];
    };
    Model319: {
        /** @enum {string} */
        status: "complete" | "incomplete";
        data?: definitions["source"];
        orderIndexes?: definitions["floorAskPrices"];
    };
    Model320: definitions["Model319"][];
    Model321: {
        id: string;
        /** @enum {string} */
        kind: "request" | "signature" | "transaction";
        action: string;
        description: string;
        items: definitions["Model320"];
    };
    Model322: definitions["Model321"][];
    Model323: {
        message?: string;
        orderIndex?: number;
    };
    errors: definitions["Model323"][];
    getExecuteBidV5Response: {
        steps?: definitions["Model322"];
        errors?: definitions["errors"];
    };
    orderIds: string[];
    Model324: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "x2y2" | "universe";
        data: definitions["source"];
    };
    rawOrders: definitions["Model324"][];
    /** @description Array of tokens user is buying. Example: `tokens[0]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:704 tokens[1]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:979` */
    Model325: string[];
    /** @description List of fees (formatted as `feeRecipient:feeBps`) to be taken when filling. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00:100` */
    feesOnTop: string[];
    Model326: {
        orderIds?: definitions["orderIds"];
        rawOrders?: definitions["rawOrders"];
        tokens?: definitions["Model325"];
        /** @description Quantity of tokens user is buying. Only compatible when buying a single ERC1155 token. Example: `5` */
        quantity?: number;
        /** @description Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        taker: string;
        /** @description Address of wallet relaying the filling transaction */
        relayer?: string;
        /**
         * @description If true, only the path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /** @description If true, all fills will be executed through the router. */
        forceRouter?: boolean;
        /** @default 0x0000000000000000000000000000000000000000 */
        currency?: string;
        /**
         * @description If there are multiple listings with equal best price, prefer this source over others.
         * NOTE: if you want to fill a listing that is not the best priced, you need to pass a specific order ID.
         */
        preferredOrderSource?: string;
        /** @description Domain of your app that is filling the order, e.g. `myapp.xyz`. This is used to attribute the "fill source" of sales in on-chain analytics, to help your app get discovered. Learn more <a href='https://docs.reservoir.tools/docs/calldata-attribution'>here</a> */
        source?: string;
        feesOnTop?: definitions["feesOnTop"];
        /**
         * @description If true, partial orders will be accepted.
         * @default false
         */
        partial?: boolean;
        /**
         * @description If true, then skip any errors in processing.
         * @default false
         */
        skipErrors?: boolean;
        /** @description Optional. Set custom gas price. */
        maxFeePerGas?: string;
        /** @description Optional. Set custom gas price. */
        maxPriorityFeePerGas?: string;
        /**
         * @description If true, balance check will be skipped.
         * @default false
         */
        skipBalanceCheck?: boolean;
    };
    /** @description List of fees (formatted as `feeRecipient:feeAmount`) to be taken when filling. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00:1000000000000000` */
    Model327: string[];
    Model328: {
        orderIds?: definitions["orderIds"];
        rawOrders?: definitions["rawOrders"];
        tokens?: definitions["Model325"];
        /** @description Quantity of tokens user is buying. Only compatible when buying a single ERC1155 token. Example: `5` */
        quantity?: number;
        /** @description Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        taker: string;
        /** @description Address of wallet relaying the filling transaction */
        relayer?: string;
        /**
         * @description If true, only the path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /** @description If true, all fills will be executed through the router. */
        forceRouter?: boolean;
        /** @default 0x0000000000000000000000000000000000000000 */
        currency?: string;
        /** @default true */
        normalizeRoyalties?: boolean;
        /**
         * @description If there are multiple listings with equal best price, prefer this source over others.
         * NOTE: if you want to fill a listing that is not the best priced, you need to pass a specific order ID.
         */
        preferredOrderSource?: string;
        /** @description Filling source used for attribution. Example: `zoolabs.io` */
        source?: string;
        feesOnTop?: definitions["Model327"];
        /**
         * @description If true, any off-chain or on-chain errors will be skipped.
         * @default false
         */
        partial?: boolean;
        /** @description Optional. Set custom gas price. */
        maxFeePerGas?: string;
        /** @description Optional. Set custom gas price. */
        maxPriorityFeePerGas?: string;
        /**
         * @description If true, balance check will be skipped.
         * @default false
         */
        skipBalanceCheck?: boolean;
        /** @description Override the X2Y2 API key used for filling. */
        x2y2ApiKey?: string;
    };
    Model329: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "x2y2" | "universe" | "rarible" | "infinity" | "sudoswap" | "flow" | "nftx";
        data: definitions["source"];
    };
    Model330: definitions["Model329"][];
    /**
     * @description List of fees (formatted as `feeRecipient:feeAmount`) to be taken when filling.
     * Unless overridden via the `currency` param, the currency used for any fees on top matches the buy-in currency detected by the backend.
     * Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00:1000000000000000`
     */
    Model331: string[];
    Model332: {
        orderIds?: definitions["orderIds"];
        rawOrders?: definitions["Model330"];
        tokens?: definitions["Model325"];
        /** @description Quantity of tokens user is buying. Only compatible when buying a single ERC1155 token. Example: `5` */
        quantity?: number;
        /** @description Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        taker: string;
        /** @description Address of wallet relaying the filling transaction */
        relayer?: string;
        /**
         * @description If true, only the path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /** @description If true, all fills will be executed through the router. */
        forceRouter?: boolean;
        /**
         * @description Currency to buy all listings in.
         * @enum {string}
         */
        currency?: "0x0000000000000000000000000000000000000000";
        /** @default false */
        normalizeRoyalties?: boolean;
        /**
         * @description If there are multiple listings with equal best price, prefer this source over others.
         * NOTE: if you want to fill a listing that is not the best priced, you need to pass a specific order ID.
         */
        preferredOrderSource?: string;
        /** @description Filling source used for attribution. Example: `zoolabs.io` */
        source?: string;
        feesOnTop?: definitions["Model331"];
        /**
         * @description If true, any off-chain or on-chain errors will be skipped.
         * @default false
         */
        partial?: boolean;
        /** @description Optional. Set custom gas price. */
        maxFeePerGas?: string;
        /** @description Optional. Set custom gas price. */
        maxPriorityFeePerGas?: string;
        /**
         * @description If true, balance check will be skipped.
         * @default false
         */
        skipBalanceCheck?: boolean;
        /**
         * @description If true, do not filter out inactive orders (only relevant for order id filtering).
         * @default false
         */
        allowInactiveOrderIds?: boolean;
        /** @description Override the X2Y2 API key used for filling. */
        x2y2ApiKey?: string;
    };
    Model333: {
        id: string;
        action: string;
        description: string;
        /** @enum {string} */
        kind: "transaction";
        items: definitions["items"];
    };
    Model334: definitions["Model333"][];
    getExecuteBuyV6Response: {
        steps?: definitions["Model334"];
        path?: definitions["Model111"];
    };
    /** @description Optional raw order to fill. */
    rawOrder: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "x2y2" | "universe" | "rarible" | "infinity" | "sudoswap" | "flow" | "nftx";
        data: definitions["source"];
    };
    Model335: {
        /** @description Token to buy. */
        token: string;
        /**
         * @description Quantity of tokens to buy.
         * @default 1
         */
        quantity?: number;
        /** @description Optional order id to fill. */
        orderId?: string;
        rawOrder?: definitions["rawOrder"];
        /**
         * @description If there are multiple listings with equal best price, prefer this source over others.
         * NOTE: if you want to fill a listing that is not the best priced, you need to pass a specific order id.
         */
        preferredOrderSource?: string;
    };
    /** @description List of items to buy. */
    Model336: definitions["Model335"][];
    Model337: {
        items: definitions["Model336"];
        /** @description Address of wallet filling. */
        taker: string;
        /** @description Address of wallet relaying the fill transaction. */
        relayer?: string;
        /**
         * @description If true, only the path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /** @description If true, all fills will be executed through the router. */
        forceRouter?: boolean;
        /**
         * @description Currency to be used for purchases.
         * @enum {string}
         */
        currency?: "0x0000000000000000000000000000000000000000";
        /**
         * @description Charge any missing royalties.
         * @default false
         */
        normalizeRoyalties?: boolean;
        /**
         * @description If true, inactive orders will not be skipped over (only relevant when filling via a specific order id).
         * @default false
         */
        allowInactiveOrderIds?: boolean;
        /** @description Filling source used for attribution. Example: `zoolabs.io` */
        source?: string;
        feesOnTop?: definitions["Model331"];
        /**
         * @description If true, any off-chain or on-chain errors will be skipped.
         * @default false
         */
        partial?: boolean;
        /**
         * @description If true, balance check will be skipped.
         * @default false
         */
        skipBalanceCheck?: boolean;
        /** @description Optional custom gas settings. */
        maxFeePerGas?: string;
        /** @description Optional custom gas settings. */
        maxPriorityFeePerGas?: string;
        /** @description Optional X2Y2 API key used for filling. */
        x2y2ApiKey?: string;
    };
    Model338: {
        id: string;
        action: string;
        description: string;
        /** @enum {string} */
        kind: "signature" | "transaction";
        items: definitions["items"];
    };
    Model339: definitions["Model338"][];
    getExecuteBuyV7Response: {
        steps?: definitions["Model339"];
        path?: definitions["Model111"];
    };
    Model340: {
        /** @description Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /** @description Quanity of tokens user is listing. Only compatible with ERC1155 tokens. Example: `5` */
        quantity?: number;
        /** @description Amount seller is willing to sell for in wei. Example: `1000000000000000000` */
        weiPrice: string;
        /**
         * @description Exchange protocol used to create order. Example: `seaport`
         * @default seaport
         * @enum {string}
         */
        orderKind?: "looks-rare" | "zeroex-v4" | "seaport" | "x2y2";
        /**
         * @description Orderbook where order is placed. Example: `Zoo`
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "opensea" | "looks-rare" | "reservoir" | "x2y2";
        /**
         * @description If true, royalties will be automatically included.
         * @default true
         */
        automatedRoyalties?: boolean;
        fee?: string;
        feeRecipient?: string;
        /** @description Unix timestamp (seconds) indicating when listing will be listed. Example: `1656080318` */
        listingTime?: string;
        /** @description Unix timestamp (seconds) indicating when listing will expire. Example: `1656080318` */
        expirationTime?: string;
        /** @description Optional. Random string to make the order unique */
        salt?: string;
        /** @description Optional. Set a custom nonce */
        nonce?: string;
        /** @default 0x0000000000000000000000000000000000000000 */
        currency?: string;
    };
    Model341: definitions["Model340"][];
    Model342: {
        /** @description Address of wallet making the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        maker: string;
        /** @description Domain of the platform that created the order. Example: `chimpers.xyz` */
        source?: string;
        params?: definitions["Model341"];
    };
    Model343: {
        /** @enum {string} */
        kind: "request" | "signature" | "transaction";
        action: string;
        description: string;
        items: definitions["Model113"];
    };
    Model344: definitions["Model343"][];
    getExecuteListV3Response: {
        steps?: definitions["Model344"];
    };
    Model345: {
        /** @description Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /** @description Quantity of tokens user is listing. Only compatible with ERC1155 tokens. Example: `5` */
        quantity?: number;
        /** @description Amount seller is willing to sell for in wei. Example: `1000000000000000000` */
        weiPrice: string;
        /**
         * @description Exchange protocol used to create order. Example: `seaport`
         * @default seaport
         * @enum {string}
         */
        orderKind?: "looks-rare" | "zeroex-v4" | "seaport" | "seaport-forward" | "x2y2" | "universe" | "infinity" | "flow";
        /**
         * @description Orderbook where order is placed. Example: `Zoo`
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "opensea" | "looks-rare" | "reservoir" | "x2y2" | "universe" | "infinity" | "flow";
        /** @description Optional API key for the target orderbook */
        orderbookApiKey?: string;
        /**
         * @description If true, royalties will be automatically included.
         * @default true
         */
        automatedRoyalties?: boolean;
        fees?: definitions["fees"];
        /** @description Unix timestamp (seconds) indicating when listing will be listed. Example: `1656080318` */
        listingTime?: string;
        /** @description Unix timestamp (seconds) indicating when listing will expire. Example: `1656080318` */
        expirationTime?: string;
        /** @description Optional. Random string to make the order unique */
        salt?: string;
        /** @description Optional. Set a custom nonce */
        nonce?: string;
        /** @default 0x0000000000000000000000000000000000000000 */
        currency?: string;
    };
    Model346: definitions["Model345"][];
    Model347: {
        /** @description Address of wallet making the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        maker: string;
        /** @description Domain of your app that is creating the order, e.g. `myapp.xyz`. This is used for filtering, and to attribute the "order source" of sales in on-chain analytics, to help your app get discovered. Lean more <a href='https://docs.reservoir.tools/docs/calldata-attribution'>here</a> */
        source?: string;
        params?: definitions["Model346"];
    };
    getExecuteListV4Response: {
        steps?: definitions["Model315"];
    };
    Model348: {
        /** @description Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /** @description Quantity of tokens user is listing. Only compatible with ERC1155 tokens. Example: `5` */
        quantity?: number;
        /** @description Amount seller is willing to sell for in wei. Example: `1000000000000000000` */
        weiPrice: string;
        /**
         * @description Exchange protocol used to create order. Example: `seaport-v1.2`
         * @default seaport-v1.2
         * @enum {string}
         */
        orderKind?: "looks-rare" | "zeroex-v4" | "seaport" | "seaport-v1.2" | "x2y2" | "universe" | "infinity" | "flow";
        /**
         * @description Orderbook where order is placed. Example: `Zoo`
         * @default reservoir
         * @enum {string}
         */
        orderbook?: "opensea" | "looks-rare" | "reservoir" | "x2y2" | "universe" | "infinity" | "flow";
        /** @description Optional API key for the target orderbook */
        orderbookApiKey?: string;
        /**
         * @description If true, royalties will be automatically included.
         * @default true
         */
        automatedRoyalties?: boolean;
        fees?: definitions["fees"];
        /** @description Unix timestamp (seconds) indicating when listing will be listed. Example: `1656080318` */
        listingTime?: string;
        /** @description Unix timestamp (seconds) indicating when listing will expire. Example: `1656080318` */
        expirationTime?: string;
        /** @description Optional. Random string to make the order unique */
        salt?: string;
        /** @description Optional. Set a custom nonce */
        nonce?: string;
        /** @default 0x0000000000000000000000000000000000000000 */
        currency?: string;
    };
    Model349: definitions["Model348"][];
    Model350: {
        /** @description Address of wallet making the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        maker: string;
        /** @description Domain of your app that is creating the order, e.g. `myapp.xyz`. This is used for filtering, and to attribute the "order source" of sales in on-chain analytics, to help your app get discovered. Lean more <a href='https://docs.reservoir.tools/docs/calldata-attribution'>here</a> */
        source?: string;
        params?: definitions["Model349"];
    };
    Model351: {
        /**
         * @description Type of permit
         * @enum {string}
         */
        kind: "nft-permit" | "ft-permit";
        /** @description Id of the permit */
        id: string;
    };
    Model352: {
        orderId?: string;
        /** @description Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /** @description Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        taker: string;
        /** @description Quantity of tokens user is selling. Only compatible when selling a single ERC1155 token. Example: `5` */
        quantity?: number;
        /** @description Domain of your app that is filling the order, e.g. `myapp.xyz`. This is used to attribute the "fill source" of sales in on-chain analytics, to help your app get discovered. Learn more <a href='https://docs.reservoir.tools/docs/calldata-attribution'>here</a> */
        source?: string;
        /**
         * @description If true, only the path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /** @description Optional. Set custom gas price. */
        maxFeePerGas?: string;
        /** @description Optional. Set custom gas price. */
        maxPriorityFeePerGas?: string;
    };
    Model353: {
        orderId?: string;
        /** @description Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /** @description Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        taker: string;
        /** @description Quantity of tokens user is selling. Only compatible when selling a single ERC1155 token. Example: `5` */
        quantity?: number;
        /** @description Filling source used for attribution. Example: `zoolabs.io` */
        source?: string;
        /**
         * @description If true, only the path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /** @default false */
        normalizeRoyalties?: boolean;
        /** @description Optional. Set custom gas price. */
        maxFeePerGas?: string;
        /** @description Optional. Set custom gas price. */
        maxPriorityFeePerGas?: string;
        /** @description Override the X2Y2 API key used for filling. */
        x2y2ApiKey?: string;
    };
    Model354: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "seaport-partial" | "x2y2" | "universe" | "infinity" | "flow";
        data: definitions["source"];
    };
    /**
     * @description List of fees (formatted as `feeRecipient:feeAmount`) to be taken when filling.
     * The currency used for any fees on top matches the accepted bid's currency.
     * Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00:1000000000000000`
     */
    Model355: string[];
    Model356: {
        orderId?: string;
        rawOrder?: definitions["Model354"];
        /** @description Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /** @description Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
        taker: string;
        /** @description Quantity of tokens user is selling. Only compatible when selling a single ERC1155 token. Example: `5` */
        quantity?: number;
        /** @description Filling source used for attribution. Example: `zoolabs.io` */
        source?: string;
        feesOnTop?: definitions["Model355"];
        /**
         * @description If true, only the path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /** @default false */
        normalizeRoyalties?: boolean;
        /**
         * @description If true, do not filter out inactive orders (only relevant for order id filtering).
         * @default false
         */
        allowInactiveOrderIds?: boolean;
        /** @description Optional. Set custom gas price. */
        maxFeePerGas?: string;
        /** @description Optional. Set custom gas price. */
        maxPriorityFeePerGas?: string;
        /** @description Override the X2Y2 API key used for filling. */
        x2y2ApiKey?: string;
    };
    /** @description Optional raw order to sell into. */
    Model357: {
        /** @enum {string} */
        kind: "opensea" | "looks-rare" | "zeroex-v4" | "seaport" | "x2y2" | "universe" | "rarible" | "infinity" | "sudoswap" | "nftx";
        data: definitions["source"];
    };
    Model358: {
        /** @description Token to sell. */
        token: string;
        /**
         * @description Quantity of tokens to sell.
         * @default 1
         */
        quantity?: number;
        /** @description Optional order id to sell into. */
        orderId?: string;
        rawOrder?: definitions["Model357"];
    };
    /** @description List of items to sell. */
    Model359: definitions["Model358"][];
    Model360: {
        items: definitions["Model359"];
        /** @description Address of wallet filling. */
        taker: string;
        /** @description Filling source used for attribution. */
        source?: string;
        /**
         * @description If true, only the filling path will be returned.
         * @default false
         */
        onlyPath?: boolean;
        /**
         * @description Charge any missing royalties.
         * @default false
         */
        normalizeRoyalties?: boolean;
        /**
         * @description If true, inactive orders will not be skipped over (only relevant when filling via a specific order id).
         * @default false
         */
        allowInactiveOrderIds?: boolean;
        /**
         * @description If true, any off-chain or on-chain errors will be skipped.
         * @default false
         */
        partial?: boolean;
        /** @description Optional custom gas settings. */
        maxFeePerGas?: string;
        /** @description Optional custom gas settings. */
        maxPriorityFeePerGas?: string;
        /** @description Optional X2Y2 API key used for filling. */
        x2y2ApiKey?: string;
    };
    Model361: {
        /** @description The token to update the flag status for. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /**
         * @description 0 - Token is not flagged, 1 - Token is flagged
         * @enum {number}
         */
        flag: 0 | 1;
    };
    Model362: {
        /** @description Refresh the given token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token: string;
        /**
         * @description If true, will force a refresh regardless of cool down. Requires an authorized api key to be passed.
         * @default false
         */
        overrideCoolDown?: boolean;
    };
    Model363: {
        token?: string;
        /**
         * @default v6
         * @enum {string}
         */
        router?: "v5" | "v6";
    };
    Model364: {
        token?: string;
    };
    Model365: {
        id: string;
        /** @default false */
        skipRevalidation?: boolean;
    };
}
export interface operations {
    /** This API can be used to scrape all of the activities */
    getActivityV1: {
        parameters: {
            query: {
                limit?: number;
                continuation?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getActivityV1Response"];
            };
        };
    };
    /** This API can be used to scrape all of the activities */
    getActivityV2: {
        parameters: {
            query: {
                limit?: number;
                continuation?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getActivityV2Response"];
            };
        };
    };
    /** This API can be used to scrape all of the activities */
    getActivityV3: {
        parameters: {
            query: {
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                limit?: number;
                continuation?: string;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getActivityV3Response"];
            };
        };
    };
    /** This API can be used to scrape all of the activities */
    getActivityV4: {
        parameters: {
            query: {
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                limit?: number;
                continuation?: string;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getActivityV4Response"];
            };
        };
    };
    getAdminGetmarketplaces: {
        responses: {
            /** Successful */
            200: {
                schema: definitions["getMarketplacesv1Resp"];
            };
        };
    };
    getAdminOpenapi: {
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getAdminRatelimitrules: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            query: {
                /** The route to get rules for */
                route?: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getAssetsV1: {
        parameters: {
            query: {
                asset: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getAttributesV1: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAttributesV1Response"];
            };
        };
    };
    /** Get detailed information about a single collection, including real-time stats. */
    getCollectionV1: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                id?: string;
                /** Filter to a particular slug, e.g. `boredapeyachtclub` */
                slug?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionV1Response"];
            };
        };
    };
    /** Get detailed information about a single collection, including real-time stats. */
    getCollectionV2: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                id?: string;
                /** Filter to a particular collection slug. Example: `boredapeyachtclub` */
                slug?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionV2Response"];
            };
        };
    };
    /** Get detailed information about a single collection, including real-time stats. */
    getCollectionV3: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                id?: string;
                /** Filter to a particular collection slug. Example: `boredapeyachtclub` */
                slug?: string;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionV3Response"];
            };
        };
    };
    /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
    getCollectionsV1: {
        parameters: {
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Search for collections that match a string, e.g. `bored` */
                name?: string;
                /** Filter to a particular slug, e.g. `boredapeyachtclub` */
                slug?: string;
                sortBy?: "1DayVolume" | "allTimeVolume";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsV1Response"];
            };
        };
    };
    /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
    getCollectionsV2: {
        parameters: {
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Search for collections that match a string, e.g. `bored` */
                name?: string;
                /** Filter to a particular slug, e.g. `boredapeyachtclub` */
                slug?: string;
                sortBy?: "1DayVolume" | "7DayVolume" | "30DayVolume" | "allTimeVolume";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsV2Response"];
            };
        };
    };
    /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
    getCollectionsV3: {
        parameters: {
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Search for collections that match a string, e.g. `bored` */
                name?: string;
                /** Filter to a particular slug, e.g. `boredapeyachtclub` */
                slug?: string;
                sortBy?: "1DayVolume" | "7DayVolume" | "30DayVolume" | "allTimeVolume";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsV3Response"];
            };
        };
    };
    /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
    getCollectionsV4: {
        parameters: {
            query: {
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                contract?: string[] | string;
                /** Search for collections that match a string. Example: `bored` */
                name?: string;
                /** Filter to a particular collection slug. Example: `boredapeyachtclub` */
                slug?: string;
                /** Order the items are returned in the response. */
                sortBy?: "1DayVolume" | "7DayVolume" | "30DayVolume" | "allTimeVolume";
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsV4Response"];
            };
        };
    };
    /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
    getCollectionsV5: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                id?: string;
                /** Filter to a particular collection slug. Example: `boredapeyachtclub` */
                slug?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                contract?: string[] | string;
                /** Search for collections that match a string. Example: `bored` */
                name?: string;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** If true, attributes will be included in the response. (supported only when filtering to a particular collection using `id` or `slug`) */
                includeAttributes?: boolean;
                /** If true, owner count will be included in the response. (supported only when filtering to a particular collection using `id` or `slug`) */
                includeOwnerCount?: boolean;
                /** If true, sales count (1 day, 7 day, 30 day, all time) will be included in the response. (supported only when filtering to a particular collection using `id` or `slug`) */
                includeSalesCount?: boolean;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** If true, return the non flagged floor ask. (only supported when `normalizeRoyalties` is false) */
                useNonFlaggedFloorAsk?: boolean;
                /** Order the items are returned in the response. */
                sortBy?: "1DayVolume" | "7DayVolume" | "30DayVolume" | "allTimeVolume" | "createdAt" | "floorAskPrice";
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsV5Response"];
            };
        };
    };
    /** Access orders with various filters applied. If you need orders created by a single user, use the positions API instead. */
    getOrdersV1: {
        parameters: {
            query: {
                id?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersV1Response"];
            };
        };
    };
    postOrdersV1: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model305"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    /** Access orders with various filters applied. If you need orders created by a single user, use the positions API instead. */
    getOrdersV2: {
        parameters: {
            query: {
                id?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersV2Response"];
            };
        };
    };
    /** Get owners with various filters applied, and a summary of their ownership. Useful for exploring top owners in a collection or attribute. */
    getOwnersV1: {
        parameters: {
            query: {
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOwnersV1Response"];
            };
        };
    };
    /** Get recent sales for a contract or token. */
    getSalesV1: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSalesV1Response"];
            };
        };
    };
    /** Get recent sales for a contract or token. */
    getSalesV2: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSalesV2Response"];
            };
        };
    };
    /** Get recent sales for a contract or token. Note: this API is returns rich metadata, and has advanced filters, so is only designed for small amounts of recent sales. If you want access to sales in bulk, use the `Aggregator > Bulk Sales` API. */
    getSalesV3: {
        parameters: {
            query: {
                contract?: string[] | string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
                /** Filter to a particular transaction. Example: `0x04654cc4c81882ed4d20b958e0eeb107915d75730110cce65333221439de6afc` */
                txHash?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSalesV3Response"];
            };
        };
    };
    /** Get recent sales for a contract or token. */
    getSalesV4: {
        parameters: {
            query: {
                contract?: string[] | string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** If enabled, also include token metadata in the response. */
                includeTokenMetadata?: boolean;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
                /** Filter to a particular transaction. Example: `0x04654cc4c81882ed4d20b958e0eeb107915d75730110cce65333221439de6afc` */
                txHash?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSalesV4Response"];
            };
        };
    };
    /** This API returns a list of sources */
    getSourcesV1: {
        parameters: {
            query: {
                /** Order of the items are returned in the response. */
                sortBy?: "domain" | "createdAt";
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Filter to a particular domain. Example: `x2y2.io` */
                domain?: string;
                /** Amount of items returned in response. */
                limit?: number;
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSourcesV1Response"];
            };
        };
    };
    /** Get aggregate stats for a particular set (collection, attribute or single token) */
    getStatsV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getStatsV1Response"];
            };
        };
    };
    /** Get aggregate stats for a particular set (collection, attribute or single token) */
    getStatsV2: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getStatsV2Response"];
            };
        };
    };
    /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
    getTokensV1: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Limit to tokens that are listed for sale */
                onSale?: boolean;
                sortBy?: "tokenId" | "floorAskPrice" | "topBidValue";
                sortDirection?: "asc" | "desc";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensV1Response"];
            };
        };
    };
    /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
    getTokensV2: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
                attributes?: string;
                sortBy?: "floorAskPrice" | "topBidValue";
                limit?: number;
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensV2Response"];
            };
        };
    };
    /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
    getTokensV3: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to one or more tokens, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                tokens?: string[] | string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
                attributes?: string;
                sortBy?: "floorAskPrice" | "topBidValue";
                limit?: number;
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensV3Response"];
            };
        };
    };
    /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the tokens/details API */
    getTokensV4: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Array of tokens. Example: `tokens[0]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:704tokens[1]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:979` */
                tokens?: string[] | string;
                /** Filter to a particular token set. Example: token:0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270:129000685 */
                tokenSetId?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
                /** Domain of the order source. Example `opensea.io` */
                source?: string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** Order the items are returned in the response, by default sorted by `floorAskPrice`. Not supported when filtering by `contract`. When filtering by `contract` the results are sorted by `tokenId` by default. */
                sortBy?: "floorAskPrice" | "tokenId" | "rarity";
                sortDirection?: "asc" | "desc";
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensV4Response"];
            };
        };
    };
    /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. */
    getTokensV5: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token by name. Example: `token #1` */
                tokenName?: string;
                /** Array of tokens. Example: `tokens[0]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:704 tokens[1]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:979` */
                tokens?: string[] | string;
                /** Filter to a particular token set. `Example: token:0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270:129000685` */
                tokenSetId?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
                /** Domain of the order source. Example `opensea.io` (Only listed tokens are returned when filtering by source) */
                source?: string;
                /** Get tokens with a min rarity rank (inclusive) */
                minRarityRank?: number;
                /** Get tokens with a max rarity rank (inclusive) */
                maxRarityRank?: number;
                /** Get tokens with a min floor ask price (inclusive) */
                minFloorAskPrice?: number;
                /** Get tokens with a max floor ask price (inclusive) */
                maxFloorAskPrice?: number;
                /**
                 * Allowed only with collection and tokens filtering!
                 * -1 = All tokens (default)
                 * 0 = Non flagged tokens
                 * 1 = Flagged tokens
                 */
                flagStatus?: -1 | 0 | 1;
                /** Order the items are returned in the response. */
                sortBy?: "floorAskPrice" | "tokenId" | "rarity";
                sortDirection?: "asc" | "desc";
                /** Filter to tokens with a listing in a particular currency. `Example: currencies[0]: 0x0000000000000000000000000000000000000000` */
                currencies?: string[] | string;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** If true, attributes will be returned in the response. */
                includeAttributes?: boolean;
                /** If true, quantity filled and quantity remaining will be returned in the response. */
                includeQuantity?: boolean;
                /** If true, dynamic pricing data will be returned in the response. */
                includeDynamicPricing?: boolean;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensV5Response"];
            };
        };
    };
    /** Get recent transfers for a contract or token. */
    getTransfersV2: {
        parameters: {
            query: {
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
                attributes?: string;
                /** Filter to a particular transaction. Example: `0x04654cc4c81882ed4d20b958e0eeb107915d75730110cce65333221439de6afc` */
                txHash?: string;
                limit?: number;
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTransfersV2Response"];
            };
        };
    };
    getAdminGetapikeyKey: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            path: {
                /** The API key */
                key: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getApiKeyRateLimitsResponse"];
            };
        };
    };
    /** Get the rate limits for the given API key */
    getApikeysKeyRatelimits: {
        parameters: {
            path: {
                /** The API key */
                key: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["Model75"];
            };
        };
    };
    /** This API can be used to build a feed for a collection */
    getCollectionsActivityV4: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Amount of items returned in response. If `includeMetadata=true` max limit is 20, otherwise max limit is 1,000. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionActivityV4Response"];
            };
        };
    };
    /** This API can be used to build a feed for a collection */
    getCollectionsActivityV5: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Amount of items returned in response. If `includeMetadata=true` max limit is 50, otherwise max limit is 1,000. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionActivityV5Response"];
            };
        };
    };
    /** Get date, volume, rank and sales count for each collection */
    getCollectionsDailyvolumesV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                id: string;
                /** Amount of items returned in response. */
                limit?: number;
                /** The start timestamp you want to filter on (UTC) */
                startTimestamp?: number;
                /** The end timestamp you want to filter on (UTC) */
                endTimestamp?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getDailyVolumesV1Response"];
            };
        };
    };
    /** This API returns aggregated listings info for the given collection per source */
    getCollectionsSourcesV1: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSourcesListingsV1Response"];
            };
        };
    };
    /** Get detailed information about a single collection, including real-time stats. */
    getCollectionsCollectionorslugV1: {
        parameters: {
            path: {
                collectionOrSlug: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionDeprecatedV1Response"];
            };
        };
    };
    /** Get updates any time an asks status changes */
    getEventsAsksV2: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAsksEventsV2Response"];
            };
        };
    };
    /** Get updates any time an asks status changes */
    getEventsAsksV3: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, criteria metadata is included in the response. */
                includeCriteriaMetadata?: boolean;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAsksEventsV3Response"];
            };
        };
    };
    /** Get updates any time a bid status changes */
    getEventsBidsV1: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, bid criteria is included in the response. */
                includeCriteria?: boolean;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getBidEventsV1Response"];
            };
        };
    };
    /** Get updates any time a bid status changes */
    getEventsBidsV2: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, criteria metadata is included in the response. */
                includeCriteriaMetadata?: boolean;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getBidEventsV2Response"];
            };
        };
    };
    /** Get updates any time a bid status changes */
    getEventsBidsV3: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, criteria metadata is included in the response. */
                includeCriteriaMetadata?: boolean;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getBidEventsV3Response"];
            };
        };
    };
    /** Get updates any time an order status changes */
    getEventsOrdersV1: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrderEventsV1Response"];
            };
        };
    };
    /** Generate a bid and submit it to multiple marketplaces */
    getExecuteBidV2: {
        parameters: {
            query: {
                /** Bid on a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Bid on a particular token set. */
                tokenSetId?: string;
                /** Bid on a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Bid on a particular attribute key. Example: `Composition` */
                attributeKey?: string;
                /** Bid on a particular attribute value. Example: `Teddy (#33)` */
                attributeValue?: string;
                /** Quanity of tokens user is buying. Only compatible with ERC1155 tokens. Example: `5` */
                quantity?: number;
                /** Address of wallet making the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker: string;
                /** Amount bidder is willing to offer in wei. Example: `1000000000000000000` */
                weiPrice: string;
                /** Exchange protocol used to create order. Example: `seaport` */
                orderKind?: "looks-rare" | "zeroex-v4" | "seaport";
                /** Orderbook where order is placed. Example: `Zoo` */
                orderbook?: "reservoir" | "opensea" | "looks-rare";
                /** Name of the platform that created the order. Example: `Chimpers Market` */
                source?: string;
                /** If true, royalties will be automatically included. */
                automatedRoyalties?: boolean;
                fee?: string;
                /** If true flagged tokens will be excluded */
                excludeFlaggedTokens?: boolean;
                /** Wallet address of fee recipient. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                feeRecipient?: string;
                /** Unix timestamp (seconds) indicating when listing will be listed. Example: `1656080318` */
                listingTime?: string;
                /** Unix timestamp (seconds) indicating when listing will expire. Example: `1656080318` */
                expirationTime?: string;
                /** Optional. Random string to make the order unique */
                salt?: string;
                /** Optional. Set a custom nonce */
                nonce?: string;
                /** Signature v component (only required after order has been signed) */
                v?: number;
                /** Signature r component (only required after order has been signed) */
                r?: string;
                /** Signature s component (only required after order has been signed) */
                s?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBidV2Response"];
            };
        };
    };
    getExecuteBuyV2: {
        parameters: {
            query: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Quanity of tokens user is buying. Only compatible with ERC1155 tokens. Example: `5` */
                quantity?: number;
                tokens?: string[];
                /** Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                taker: string;
                /** If true, only quote will be returned. */
                onlyQuote?: boolean;
                /** Filling source used for attribution. Example: `zoolabs.io` */
                source?: string;
                /** Wallet address of referrer. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                referrer?: string;
                /** Fee amount in BPS. Example: `100`. */
                referrerFeeBps?: number;
                /** If true, partial orders will be accepted. */
                partial?: boolean;
                /** Optional. Set custom gas price. */
                maxFeePerGas?: string;
                /** Optional. Set custom gas price. */
                maxPriorityFeePerGas?: string;
                /** If true, balance check will be skipped. */
                skipBalanceCheck?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV2Response"];
            };
        };
    };
    getExecuteBuyV3: {
        parameters: {
            query: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Quanity of tokens user is buying. Only compatible with ERC1155 tokens. Example: `5` */
                quantity?: number;
                tokens?: string[];
                /** Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                taker: string;
                /** If true, only the path will be returned. */
                onlyPath?: boolean;
                /** If true, all fills will be executed through the router. */
                forceRouter?: boolean;
                currency?: string;
                /** Filling source used for attribution. Example: `zoolabs.io` */
                source?: string;
                /** Wallet address of referrer. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                referrer?: string;
                /** Fee amount in BPS. Example: `100`. */
                referrerFeeBps?: number;
                /** If true, partial orders will be accepted. */
                partial?: boolean;
                /** Optional. Set custom gas price. */
                maxFeePerGas?: string;
                /** Optional. Set custom gas price. */
                maxPriorityFeePerGas?: string;
                /** If true, balance check will be skipped. */
                skipBalanceCheck?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV3Response"];
            };
        };
    };
    /** Cancel an existing order on any marketplace */
    getExecuteCancelV1: {
        parameters: {
            query: {
                /** Order Id. Example: `0x1544e82e6f2174f26233abcc35f3d478fa9c92926a91465430657987aea7d748` */
                id: string;
                /** Address of wallet cancelling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker: string;
                /** Optional. Set custom gas price */
                maxFeePerGas?: string;
                /** Optional. Set custom gas price */
                maxPriorityFeePerGas?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteCancelV1Response"];
            };
        };
    };
    /** Cancel an existing order on any marketplace */
    getExecuteCancelV2: {
        parameters: {
            query: {
                /** Order Id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                id: string;
                /** If true, the order will be soft-cancelled. */
                softCancel?: boolean;
                /** Maker signature for soft-cancelling. */
                signature?: string;
                /** Optional. Set custom gas price */
                maxFeePerGas?: string;
                /** Optional. Set custom gas price */
                maxPriorityFeePerGas?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteCancelV2Response"];
            };
        };
    };
    /** Generate a listing and submit it to multiple marketplaces */
    getExecuteListV2: {
        parameters: {
            query: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
                /** Quanity of tokens user is listing. Only compatible with ERC1155 tokens. Example: `5` */
                quantity?: number;
                /** Address of wallet making the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker: string;
                /** Amount seller is willing to sell for in wei. Example: `1000000000000000000` */
                weiPrice: string;
                /** Exchange protocol used to create order. Example: `seaport` */
                orderKind?: "looks-rare" | "zeroex-v4" | "seaport" | "x2y2";
                /** Orderbook where order is placed. Example: `Zoo` */
                orderbook?: "opensea" | "looks-rare" | "reservoir" | "x2y2";
                /** Name of the platform that created the order. Example: `Chimpers Market` */
                source?: string;
                /** If true, royalties will be automatically included. */
                automatedRoyalties?: boolean;
                fee?: string;
                feeRecipient?: string;
                listingTime?: string;
                /** Unix timestamp (seconds) indicating when listing will expire. Example: `1656080318` */
                expirationTime?: string;
                /** Optional. Random string to make the order unique */
                salt?: string;
                /** Optional. Set a custom nonce */
                nonce?: string;
                /** Signature v component (only required after order has been signed) */
                v?: number;
                /** Signature r component (only required after order has been signed) */
                r?: string;
                /** Signature s component (only required after order has been signed) */
                s?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBidV2Response"];
            };
        };
    };
    getExecuteSellV3: {
        parameters: {
            query: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
                /** Address of wallet filling the order. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                taker: string;
                /** Filling source used for attribution. Example: `zoolabs.io` */
                source?: string;
                /** Wallet address of referrer. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                referrer?: string;
                /** If true, only the path will be returned. */
                onlyPath?: boolean;
                /** Optional. Set custom gas price. */
                maxFeePerGas?: string;
                /** Optional. Set custom gas price. */
                maxPriorityFeePerGas?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV3Response"];
            };
        };
    };
    /** This API calculates the total liquidity created by users, based on the number of tokens they are top bidder for. */
    getLiquidityUsersV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user?: string;
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUsersLiquidityV1Response"];
            };
        };
    };
    /** This API calculates the total liquidity created by users, based on the number of tokens they are top bidder for. */
    getLiquidityUsersV2: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUsersLiquidityV1Response"];
            };
        };
    };
    /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersAllV1: {
        parameters: {
            query: {
                id?: string;
                /** Filter to a source by domain. Example: `opensea.io` */
                source?: string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** Sell or buy side. */
                side?: "sell" | "buy";
                /** If true, metadata will be included in the response. */
                includeMetadata?: boolean;
                /** If true, raw data will be included in the response. */
                includeRawData?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersAllV1Response"];
            };
        };
    };
    /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersAllV2: {
        parameters: {
            query: {
                id?: string;
                /** Filter to a source by domain. Example: `opensea.io` */
                source?: string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** Sell or buy side. */
                side?: "sell" | "buy";
                /** If true, metadata will be included in the response. */
                includeMetadata?: boolean;
                /** If true, raw data will be included in the response. */
                includeRawData?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersAllV2Response"];
            };
        };
    };
    /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersAsksV1: {
        parameters: {
            query: {
                /** Filter to a token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular user, e.g. `0x4d04eb67a2d1e01c71fad0366e0c200207a75487` */
                maker?: string;
                /** Filter to a particular user, e.g. `0x4d04eb67a2d1e01c71fad0366e0c200207a75487` */
                contract?: string;
                /**
                 * `active` = currently valid, `inactive` = temporarily invalid
                 *
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: "active" | "inactive";
                sortBy?: "price" | "createdAt";
                continuation?: string;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersAsksV1Response"];
            };
        };
    };
    /** Get a list of asks (listings), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersAsksV2: {
        parameters: {
            query: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker?: string;
                contracts?: string[] | string;
                /**
                 * active = currently valid, inactive = temporarily invalid
                 *
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: string;
                /** When true, private orders are included in the response. */
                includePrivate?: boolean;
                /** Order the items are returned in the response. */
                sortBy?: string;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersAsksV1Response"];
            };
        };
    };
    /** Get a list of asks (listings), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersAsksV3: {
        parameters: {
            query: {
                ids?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                contracts?: string[] | string;
                /**
                 * active = currently valid
                 * inactive = temporarily invalid
                 * expired, cancelled, filled = permanently invalid
                 *
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: string;
                source?: string[] | string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** If true, private orders are included in the response. */
                includePrivate?: boolean;
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                /** If true, raw data is included in the response. */
                includeRawData?: boolean;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Order the items are returned in the response, Sorting by price allowed only when filtering by token */
                sortBy?: "createdAt" | "price";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersAsksV3Response"];
            };
        };
    };
    /** Get a list of asks (listings), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersAsksV4: {
        parameters: {
            query: {
                ids?: string[] | string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                contracts?: string[] | string;
                /**
                 * active = currently valid
                 * inactive = temporarily invalid
                 * expired, cancelled, filled = permanently invalid
                 * any = any status
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: string;
                /** Filter to a source by domain. Example: `opensea.io` */
                source?: string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** If true, private orders are included in the response. */
                includePrivate?: boolean;
                /** If true, criteria metadata is included in the response. */
                includeCriteriaMetadata?: boolean;
                /** If true, raw data is included in the response. */
                includeRawData?: boolean;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Order the items are returned in the response, Sorting by price allowed only when filtering by token */
                sortBy?: "createdAt" | "price";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersAsksV4Response"];
            };
        };
    };
    /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersBidsV1: {
        parameters: {
            query: {
                /** Filter to a token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular user, e.g. `0x4d04eb67a2d1e01c71fad0366e0c200207a75487` */
                maker?: string;
                /**
                 * `active` = currently valid, `inactive` = temporarily invalid, `expired` = permanently invalid
                 *
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: "active" | "inactive" | "expired";
                sortBy?: "price" | "createdAt";
                continuation?: string;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersBidsV1Response"];
            };
        };
    };
    /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersBidsV2: {
        parameters: {
            query: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker?: string;
                /** Filter to an array of contracts. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contracts?: string[] | string;
                /**
                 * active = currently valid, inactive = temporarily invalid, expired = permanently invalid
                 *
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: string;
                /** Order the items are returned in the response. */
                sortBy?: string;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersBidsV1Response"];
            };
        };
    };
    /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersBidsV3: {
        parameters: {
            query: {
                ids?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker?: string;
                /** Filter to an array of contracts. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contracts?: string[] | string;
                /**
                 * active = currently valid, inactive = temporarily invalid, expired = permanently invalid
                 *
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: string;
                /** Filter to a source by domain. Example: `opensea.io` */
                source?: string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                /** If true, raw data is included in the response. */
                includeRawData?: boolean;
                /** Order the items are returned in the response, Sorting by price allowed only when filtering by token */
                sortBy?: "createdAt" | "price";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersBidsV3Response"];
            };
        };
    };
    /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersBidsV4: {
        parameters: {
            query: {
                ids?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set. Example: `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` or `token:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:1` */
                tokenSetId?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Filter to a particular collection bids with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular attribute within a collection. Example: `attribute[Mouth]=Bored` (Collection must be passed as well when filtering by attribute) */
                attribute?: string;
                /** Filter to an array of contracts. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contracts?: string[] | string;
                /**
                 * active = currently valid
                 * inactive = temporarily invalid
                 * expired, cancelled, filled = permanently invalid
                 *
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: string;
                /** Filter to a source by domain. Example: `opensea.io` */
                source?: string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                /** If true, raw data is included in the response. */
                includeRawData?: boolean;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Order the items are returned in the response, Sorting by price allowed only when filtering by token */
                sortBy?: "createdAt" | "price";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersBidsV4Response"];
            };
        };
    };
    /** Get a list of bids (offers), filtered by token, collection or maker. This API is designed for efficiently ingesting large volumes of orders, for external processing */
    getOrdersBidsV5: {
        parameters: {
            query: {
                ids?: string[] | string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set. Example: `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` or `token:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:1` */
                tokenSetId?: string;
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                maker?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection bids with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular attribute within a collection. Example: `attribute[Mouth]=Bored` (Collection must be passed as well when filtering by attribute) */
                attribute?: string;
                /** Filter to an array of contracts. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contracts?: string[] | string;
                /**
                 * active = currently valid
                 * inactive = temporarily invalid
                 * expired, cancelled, filled = permanently invalid
                 * any = any status
                 * Available when filtering by maker, otherwise only valid orders will be returned
                 */
                status?: string;
                /** Filter to a source by domain. Example: `opensea.io` */
                source?: string;
                /** If true, results will filter only Zoo orders. */
                native?: boolean;
                /** If true, criteria metadata is included in the response. */
                includeCriteriaMetadata?: boolean;
                /** If true, raw data is included in the response. */
                includeRawData?: boolean;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Order the items are returned in the response. */
                sortBy?: "createdAt" | "price";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getOrdersBidsV5Response"];
            };
        };
    };
    getOrdersExecutedV1: {
        parameters: {
            query: {
                ids: string[] | string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    /** This API can be used to find top common collections among the given owners */
    getOwnersCommoncollectionsV1: {
        parameters: {
            query: {
                /** Array of owner addresses. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                owners: string[] | string;
                /** Amount of collections returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCommonCollectionsOwnersV1Response"];
            };
        };
    };
    /** Find which addresses own the most of a group of collections. */
    getOwnersCrosscollectionsV1: {
        parameters: {
            query: {
                /** Filter to one or more collections. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collections: string[] | string;
                /** Amount of owners returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCrossCollectionsOwnersV1Response"];
            };
        };
    };
    getRedirectLogoV1: {
        parameters: {
            query: {
                source: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getRedirectTokenV1: {
        parameters: {
            query: {
                source: string;
                /** Redirect to the given token page, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    /** Note: this API is optimized for bulk access, and offers minimal filters/metadata. If you need more flexibility, try the `NFT API > Sales` endpoint */
    getSalesBulkV1: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSalesBulkV1Response"];
            };
        };
    };
    getSearchCollectionsV1: {
        parameters: {
            query: {
                /** Lightweight search for collections that match a string. Example: `bored` */
                name?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Return result in given currency */
                displayCurrency?: string;
                /** Filter to a particular collection set */
                collectionsSetId?: string;
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getSearchCollectionsV1Response"];
            };
        };
    };
    /** Get the latest price event per token in a collection, so that you can listen to future events and keep track of prices */
    getTokensBootstrapV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensBootstrapV1Response"];
            };
        };
    };
    /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
    getTokensDetailsV2: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
                attributes?: string;
                /** Filter to a particular source, e.g. `0x5b3256965e7c3cf26e11fcaf296dfc8807c01073` */
                source?: string;
                sortBy?: "floorAskPrice" | "topBidValue";
                limit?: number;
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensDetailsV2Response"];
            };
        };
    };
    /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
    getTokensDetailsV3: {
        parameters: {
            query: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to one or more tokens, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                tokens?: string[] | string;
                /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                tokenSetId?: string;
                /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
                attributes?: string;
                /** Filter to a particular source, e.g. `0x5b3256965e7c3cf26e11fcaf296dfc8807c01073` */
                source?: string;
                sortBy?: "floorAskPrice" | "topBidValue";
                limit?: number;
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensDetailsV3Response"];
            };
        };
    };
    /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
    getTokensDetailsV4: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Array of tokens. Example: `tokens[0]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:704 tokens[1]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:979` */
                tokens?: string[] | string;
                /** Filter to a particular token set. `Example: token:0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270:129000685` */
                tokenSetId?: string;
                /** Filter to a particular attribute. Example: `attributes[Type]=Original` */
                attributes?: string;
                /** Domain of the order source. Example `opensea.io` */
                source?: string;
                /** Order the items are returned in the response. */
                sortBy?: "floorAskPrice" | "tokenId";
                sortDirection?: "asc" | "desc";
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensDetailsV4Response"];
            };
        };
    };
    /** This API will return the best price of every token in a collection that is currently on sale. Note: Prices are returned in the native currency of the network. */
    getTokensFloorV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensFloorV1Response"];
            };
        };
    };
    /** This API is optimized for quickly fetching a list of tokens ids in by collection, contract, token set id. */
    getTokensIdsV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token set. Example: token:0xa7d8d9ef8d8ce8992df33d8b8cf4aebabd5bd270:129000685 */
                tokenSetId?: string;
                /**
                 * -1 = All tokens (default)
                 * 0 = Non flagged tokens
                 * 1 = Flagged tokens
                 */
                flagStatus?: -1 | 0 | 1;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensIdsV1Response"];
            };
        };
    };
    /** Note: this API is optimized for bulk access, and offers minimal filters/metadata. If you need more flexibility, try the `NFT API > Transfers` endpoint */
    getTransfersBulkV1: {
        parameters: {
            query: {
                /** Filter to a particular contract. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTransfersBulkV1Response"];
            };
        };
    };
    /** This API can be used to build a feed for a user */
    getUsersActivityV2: {
        parameters: {
            query: {
                /** Array of users addresses. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                users: string[] | string;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: number;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserActivityV2Response"];
            };
        };
    };
    /** This API can be used to build a feed for a user */
    getUsersActivityV3: {
        parameters: {
            query: {
                /** Array of users addresses. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                users: string[] | string;
                /** Amount of items returned in response. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserActivityV3Response"];
            };
        };
    };
    /** This API can be used to build a feed for a user */
    getUsersActivityV4: {
        parameters: {
            query: {
                /** Array of users addresses. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                users: string[] | string;
                collection?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Amount of items returned in response. If `includeMetadata=true` max limit is 20, otherwise max limit is 1,000. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserActivityV4Response"];
            };
        };
    };
    /** This API can be used to build a feed for a user */
    getUsersActivityV5: {
        parameters: {
            query: {
                /** Array of users addresses. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                users: string[] | string;
                collection?: string[] | string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular contracts set. */
                contractsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Amount of items returned in response. If `includeMetadata=true` max limit is 20, otherwise max limit is 1,000. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserActivityV5Response"];
            };
        };
    };
    getCollectionsCollectionAttributesV1: {
        parameters: {
            path: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                attributeKey?: string;
                sortBy?: "floorAskPrice" | "topBidValue";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionAttributesV1Response"];
            };
        };
    };
    /** This API can be used to build a feed for a collection */
    getCollectionsCollectionActivityV2: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                /** Amount of items returned in response. If `includeMetadata=true` max limit is 20, otherwise max limit is 1,000. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionActivityV2Response"];
            };
        };
    };
    /** This API can be used to build a feed for a collection */
    getCollectionsCollectionActivityV1: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: number;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserActivityV2Response"];
            };
        };
    };
    /** This API can be used to build a feed for a collection */
    getCollectionsCollectionActivityV3: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                /** Amount of items returned in response. If `includeMetadata=true` max limit is 20, otherwise max limit is 1,000. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionActivityV3Response"];
            };
        };
    };
    /** When users are placing collection or trait bids, this API can be used to show them where the bid is in the context of other bids, and how many tokens it will be the top bid for. */
    getCollectionsCollectionTopbidsV1: {
        parameters: {
            path: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionTopBidsV1Response"];
            };
        };
    };
    /** This API can be used to show what the distribution of owners in a collection looks like. */
    getCollectionsCollectionOwnersdistributionV1: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionOwnersDistributionV1Response"];
            };
        };
    };
    /** This API can be used to show what the distribution of owners in a collections set looks like. */
    getCollectionssetsCollectionssetidOwnersdistributionV1: {
        parameters: {
            path: {
                /** Filter to a particular collections set. */
                collectionsSetId: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionOwnersDistributionV1Response"];
            };
        };
    };
    /**
     * Every time the floor price of a collection changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
     *
     * There are multiple event types, which describe what caused the change in price:
     *
     * - `new-order` > new listing at a lower price
     *
     * - `expiry` > the previous best listing expired
     *
     * - `sale` > the previous best listing was filled
     *
     * - `cancel` > the previous best listing was cancelled
     *
     * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
     *
     * - `approval-change` > the best listing was invalidated due to revoked approval
     *
     * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
     *
     * - `reprice` > price update for dynamic orders (e.g. dutch auctions)
     *
     * - `bootstrap` > initial loading of data, so that all tokens have a price associated
     *
     * Some considerations to keep in mind
     *
     * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
     *
     * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
     */
    getEventsCollectionsFlooraskV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** If true, will exclude floor asks on flagged tokens. (only supported when `normalizeRoyalties` is false) */
                excludeFlaggedTokens?: boolean;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsFloorAskV1Response"];
            };
        };
    };
    /** Every time the top offer of a collection changes (i.e. the 'top bid'), an event is generated. This API is designed to be polled at high frequency. */
    getEventsCollectionsTopbidV1: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsTopbidV1Response"];
            };
        };
    };
    /** Every time the top offer of a collection changes (i.e. the 'top bid'), an event is generated. This API is designed to be polled at high frequency. */
    getEventsCollectionsTopbidV2: {
        parameters: {
            query: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionsTopbidV2Response"];
            };
        };
    };
    /**
     * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
     *
     * There are multiple event types, which describe what caused the change in price:
     *
     * - `new-order` > new listing at a lower price
     *
     * - `expiry` > the previous best listing expired
     *
     * - `sale` > the previous best listing was filled
     *
     * - `cancel` > the previous best listing was cancelled
     *
     * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
     *
     * - `approval-change` > the best listing was invalidated due to revoked approval
     *
     * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
     *
     * - `reprice` > price update for dynamic orders (e.g. dutch auctions)
     *
     * - `bootstrap` > initial loading of data, so that all tokens have a price associated
     *
     * Some considerations to keep in mind
     *
     * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
     *
     * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
     */
    getEventsTokensFlooraskV2: {
        parameters: {
            query: {
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                sortDirection?: "asc" | "desc";
                continuation?: string;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensFloorAskV2Response"];
            };
        };
    };
    /**
     * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
     *
     * There are multiple event types, which describe what caused the change in price:
     *
     * - `new-order` > new listing at a lower price
     *
     * - `expiry` > the previous best listing expired
     *
     * - `sale` > the previous best listing was filled
     *
     * - `cancel` > the previous best listing was cancelled
     *
     * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
     *
     * - `approval-change` > the best listing was invalidated due to revoked approval
     *
     * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
     *
     * - `reprice` > price update for dynamic orders (e.g. dutch auctions)
     *
     * - `bootstrap` > initial loading of data, so that all tokens have a price associated
     *
     * Some considerations to keep in mind
     *
     * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
     *
     * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
     */
    getEventsTokensFlooraskV3: {
        parameters: {
            query: {
                contract?: string;
                /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token?: string;
                /** Get events after a particular unix timestamp (inclusive) */
                startTimestamp?: number;
                /** Get events before a particular unix timestamp (inclusive) */
                endTimestamp?: number;
                sortDirection?: "asc" | "desc";
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                continuation?: string;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokensFloorAskV3Response"];
            };
        };
    };
    /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
    getOracleCollectionsFlooraskV4: {
        parameters: {
            query: {
                kind?: "spot" | "twap" | "lower" | "upper";
                currency?: string;
                twapSeconds?: number;
                eip3668Calldata?: string;
                collection?: string;
                token?: string;
                /** If true, will use the collection non flagged floor ask events. */
                useNonFlaggedFloorAsk?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionFloorAskOracleV4Response"];
            };
        };
    };
    /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0xAeB1D03929bF87F69888f381e73FBf75753d75AF. */
    getOracleCollectionsFlooraskV5: {
        parameters: {
            query: {
                kind?: "spot" | "twap" | "lower" | "upper";
                currency?: string;
                twapSeconds?: number;
                eip3668Calldata?: string;
                collection?: string;
                token?: string;
                /** If true, will use the collection non flagged floor ask events. */
                useNonFlaggedFloorAsk?: boolean;
                signer?: "0x32da57e736e05f75aa4fae2e9be60fd904492726" | "0xaeb1d03929bf87f69888f381e73fbf75753d75af";
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionFloorAskOracleV4Response"];
            };
        };
    };
    /** Get a signed message of any collection's top bid price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
    getOracleCollectionsTopbidV1: {
        parameters: {
            query: {
                kind?: "spot" | "twap" | "lower" | "upper";
                currency?: string;
                twapSeconds?: number;
                collection?: string;
                token?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionTopBidOracleV1Response"];
            };
        };
    };
    /** Get a signed message of any collection's top bid price (spot or twap). The oracle's address is 0xAeB1D03929bF87F69888f381e73FBf75753d75AF. */
    getOracleCollectionsTopbidV2: {
        parameters: {
            query: {
                kind?: "spot" | "twap" | "lower" | "upper";
                currency?: string;
                twapSeconds?: number;
                collection?: string;
                token?: string;
                signer?: "0x32da57e736e05f75aa4fae2e9be60fd904492726" | "0xaeb1d03929bf87f69888f381e73fbf75753d75af";
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionTopBidOracleV1Response"];
            };
        };
    };
    /** Get a signed message of a token's details (flagged status and last transfer time). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
    getOracleTokensStatusV1: {
        parameters: {
            query: {
                tokens: string[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokenStatusOracleV1Response"];
            };
        };
    };
    /** Get a signed message of a token's details (flagged status and last transfer time). The oracle's address is 0xAeB1D03929bF87F69888f381e73FBf75753d75AF. */
    getOracleTokensStatusV2: {
        parameters: {
            query: {
                tokens: string[] | string;
                signer?: "0x32da57e736e05f75aa4fae2e9be60fd904492726" | "0xaeb1d03929bf87f69888f381e73fbf75753d75af";
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTokenStatusOracleV1Response"];
            };
        };
    };
    /** This API return the recent flagged/un-flagged tokens across all collections sorted by change time */
    getTokensFlagChangesV1: {
        parameters: {
            query: {
                /**
                 * -1 = All tokens (default)
                 * 0 = Non flagged tokens
                 * 1 = Flagged tokens
                 */
                flagStatus?: -1 | 0 | 1;
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getFlaggedTokensV1Response"];
            };
        };
    };
    /** This API can be used to build a feed for a token */
    getTokensTokenActivityV3: {
        parameters: {
            path: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
            };
            query: {
                /** Amount of items returned in response. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionActivityV4Response"];
            };
        };
    };
    /** This API can be used to build a feed for a token */
    getTokensTokenActivityV1: {
        parameters: {
            path: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
            };
            query: {
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: number;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserActivityV2Response"];
            };
        };
    };
    /** This API can be used to build a feed for a token */
    getTokensTokenActivityV2: {
        parameters: {
            path: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
            };
            query: {
                /** Amount of items returned in response. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionActivityV2Response"];
            };
        };
    };
    /** This API can be used to build a feed for a token */
    getTokensTokenActivityV4: {
        parameters: {
            path: {
                /** Filter to a particular token. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
            };
            query: {
                /** Amount of items returned in response. */
                limit?: number;
                /** Order the items are returned in the response, eventTimestamp = The blockchain event time, createdAt - The time in which event was recorded */
                sortBy?: "eventTimestamp" | "createdAt";
                /** If true, metadata is included in the response. */
                includeMetadata?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionActivityV5Response"];
            };
        };
    };
    /** Get a boolean response on whether a particular transaction was synced or not. */
    getTransactionsTxhashSyncedV1: {
        parameters: {
            path: {
                txHash: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getTransactionSyncedV1Response"];
            };
        };
    };
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    getUsersUserTokensV6: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Array of tokens. Example: `tokens[0]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:704 tokens[1]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:979` */
                tokens?: string[] | string;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** If true, will return the collection non flagged floor ask. */
                useNonFlaggedFloorAsk?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTokensV6Response"];
            };
        };
    };
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    getUsersUserTokensV4: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Order the items are returned in the response. */
                sortBy?: "acquiredAt";
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTokensV4Response"];
            };
        };
    };
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    getUsersUserTokensV2: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Order the items are returned in the response. */
                sortBy?: "acquiredAt";
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTokensV2Response"];
            };
        };
    };
    /** Get aggregate user liquidity, grouped by collection. Useful for showing a summary of liquidity being provided (orders made). */
    getUsersUserPositionsV1: {
        parameters: {
            path: {
                /** Wallet to see results for e.g. `0xf296178d553c8ec21a2fbd2c5dda8ca9ac905a00` */
                user: string;
            };
            query: {
                side: "buy" | "sell";
                status: "valid" | "invalid";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserPositionsV1Response"];
            };
        };
    };
    /** Get aggregate stats for a user, grouped by collection. Useful for showing total portfolio information. */
    getUsersUserCollectionsV1: {
        parameters: {
            path: {
                /** Wallet to see results for e.g. `0xf296178d553c8ec21a2fbd2c5dda8ca9ac905a00` */
                user: string;
            };
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserCollectionsV1Response"];
            };
        };
    };
    /** This API can be used to build a feed for a user */
    getUsersUserActivityV1: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                /** Amount of items returned in response. */
                limit?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: number;
                types?: ("sale" | "ask" | "transfer" | "mint" | "bid" | "bid_cancel" | "ask_cancel")[] | string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserActivityV1Response"];
            };
        };
    };
    /** Get aggregate stats for a user, grouped by collection. Useful for showing total portfolio information. */
    getUsersUserCollectionsV2: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** If true, number of tokens with bids will be returned in the response. */
                includeLiquidCount?: boolean;
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserCollectionsV2Response"];
            };
        };
    };
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    getUsersUserTokensV1: {
        parameters: {
            path: {
                user: string;
            };
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                hasOffer?: boolean;
                sortBy?: "topBuyValue";
                sortDirection?: "asc" | "desc";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTokensV1Response"];
            };
        };
    };
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    getUsersUserTokensV3: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Order the items are returned in the response. */
                sortBy?: "acquiredAt";
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTokensV3Response"];
            };
        };
    };
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    getUsersUserTokensV5: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                /** Filter to a particular community, e.g. `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection?: string;
                /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                contract?: string;
                /** Array of tokens. Example: `tokens[0]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:704 tokens[1]: 0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:979` */
                tokens?: string[] | string;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Order the items are returned in the response. */
                sortBy?: "acquiredAt";
                /** Order the items are returned in the response. */
                sortDirection?: "asc" | "desc";
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTokensV5Response"];
            };
        };
    };
    /** Get detailed aggregate about attributes in a collection, attribute floors */
    getCollectionsCollectionAttributesExploreV4: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** If true, range traits will be excluded from the response. */
                excludeRangeTraits?: boolean;
                /** If true, number traits will be excluded from the response. */
                excludeNumberTraits?: boolean;
                /** Filter to a particular attribute key. Example: `Composition` */
                attributeKey?: string;
                /** Max number of items returned in the response. */
                maxFloorAskPrices?: number;
                /** Max number of items returned in the response. */
                maxLastSells?: number;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAttributesExploreV4Response"];
            };
        };
    };
    /** Get detailed aggregate about attributes in a collection, attribute floors */
    getCollectionsCollectionAttributesExploreV2: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                /** Filter to a particular attribute key. Example: `Composition` */
                attributeKey?: string;
                /** Max number of items returned in the response. */
                maxFloorAskPrices?: number;
                /** Max number of items returned in the response. */
                maxLastSells?: number;
                /** Order the items are returned in the response. */
                sortBy?: "floorAskPrice" | "topBidValue";
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAttributesExploreV2Response"];
            };
        };
    };
    getCollectionsCollectionAttributesAllV2: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAttributesAllV2Response"];
            };
        };
    };
    getCollectionsCollectionAttributesAllV1: {
        parameters: {
            path: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAttributesV1Response"];
            };
        };
    };
    getCollectionsCollectionAttributesStaticV1: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAttributesStaticV1Response"];
            };
        };
    };
    getCollectionsCollectionAttributesExploreV1: {
        parameters: {
            path: {
                /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                /** Filter to a particular attribute key, e.g. `Composition` */
                attributeKey?: string;
                sortBy?: "floorAskPrice" | "topBidValue";
                offset?: number;
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionAttributesV1Response"];
            };
        };
    };
    /** Get detailed aggregate about attributes in a collection, attribute floors */
    getCollectionsCollectionAttributesExploreV3: {
        parameters: {
            path: {
                /** Filter to a particular collection with collection-id. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
            query: {
                /** If true, top bid will be returned in the response. */
                includeTopBid?: boolean;
                /** Filter to a particular attribute key. Example: `Composition` */
                attributeKey?: string;
                /** Max number of items returned in the response. */
                maxFloorAskPrices?: number;
                /** Max number of items returned in the response. */
                maxLastSells?: number;
                /** Order the items are returned in the response. */
                sortBy?: "floorAskPrice" | "topBidValue";
                /** Use offset to request the next batch of items. */
                offset?: number;
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getAttributesExploreV3Response"];
            };
        };
    };
    /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
    getOracleCollectionsCollectionFlooraskV2: {
        parameters: {
            path: {
                collection: string;
            };
            query: {
                kind?: "spot" | "twap" | "lower" | "upper";
                currency?: string;
                twapHours?: number;
                eip3668Calldata?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionFloorAskOracleV4Response"];
            };
        };
    };
    /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
    getOracleCollectionsCollectionFlooraskV1: {
        parameters: {
            path: {
                collection: string;
            };
            query: {
                kind?: "spot" | "twap" | "lower" | "upper";
                currency?: string;
                twapHours?: number;
                eip3668Calldata?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionFloorAskOracleV4Response"];
            };
        };
    };
    /** Get a signed message of any collection's floor price (spot or twap). The oracle's address is 0x32dA57E736E05f75aa4FaE2E9Be60FD904492726. */
    getOracleCollectionsCollectionFlooraskV3: {
        parameters: {
            path: {
                collection: string;
            };
            query: {
                kind?: "spot" | "twap" | "lower" | "upper";
                currency?: string;
                twapSeconds?: number;
                eip3668Calldata?: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getCollectionFloorAskOracleV4Response"];
            };
        };
    };
    /** Return the top bids for the given user tokens */
    getOrdersUsersUserTopbidsV2: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                collection?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** If true, urls will only be returned for optimized sources that support royalties. */
                optimizeCheckoutURL?: boolean;
                /** If true, criteria metadata is included in the response. */
                includeCriteriaMetadata?: boolean;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** If true, will return the collection non flagged floor ask events. */
                useNonFlaggedFloorAsk?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Order of the items are returned in the response. */
                sortBy?: "topBidValue" | "dateCreated" | "orderExpiry" | "floorDifferencePercentage";
                sortDirection?: "asc" | "desc";
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTopBidsV2Response"];
            };
        };
    };
    /** Return the top bids for the given user tokens */
    getOrdersUsersUserTopbidsV1: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                collection?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** If true, urls will only be returned for optimized sources that support royalties. */
                optimizeCheckoutURL?: boolean;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Order of the items are returned in the response. */
                sortBy?: "topBidValue" | "dateCreated" | "orderExpiry" | "floorDifferencePercentage";
                sortDirection?: "asc" | "desc";
                /** Amount of items returned in response. */
                limit?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTopBidsV1Response"];
            };
        };
    };
    /** Return the top bids for the given user tokens */
    getOrdersUsersUserTopbidsV3: {
        parameters: {
            path: {
                /** Filter to a particular user. Example: `0xF296178d553C8Ec21A2fBD2c5dDa8CA9ac905A00` */
                user: string;
            };
            query: {
                collection?: string;
                /** Filter to a particular contracts set. */
                contractsSetId?: string;
                /** Filter to a particular community. Example: `artblocks` */
                community?: string;
                /** Filter to a particular collection set. */
                collectionsSetId?: string;
                /** If true, urls will only be returned for optimized sources that support royalties. */
                optimizeCheckoutURL?: boolean;
                /** If true, criteria metadata is included in the response. */
                includeCriteriaMetadata?: boolean;
                /** If true, prices will include missing royalties to be added on-top. */
                normalizeRoyalties?: boolean;
                /** If true, will return the collection non flagged floor ask events. */
                useNonFlaggedFloorAsk?: boolean;
                /** Use continuation token to request next offset of items. */
                continuation?: string;
                /** Order of the items are returned in the response. */
                sortBy?: "topBidValue" | "dateCreated" | "orderExpiry" | "floorDifferencePercentage";
                sortDirection?: "asc" | "desc";
                /** Amount of items returned in response. */
                limit?: number;
                /** Amount of tokens considered. */
                sampleSize?: number;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getUserTopBidsV3Response"];
            };
        };
    };
    getRedirectCollectionsCollectionImageV1: {
        parameters: {
            path: {
                /** Redirect to the given collection image. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                collection: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getRedirectCurrencyAddressIconV1: {
        parameters: {
            path: {
                /** Redirect to the given currency address icon. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
                address: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getRedirectSourcesSourceLogoV2: {
        parameters: {
            path: {
                /** Domain of the source. Example `opensea.io` */
                source: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getRedirectTokensTokenImageV1: {
        parameters: {
            path: {
                /** Redirect to the given token image. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    getRedirectSourcesSourceTokensTokenLinkV2: {
        parameters: {
            path: {
                /** Domain of the source. Example `opensea.io` */
                source: string;
                /** Redirect to the given token page. Example: `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
                token: string;
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    putCollectionsCollectionCommunityV1: {
        parameters: {
            header: {
                "x-api-key": string;
            };
            path: {
                /** Update community for a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63`. Requires an authorized api key to be passed. */
                collection: string;
            };
            body: {
                body?: definitions["Model265"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
    /**
     * The API key can be used in every route, by setting it as a request header **x-api-key**.
     *
     * <a href='https://docs.reservoir.tools/reference/getting-started'>Learn more</a> about API Keys and Rate Limiting
     */
    postApikeys: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            formData: {
                /** The name of your app */
                appName: string;
                /** An e-mail address where you can be reached, in case of issues, to avoid service disruption */
                email: string;
                /** The website of your project */
                website: string;
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getNewApiKeyResponse"];
            };
        };
    };
    postAdminCalcrarity: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model266"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminCreateratelimitrule: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model267"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminDeleteratelimitrule: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model268"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminFixblocks: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model269"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminFixcache: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model270"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminFixorders: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model271"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminFixtokencache: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model272"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminFlagaddress: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model273"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminIndexmetadata: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model274"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminRefreshcollection: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model275"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminRefreshcollectionflags: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model276"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminRefreshtoken: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model277"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminResyncfloorevents: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model278"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminResyncsource: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model279"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminRevalidateorder: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model280"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminRouters: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model281"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminSetcommunity: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model282"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminSyncarweave: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model283"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminSyncdailyvolumes: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model284"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminSyncevents: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model286"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminUpdateapikey: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model287"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminUpdateratelimitrule: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model288"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postAdminUpdatesource: {
        parameters: {
            header: {
                "x-admin-api-key": string;
            };
            body: {
                body?: definitions["Model289"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postCollectionssetsV1: {
        parameters: {
            body: {
                body?: definitions["Model291"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["postCreateCollectionsSetV1Response"];
            };
        };
    };
    postContractssetsV1: {
        parameters: {
            body: {
                body?: definitions["Model293"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["postCreateContractsSetV1Response"];
            };
        };
    };
    postOrderV2: {
        parameters: {
            query: {
                signature?: string;
            };
            body: {
                body?: definitions["Model295"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postOrderV3: {
        parameters: {
            query: {
                signature?: string;
            };
            body: {
                body?: definitions["Model297"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postOrderV4: {
        parameters: {
            query: {
                signature?: string;
            };
            body: {
                body?: definitions["Model302"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postSeaportOffers: {
        parameters: {
            body: {
                body?: definitions["Model307"];
            };
        };
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postTokensetsV1: {
        parameters: {
            body: {
                body?: definitions["Model308"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["Model188"];
            };
        };
    };
    postTokensetsV2: {
        parameters: {
            body: {
                body?: definitions["Model310"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["Model188"];
            };
        };
    };
    postWebsocketUserauth: {
        responses: {
            /** Successful */
            default: {
                schema: string;
            };
        };
    };
    postCollectionsRefreshV1: {
        parameters: {
            header: {
                "x-api-key"?: string;
            };
            body: {
                body?: definitions["Model311"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
    /** Generate a bid and submit it to multiple marketplaces */
    postExecuteBidV4: {
        parameters: {
            body: {
                body?: definitions["Model313"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBidV4Response"];
            };
        };
    };
    /** Generate bids and submit them to multiple marketplaces */
    postExecuteBidV5: {
        parameters: {
            body: {
                body?: definitions["Model318"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBidV5Response"];
            };
        };
    };
    postExecuteBuyV4: {
        parameters: {
            body: {
                body?: definitions["Model326"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV3Response"];
            };
        };
    };
    postExecuteBuyV5: {
        parameters: {
            body: {
                body?: definitions["Model328"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV3Response"];
            };
        };
    };
    postExecuteBuyV6: {
        parameters: {
            body: {
                body?: definitions["Model332"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV6Response"];
            };
        };
    };
    postExecuteBuyV7: {
        parameters: {
            body: {
                body?: definitions["Model337"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV7Response"];
            };
        };
    };
    /** Generate a listing and submit it to multiple marketplaces */
    postExecuteListV3: {
        parameters: {
            body: {
                body?: definitions["Model342"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteListV3Response"];
            };
        };
    };
    /** Generate a listing and submit it to multiple marketplaces */
    postExecuteListV4: {
        parameters: {
            body: {
                body?: definitions["Model347"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteListV4Response"];
            };
        };
    };
    /** Generate listings and submit them to multiple marketplaces */
    postExecuteListV5: {
        parameters: {
            body: {
                body?: definitions["Model350"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBidV5Response"];
            };
        };
    };
    postExecutePermitsignatureV1: {
        parameters: {
            query: {
                /** Signature to attach to the permit */
                signature: string;
            };
            body: {
                body?: definitions["Model351"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
    postExecuteSellV4: {
        parameters: {
            body: {
                body?: definitions["Model352"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV3Response"];
            };
        };
    };
    postExecuteSellV5: {
        parameters: {
            body: {
                body?: definitions["Model353"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV3Response"];
            };
        };
    };
    postExecuteSellV6: {
        parameters: {
            body: {
                body?: definitions["Model356"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV6Response"];
            };
        };
    };
    postExecuteSellV7: {
        parameters: {
            body: {
                body?: definitions["Model360"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["getExecuteBuyV7Response"];
            };
        };
    };
    postTokensFlagV1: {
        parameters: {
            body: {
                body?: definitions["Model361"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
    postTokensRefreshV1: {
        parameters: {
            body: {
                body?: definitions["Model362"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
    postTokensSimulatefloorV1: {
        parameters: {
            body: {
                body?: definitions["Model363"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
    postTokensSimulatetopbidV1: {
        parameters: {
            body: {
                body?: definitions["Model364"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
    postManagementOrdersSimulateV1: {
        parameters: {
            body: {
                body?: definitions["Model365"];
            };
        };
        responses: {
            /** Successful */
            200: {
                schema: definitions["putSetCollectionCommunityV1Response"];
            };
        };
    };
}
export interface external {
}
export type Execute = {
    error?: string;
    path: paths['/execute/buy/v3']['get']['responses']['200']['schema']['path'] | paths['/execute/sell/v3']['get']['responses']['200']['schema']['path'];
    steps: {
        message?: string;
        error?: string;
        errorData?: any;
        action: string;
        description: string;
        kind: 'transaction' | 'signature';
        items?: {
            status: 'complete' | 'incomplete';
            data?: any;
            txHash?: string;
            orderId?: string;
            orderIndex?: number;
        }[];
    }[];
};
/**
 * Poll the URL with a 5 second interval until the step has data
 * available
 * @param url an URL object
 * @param index The index of the step to be polled for
 * @param maximumAttempts The maximum amount of tries for this poll
 * @param attemptCount The amount of attempts already done by the poll, should be left blank
 * @returns The updated JSON response
 */
export function pollUntilHasData(request: AxiosRequestConfig, dataParser: (json: any) => boolean, maximumAttempts?: number, attemptCount?: number): Promise<any>;
/**
 * Poll the URL with a 5 second interval until it responds with success
 * @param url An URL object
 * @param validate A function that checks if the request is "ok" or valid
 * @param maximumAttempts The maximum amount of tries for this poll
 * @param attemptCount The amount of attempts already done by the poll, should be left blank
 * @returns When it has finished polling
 */
export function pollUntilOk(request: AxiosRequestConfig, validate?: (res: AxiosResponse) => boolean, maximumAttempts?: number, attemptCount?: number): Promise<boolean>;
/**
 *  Set URL query params using a typed objects
 *
 * This will convert an object
 *
 * ```js
 *  {
 *    foo: 'bar',
 *    age: 50,
 *  }
 * ```
 *
 * into a query string
 *
 * `?foo=bar&age=50`
 *
 * and append it to URL provided
 *
 * `https://api.example.com/tokens?foo=bar&age=50`
 *
 * @param url An URL instance
 * @param query An object containing all needed query params.
 */
export function setParams(url: URL, query: {
    [x: string]: any;
}): void;
/**
 * When attempting to perform actions, such as, selling a token or
 * buying a token, the user's account needs to meet certain requirements. For
 * example, if the user attempts to buy a token the Zoo API checks if the
 * user has enough balance, before providing the transaction to be signed by
 * the user. This function executes all transactions, in order, to complete the
 * action.
 * @param request AxiosRequestConfig object with at least a url set
 * @param signer Ethereum signer object provided by the browser
 * @param setState Callback to update UI state has execution progresses
 * @returns The data field of the last element in the steps array
 */
export function executeSteps(request: AxiosRequestConfig, signer: Signer, setState: (steps: Execute['steps']) => any, newJson?: Execute, expectedPrice?: number): Promise<void>;
/**
 * Check if tokens are banned on OpenSea
 * @param tokens An array of token ids (e.g. ["123:0xabc123"])
 * @returns `{tokenId: true}` A dictionary of token banned status from OpenSea.
 */
export function isOpenSeaBanned(ids: string[]): Promise<Record<string, boolean>>;
export function request(config?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any, any>>;
type Token = Pick<NonNullable<NonNullable<paths['/tokens/v5']['get']['responses']['200']['schema']['tokens']>[0]['token']>, 'tokenId' | 'contract'>;
type AcceptOfferBodyParameters = paths['/execute/sell/v6']['post']['parameters']['body']['body'];
type AcceptOfferOptions = Partial<Omit<AcceptOfferBodyParameters, 'token'>>;
type Data = {
    token: Token;
    options?: AcceptOfferOptions;
    expectedPrice?: number;
    signer: Signer;
    onProgress: (steps: Execute['steps']) => any;
};
/**
 * Accept an offer to buy your token
 * @param data.token Token being accepted
 * @param data.expectedPrice Token price used to prevent to protect buyer from price moves. Pass the number with unit 'ether'. Example: `1.543` means 1.543 ETH
 * @param data.signer Ethereum signer object provided by the browser
 * @param data.options Additional options to pass into the accept request
 * @param data.onProgress Callback to update UI state as execution progresses
 */
declare function acceptOffer(data: Data): Promise<boolean>;
type _Token1 = Pick<NonNullable<NonNullable<paths['/tokens/v5']['get']['responses']['200']['schema']['tokens']>[0]['token']>, 'tokenId' | 'contract'>;
type BuyTokenBodyParameters = NonNullable<paths['/execute/buy/v6']['post']['parameters']['body']['body']>;
type BuyTokenOptions = Partial<Omit<BuyTokenBodyParameters, 'source' | 'tokens' | 'orderIds' | 'rawOrders'>>;
type BuyTokenRequiredOptions = Pick<BuyTokenBodyParameters, 'orderIds' | 'rawOrders'>;
type _Data1 = BuyTokenRequiredOptions & {
    tokens?: _Token1[];
    expectedPrice?: number;
    options?: BuyTokenOptions;
    signer: Signer;
    onProgress: (steps: Execute['steps']) => any;
};
/**
 * Instantly buy a token
 * @param data.tokens Tokens to be purchased (mutually exclusive with rawOrders and orderIds)
 * @param data.orderIds OrderIds to be purchased (mutually exclusive with tokens and rawOrders)
 * @param data.rawOrders RawOrders to be purchased (mutually exclusive with tokens and orderIds)
 * @param data.expectedPrice Token price used to prevent to protect buyer from price moves. Pass the number with unit 'ether'. Example: `1.543` means 1.543 ETH
 * @param data.options Additional options to pass into the buy request
 * @param data.signer Ethereum signer object provided by the browser
 * @param data.onProgress Callback to update UI state as execution progresses
 */
declare function buyToken(data: _Data1): Promise<boolean>;
type CancelOrderPathParameters = paths['/execute/cancel/v2']['get']['parameters']['query'];
type CancelOrderOptions = Omit<CancelOrderPathParameters, 'maker' | 'id'>;
type _Data2 = {
    id: CancelOrderPathParameters['id'];
    signer: Signer;
    options?: CancelOrderOptions;
    onProgress: (steps: Execute['steps']) => any;
};
/**
 * Cancel an offer or listing
 * @param data.id Id of the order to cancel
 * @param data.signer Ethereum signer object provided by the browser
 * @param data.options Additional options to pass into the cancel request
 * @param data.onProgress Callback to update UI state has execution progresses
 */
declare function cancelOrder(data: _Data2): Promise<boolean>;
type ListTokenBody = NonNullable<paths['/execute/list/v4']['post']['parameters']['body']['body']>;
type _Data3 = {
    listings: Required<ListTokenBody>['params'];
    signer: Signer;
    onProgress?: (steps: Execute['steps']) => any;
    precheck?: boolean;
};
/**
 * List a token for sale
 * @param data.listings Listings data to be processed
 * @param data.signer Ethereum signer object provided by the browser
 * @param data.onProgress Callback to update UI state as execution progresses
 * @param data.precheck Set to true to skip executing steps and just to get the initial steps required
 */
declare function listToken(data: _Data3): Promise<Execute['steps'] | boolean>;
type PlaceBidBody = NonNullable<paths['/execute/bid/v4']['post']['parameters']['body']['body']>;
type _Data4 = {
    bids: Required<PlaceBidBody>['params'];
    signer: Signer;
    onProgress: (steps: Execute['steps']) => any;
};
/**
 * Place a bid on a token
 * @param data.bids Bidding data to be processed
 * @param data.signer Ethereum signer object provided by the browser
 * @param data.onProgress Callback to update UI state as execution progresses
 */
declare function placeBid({ bids, signer, onProgress }: _Data4): Promise<boolean>;
declare const actions: {
    acceptOffer: typeof acceptOffer;
    buyToken: typeof buyToken;
    cancelOrder: typeof cancelOrder;
    listToken: typeof listToken;
    placeBid: typeof placeBid;
};
export type ZooChain = {
    id: number;
    baseApiUrl: string;
    default: boolean;
    apiKey?: string;
};
/**
 * ZooClient Configuration Options
 * @param chains List of chain objects with configuration (id, baseApiUrl, apiKey and if it's the default)
 * @param source Used to manually override the source domain used to attribute local orders
 * @param automatedRoyalties If true, royalties will be automatically included, defaults to true. Only relevant for creating orders.
 * @param marketplaceFee Fee in bps included when creating an order (listing & bidding)
 * @param marketplaceFeeRecipient Marketplace fee recipient
 * @param normalizeRoyalties Normalize orders that don't have royalties by apply royalties on top of them
 */
export type ZooClientOptions = {
    chains: ZooChain[];
    uiVersion?: string;
    source?: string;
    automatedRoyalties?: boolean;
    marketplaceFee?: number;
    marketplaceFeeRecipient?: string;
    normalizeRoyalties?: boolean;
};
export type ZooClientActions = typeof actions;
export class ZooClient {
    version: string;
    chains: ZooChain[];
    source?: string;
    uiVersion?: string;
    marketplaceFee?: number;
    marketplaceFeeRecipient?: string;
    automatedRoyalties?: boolean;
    normalizeRoyalties?: boolean;
    readonly utils: {
        executeSteps: typeof executeSteps;
        setParams: typeof setParams;
        pollUntilOk: typeof pollUntilOk;
        pollUntilHasData: typeof pollUntilHasData;
        isOpenSeaBanned: typeof isOpenSeaBanned;
        request: typeof request;
    };
    readonly actions: ZooClientActions;
    constructor(options: ZooClientOptions);
    configure(options: ZooClientOptions): void;
    currentChain(): ZooChain | null;
}
export function getClient(): ZooClient;
export function createClient(options: ZooClientOptions): ZooClient;

//# sourceMappingURL=index.d.ts.map
